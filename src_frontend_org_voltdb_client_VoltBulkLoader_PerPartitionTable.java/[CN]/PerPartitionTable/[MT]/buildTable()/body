{
  PartitionProcedureCallback nextCallback;
  List<VoltBulkLoaderRow> batchList=new ArrayList<VoltBulkLoaderRow>();
  m_partitionRowQueue.drainTo(batchList,m_minBatchTriggerSize);
  m_partitionQueuedRowCnt.addAndGet(-1 * batchList.size());
  ArrayList<LoaderPair> usedLoaderList=new ArrayList<LoaderPair>();
  ArrayList<VoltBulkLoaderRow> notificationList=new ArrayList<VoltBulkLoaderRow>();
  for (Iterator<VoltBulkLoaderRow> it=batchList.iterator(); it.hasNext(); ) {
    VoltBulkLoaderRow currRow=it.next();
    VoltBulkLoader loader=currRow.loader;
    if (currRow.isNotificationRow()) {
      notificationList.add(currRow);
      it.remove();
      continue;
    }
    Object row_args[];
    row_args=new Object[currRow.objectList.length];
    try {
      for (int i=0; i < row_args.length; i++) {
        final VoltType type=m_columnTypes[i];
        row_args[i]=ParameterConverter.tryToMakeCompatible(type.classFromType(),currRow.objectList[i]);
      }
    }
 catch (    VoltTypeException e) {
      loader.generateError(currRow.rowHandle,currRow.objectList,e.getMessage());
      loader.m_loaderQueuedRowCnt.decrementAndGet();
      it.remove();
      continue;
    }
    table.addRow(row_args);
    LoaderPair currLoaderPair=loader.m_currBatchPair[m_partitionId];
    if (currLoaderPair == null) {
      try {
        currLoaderPair=(LoaderPair)loader.m_availLoaderPairs.pop();
      }
 catch (      EmptyStackException e) {
        currLoaderPair=new LoaderPair(loader,0);
        loader.m_outstandingRowCnts[m_partitionId].add(currLoaderPair);
      }
      currLoaderPair.rowCnt=0;
      usedLoaderList.add(currLoaderPair);
      loader.m_currBatchPair[m_partitionId]=currLoaderPair;
    }
    currLoaderPair.rowCnt++;
  }
  for (  LoaderPair currPair : usedLoaderList) {
    currPair.loader.m_currBatchPair[m_partitionId]=null;
    currPair.loader.m_loaderBatchedRowCnt.addAndGet(currPair.rowCnt);
    currPair.loader.m_loaderQueuedRowCnt.addAndGet(-1 * currPair.rowCnt);
  }
synchronized (PerPartitionTable.this) {
    if (notificationList.size() > 0) {
      Node<PartitionProcedureCallback> currCallbackNode=m_activeCallbacks.getFirst();
      while (currCallbackNode != null) {
        currCallbackNode.item.m_notificationRows.addAll(notificationList);
        currCallbackNode=m_activeCallbacks.getNext(currCallbackNode);
      }
    }
    nextCallback=new PartitionProcedureCallback(batchList,usedLoaderList,notificationList);
    if (m_activeCallbacks.size > 0) {
      for (      VoltBulkLoaderRow currRow : notificationList)       ((BulkLoaderNotification)currRow.rowHandle).setBatchCount(m_activeCallbacks.size);
    }
 else {
      for (      VoltBulkLoaderRow currRow : notificationList)       ((BulkLoaderNotification)currRow.rowHandle).notifyOfClientResponse();
    }
  }
  return nextCallback;
}
