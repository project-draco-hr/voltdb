{
  ArrayList<LoaderSpecificRowCnt> usedLoaderList=new ArrayList<LoaderSpecificRowCnt>();
  ArrayList<VoltBulkLoaderRow> buf=new ArrayList<VoltBulkLoaderRow>(m_minBatchTriggerSize);
  m_partitionRowQueue.drainTo(buf,m_minBatchTriggerSize);
  ListIterator<VoltBulkLoaderRow> it=buf.listIterator();
  while (it.hasNext()) {
    VoltBulkLoaderRow currRow=it.next();
    VoltBulkLoader loader=currRow.m_loader;
    Object row_args[];
    row_args=new Object[currRow.m_rowData.length];
    try {
      for (int i=0; i < row_args.length; i++) {
        final VoltType type=m_columnTypes[i];
        row_args[i]=ParameterConverter.tryToMakeCompatible(type.classFromType(),currRow.m_rowData[i]);
      }
    }
 catch (    VoltTypeException e) {
      loader.generateError(currRow.m_rowHandle,currRow.m_rowData,e.getMessage());
      loader.m_loaderQueuedRowCnt.decrementAndGet();
      it.remove();
      continue;
    }
    table.addRow(row_args);
    LoaderSpecificRowCnt currLoaderPair=loader.m_currBatchPair[m_partitionId];
    if (currLoaderPair == null) {
      try {
        currLoaderPair=(LoaderSpecificRowCnt)loader.m_availLoaderPairs.pop();
      }
 catch (      EmptyStackException e) {
        currLoaderPair=new LoaderSpecificRowCnt(loader,0);
        loader.m_outstandingRowCnts[m_partitionId].add(currLoaderPair);
      }
      currLoaderPair.rowCnt=0;
      usedLoaderList.add(currLoaderPair);
      loader.m_currBatchPair[m_partitionId]=currLoaderPair;
    }
    currLoaderPair.rowCnt++;
  }
  for (  LoaderSpecificRowCnt currPair : usedLoaderList) {
    currPair.loader.m_currBatchPair[m_partitionId]=null;
    currPair.loader.m_loaderBatchedRowCnt.addAndGet(currPair.rowCnt);
    currPair.loader.m_loaderQueuedRowCnt.addAndGet(-1 * currPair.rowCnt);
  }
  return new PartitionProcedureCallback(buf,usedLoaderList);
}
