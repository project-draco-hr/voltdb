{
  byte nextTypeByte=in.readByte();
  if (nextTypeByte == ARRAY) {
    VoltType nextType=VoltType.get(in.readByte());
    if (nextType == null)     return null;
    return in.readArray(nextType.classFromType());
  }
 else {
    VoltType nextType=VoltType.get(nextTypeByte);
switch (nextType) {
case NULL:
      return null;
case TINYINT:
    return in.readByte();
case SMALLINT:
  return in.readShort();
case INTEGER:
return in.readInt();
case BIGINT:
return in.readLong();
case FLOAT:
return in.readDouble();
case STRING:
String string_val=(enforceSizeLimits ? in.readString() : in.readStringUnlimited());
if (string_val == null) {
return VoltType.NULL_STRING_OR_VARBINARY;
}
return string_val;
case VARBINARY:
byte[] bin_val=(enforceSizeLimits ? in.readVarbinary() : in.readVarbinaryUnlimited());
if (bin_val == null) {
return VoltType.NULL_STRING_OR_VARBINARY;
}
return bin_val;
case TIMESTAMP:
final long micros=in.readLong();
return new TimestampType(micros);
case VOLTTABLE:
return in.readObject(VoltTable.class);
case DECIMAL:
{
BigDecimal decimal_val=in.readBigDecimal();
if (decimal_val == null) {
return VoltType.NULL_DECIMAL;
}
return decimal_val;
}
case DECIMAL_STRING:
{
BigDecimal decimal_val=in.readBigDecimalFromString();
if (decimal_val == null) {
return VoltType.NULL_DECIMAL;
}
return decimal_val;
}
default :
throw new RuntimeException("ParameterSet doesn't support type " + nextType);
}
}
}
