{
  buf.putShort((short)m_params.length);
  for (int i=0; i < m_params.length; i++) {
    Object obj=m_params[i];
    if ((obj == null) || (obj == JSONObject.NULL)) {
      VoltType type=VoltType.NULL;
      buf.put(type.getValue());
      continue;
    }
    Class<?> cls=obj.getClass();
    if (cls.isArray()) {
      if (obj instanceof byte[]) {
        final byte[] b=(byte[])obj;
        buf.put(VoltType.VARBINARY.getValue());
        buf.putInt(b.length);
        buf.put(b);
        continue;
      }
      buf.put(ARRAY);
      VoltType type;
      try {
        type=VoltType.typeFromClass(cls.getComponentType());
      }
 catch (      VoltTypeException e) {
        obj=getAKosherArray((Object[])obj);
        cls=obj.getClass();
        type=VoltType.typeFromClass(cls.getComponentType());
      }
      buf.put(type.getValue());
switch (type) {
case SMALLINT:
        FastSerializer.writeArray((short[])obj,buf);
      break;
case INTEGER:
    FastSerializer.writeArray((int[])obj,buf);
  break;
case BIGINT:
FastSerializer.writeArray((long[])obj,buf);
break;
case FLOAT:
FastSerializer.writeArray((double[])obj,buf);
break;
case STRING:
if (m_encodedStringArrays[i] == null) {
throw new IOException("String array not encoded");
}
if (m_encodedStringArrays[i].length > Short.MAX_VALUE) {
throw new IOException("Array exceeds maximum length of " + Short.MAX_VALUE + " bytes");
}
buf.putShort((short)m_encodedStringArrays[i].length);
for (int zz=0; zz < m_encodedStringArrays[i].length; zz++) {
FastSerializer.writeString(m_encodedStringArrays[i][zz],buf);
}
break;
case TIMESTAMP:
FastSerializer.writeArray((TimestampType[])obj,buf);
break;
case DECIMAL:
FastSerializer.writeArray((BigDecimal[])obj,buf);
break;
case VOLTTABLE:
FastSerializer.writeArray((VoltTable[])obj,buf);
break;
case VARBINARY:
FastSerializer.writeArray((byte[][])obj,buf);
break;
default :
throw new RuntimeException("FIXME: Unsupported type " + type);
}
continue;
}
if (obj == VoltType.NULL_TIMESTAMP) {
buf.put(VoltType.TIMESTAMP.getValue());
buf.putLong(VoltType.NULL_BIGINT);
continue;
}
 else if (obj == VoltType.NULL_STRING_OR_VARBINARY) {
buf.put(VoltType.STRING.getValue());
buf.putInt(VoltType.NULL_STRING_LENGTH);
continue;
}
 else if (obj == VoltType.NULL_DECIMAL) {
buf.put(VoltType.DECIMAL.getValue());
VoltDecimalHelper.serializeNull(buf);
continue;
}
VoltType type=VoltType.typeFromClass(cls);
buf.put(type.getValue());
switch (type) {
case TINYINT:
buf.put((Byte)obj);
break;
case SMALLINT:
buf.putShort((Short)obj);
break;
case INTEGER:
buf.putInt((Integer)obj);
break;
case BIGINT:
buf.putLong((Long)obj);
break;
case FLOAT:
if (cls == Float.class) buf.putDouble(((Float)obj).doubleValue());
 else if (cls == Double.class) buf.putDouble(((Double)obj).doubleValue());
 else throw new RuntimeException("Can't cast parameter type to Double");
break;
case STRING:
if (m_encodedStrings[i] == null) {
throw new IOException("String not encoded: " + (String)obj);
}
FastSerializer.writeString(m_encodedStrings[i],buf);
break;
case TIMESTAMP:
long micros=timestampToMicroseconds(obj);
buf.putLong(micros);
break;
case DECIMAL:
VoltDecimalHelper.serializeBigDecimal((BigDecimal)obj,buf);
break;
case VOLTTABLE:
((VoltTable)obj).flattenToBuffer(buf);
break;
default :
throw new RuntimeException("FIXME: Unsupported type " + type);
}
}
}
