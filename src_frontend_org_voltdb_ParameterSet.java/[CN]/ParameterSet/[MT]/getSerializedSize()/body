{
  boolean shouldEncodeStrings=m_encodedStringArrays.isEmpty() && m_encodedStrings.isEmpty();
  int stringArrayIndex=0;
  int stringIndex=0;
  int size=2;
  for (int ii=0; ii < m_params.length; ii++) {
    Object obj=m_params[ii];
    if ((obj == null) || (obj == JSONObject.NULL)) {
      size++;
      continue;
    }
    size+=1;
    Class<?> cls=obj.getClass();
    if (cls.isArray()) {
      if (obj instanceof byte[]) {
        final byte[] b=(byte[])obj;
        size+=4 + b.length;
        continue;
      }
      VoltType type;
      try {
        type=VoltType.typeFromClass(cls.getComponentType());
      }
 catch (      VoltTypeException e) {
        obj=getAKosherArray((Object[])obj);
        cls=obj.getClass();
        type=VoltType.typeFromClass(cls.getComponentType());
      }
      size+=1 + 2;
switch (type) {
case SMALLINT:
        size+=2 * ((short[])obj).length;
      break;
case INTEGER:
    size+=4 * ((int[])obj).length;
  break;
case BIGINT:
size+=8 * ((long[])obj).length;
break;
case FLOAT:
size+=8 * ((double[])obj).length;
break;
case STRING:
if (shouldEncodeStrings) {
String strings[]=(String[])obj;
byte encodedStrings[][]=new byte[strings.length][];
for (int zz=0; zz < strings.length; zz++) {
if (strings[zz] == null) {
size+=4;
}
 else {
try {
encodedStrings[zz]=strings[zz].getBytes("UTF-8");
}
 catch (UnsupportedEncodingException e) {
VoltDB.crashLocalVoltDB("Shouldn't happen",false,e);
}
size+=4 + encodedStrings[zz].length;
}
}
m_encodedStringArrays.add(encodedStrings);
}
 else {
byte[][] strArray=m_encodedStringArrays.get(stringArrayIndex++);
for (int strIdx=0; strIdx < strArray.length; strIdx++) {
if (strArray[strIdx] == null) {
size+=4;
}
 else {
size+=4 + strArray[strIdx].length;
}
}
}
break;
case TIMESTAMP:
size+=8 * ((TimestampType[])obj).length;
break;
case DECIMAL:
size+=16 * ((BigDecimal[])obj).length;
break;
case VOLTTABLE:
for (VoltTable vt : (VoltTable[])obj) {
size+=vt.getSerializedSize();
}
break;
default :
throw new RuntimeException("FIXME: Unsupported type " + type);
}
continue;
}
if (obj == VoltType.NULL_TIMESTAMP) {
size+=8;
continue;
}
 else if (obj == VoltType.NULL_STRING_OR_VARBINARY) {
size+=4;
continue;
}
 else if (obj == VoltType.NULL_DECIMAL) {
size+=16;
continue;
}
VoltType type=VoltType.typeFromClass(cls);
switch (type) {
case TINYINT:
size++;
break;
case SMALLINT:
size+=2;
break;
case INTEGER:
size+=4;
break;
case BIGINT:
size+=8;
break;
case FLOAT:
size+=8;
break;
case STRING:
if (shouldEncodeStrings) {
try {
byte encodedString[]=((String)obj).getBytes("UTF-8");
size+=4 + encodedString.length;
m_encodedStrings.add(encodedString);
}
 catch (UnsupportedEncodingException e) {
VoltDB.crashLocalVoltDB("Shouldn't happen",false,e);
}
}
 else {
byte[] string=m_encodedStrings.get(stringIndex++);
size+=4 + string.length;
}
break;
case TIMESTAMP:
size+=8;
break;
case DECIMAL:
size+=16;
break;
case VOLTTABLE:
size+=((VoltTable)obj).getSerializedSize();
break;
default :
throw new RuntimeException("FIXME: Unsupported type " + type);
}
}
return size;
}
