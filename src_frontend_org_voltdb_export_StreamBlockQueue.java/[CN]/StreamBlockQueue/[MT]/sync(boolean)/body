{
  if (m_memoryDeque.peek() != null && !m_memoryDeque.peek().isPersisted()) {
    ArrayDeque<BBContainer[]> buffersToPush=new ArrayDeque<BBContainer[]>();
    Iterator<StreamBlock> iter=m_memoryDeque.iterator();
    while (iter.hasNext()) {
      StreamBlock sb=iter.next();
      if (sb.isPersisted()) {
        exportLog.error("Found a persisted export buffer after a memory buffer." + " This shouldn't happen. Will make a best effort to return all the data " + " and not leak memory");
        break;
      }
      buffersToPush.offer(sb.asBufferChain());
      iter.remove();
    }
    m_memoryDeque.clear();
    if (!buffersToPush.isEmpty()) {
      m_persistentDeque.push(buffersToPush.toArray(new BBContainer[0][0]));
    }
  }
  if (!nofsync) {
    m_persistentDeque.sync();
  }
}
