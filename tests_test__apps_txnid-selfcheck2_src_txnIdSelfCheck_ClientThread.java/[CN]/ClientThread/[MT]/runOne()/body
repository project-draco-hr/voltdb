{
  byte shouldRollback=(byte)(m_random.nextInt(10) == 0 ? 1 : 0);
  try {
    String procName=null;
switch (m_type) {
case PARTITIONED_SP:
      procName="UpdatePartitionedSP";
    break;
case PARTITIONED_MP:
  procName="UpdatePartitionedMP";
break;
case REPLICATED:
procName="UpdateReplicatedMP";
break;
case HYBRID:
procName="UpdateBothMP";
break;
case ADHOC_MP:
procName="UpdateReplicatedMPInProcAdHoc";
break;
}
byte[] payload=m_processor.generateForStore().getStoreValue();
ClientResponse response=m_client.callProcedure(procName,m_cid,m_nextRid,payload,shouldRollback);
if (response.getStatus() != ClientResponse.SUCCESS) {
throw new UserProcCallException(response);
}
VoltTable[] results=response.getResults();
m_txnsRun.incrementAndGet();
if (results.length != 3) {
log.error(String.format("Client cid %d procedure %s returned %d results instead of 3",m_cid,procName,results.length));
log.error(((ClientResponseImpl)response).toJSONString());
Benchmark.printJStack();
System.exit(-1);
}
VoltTable data=results[2];
try {
UpdateBaseProc.validateCIDData(data,"ClientThread:" + m_cid);
}
 catch (VoltAbortException vae) {
log.error("validateCIDData failed on: " + procName + ", shouldRollback: "+ shouldRollback+ " data: "+ data);
throw vae;
}
}
  finally {
if (shouldRollback == 0) {
m_nextRid++;
}
}
}
