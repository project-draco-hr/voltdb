{
  if (!m_partitionExecutor.containsKey(partition)) {
    m_partitionExecutor.putIfAbsent(partition,CoreUtils.getSingleThreadExecutor("InternalHandlerExecutor - " + partition));
  }
  ExecutorService executor=m_partitionExecutor.get(partition);
  try {
    executor.submit(new Runnable(){
      @Override public void run(){
        context.setBackPressure(hasBackPressure());
        if (!m_internalConnectionIds.containsKey(context.getName())) {
          m_internalConnectionIds.putIfAbsent(context.getName(),VoltProtocolHandler.getNextConnectionId());
        }
        submitTransaction();
      }
      public boolean submitTransaction(){
        final long handle=nextHandle();
        task.setClientHandle(handle);
        final InternalCallback cb=new InternalCallback(context,catProc,task,procName,partition,proccb,statsCollector,handle);
        m_callbacks.put(handle,cb);
        boolean bval=getClientInterface().createTransaction(connectionId(),task,catProc.getReadonly(),catProc.getSinglepartition(),catProc.getEverysite(),partition,task.getSerializedSize(),nowNanos);
        if (!bval) {
          m_logger.error("Failed to submit transaction.");
          m_callbacks.remove(handle);
        }
        return bval;
      }
    }
);
  }
 catch (  RejectedExecutionException ex) {
    m_logger.error("Failed to submit transaction to the partition queue.",ex);
    return false;
  }
  return true;
}
