{
  if (log.isTraceEnabled()) {
    log.trace("Received DR buffer size " + buf.remaining());
    AtomicLong haveOpenTransaction=haveOpenTransactionLocal.get();
    buf.order(ByteOrder.LITTLE_ENDIAN);
    buf.position(8);
    while (buf.hasRemaining()) {
      int startPosition=buf.position();
      byte version=buf.get();
      int type=buf.get();
      int checksum=0;
      if (version != 0)       log.trace("Remaining is " + buf.remaining());
switch (DRRecordType.valueOf(type)) {
case INSERT:
{
          if (haveOpenTransaction.get() == -1) {
            log.error("Have insert but no open transaction");
            break;
          }
          final long tableHandle=buf.getLong();
          final int lengthPrefix=buf.getInt();
          buf.position(buf.position() + lengthPrefix);
          checksum=buf.getInt();
          log.trace("Version " + version + " type INSERT table handle "+ tableHandle+ " length "+ lengthPrefix+ " checksum "+ checksum);
          break;
        }
case DELETE:
{
        if (haveOpenTransaction.get() == -1) {
          log.error("Have insert but no open transaction");
          break;
        }
        final long tableHandle=buf.getLong();
        final int lengthPrefix=buf.getInt();
        buf.position(buf.position() + lengthPrefix);
        checksum=buf.getInt();
        log.trace("Version " + version + " type DELETE table handle "+ tableHandle+ " length "+ lengthPrefix+ " checksum "+ checksum);
        break;
      }
case UPDATE:
    break;
case BEGIN_TXN:
{
    final long txnId=buf.getLong();
    final long spHandle=buf.getLong();
    if (haveOpenTransaction.get() != -1) {
      log.error("Have open transaction txnid " + txnId + " spHandle "+ spHandle+ " but already open transaction");
      break;
    }
    haveOpenTransaction.set(spHandle);
    checksum=buf.getInt();
    log.trace("Version " + version + " type BEGIN_TXN "+ " txnid "+ txnId+ " spHandle "+ spHandle+ " checksum "+ checksum);
    break;
  }
case END_TXN:
{
  final long spHandle=buf.getLong();
  if (haveOpenTransaction.get() == -1) {
    log.error("Have end transaction spHandle " + spHandle + " but no open transaction and its less then last committed "+ lastCommittedSpHandleTL.get().get());
    break;
  }
  haveOpenTransaction.set(-1);
  lastCommittedSpHandleTL.get().set(spHandle);
  checksum=buf.getInt();
  log.trace("Version " + version + " type END_TXN "+ " spHandle "+ spHandle+ " checksum "+ checksum);
  break;
}
case TRUNCATE_TABLE:
{
final long tableHandle=buf.getLong();
final byte tableNameBytes[]=new byte[buf.getInt()];
buf.get(tableNameBytes);
final String tableName=new String(tableNameBytes,Charsets.UTF_8);
checksum=buf.getInt();
log.trace("Version " + version + " type TRUNCATE_TABLE table handle "+ tableHandle+ " table name "+ tableName);
break;
}
}
int calculatedChecksum=DBBPool.getBufferCRC32C(buf,startPosition,buf.position() - startPosition - 4);
if (calculatedChecksum != checksum) {
log.error("Checksum " + calculatedChecksum + " didn't match "+ checksum);
break;
}
}
}
final PartitionDRGateway pdrg=gateways.get(partitionId);
if (pdrg == null) {
VoltDB.crashLocalVoltDB("No PRDG when there should be",true,null);
}
pdrg.onBinaryDR(partitionId,startSequenceNumber,lastSequenceNumber,lastUniqueId,buf);
}
