{
  assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());
  final StreamSnapshotRequestConfig config=new StreamSnapshotRequestConfig(jsData,context.getDatabase());
  final List<StreamSnapshotRequestConfig.Stream> localStreams=filterRemoteStreams(config.streams,Longs.asList(tracker.getLocalSites()));
  final Set<Integer> partitionsToAdd=getPartitionsToAdd(localStreams);
  if (config.shouldTruncate) {
    final int newPartitionCount=context.getNumberOfPartitions() + partitionsToAdd.size();
    coalesceTruncationSnapshotPlan(file_path,file_nonce,txnId,partitionTransactionIds,jsData,context,hostname,result,exportSequenceNumbers,tracker,timestamp,newPartitionCount);
  }
  List<Integer> localPartitions=tracker.getPartitionsForHost(context.getHostId());
  if (!partitionsToAdd.isEmpty()) {
    createUpdatePartitionCountTasksForSites(localPartitions,partitionsToAdd);
  }
  final AtomicInteger numTables=new AtomicInteger(config.tables.length);
  final SnapshotRegistry.Snapshot snapshotRecord=SnapshotRegistry.startSnapshot(txnId,context.getHostId(),file_path,file_nonce,SnapshotFormat.STREAM,config.tables);
  Map<Integer,byte[]> schemas=new HashMap<Integer,byte[]>();
  for (  final Table table : config.tables) {
    VoltTable schemaTable=CatalogUtil.getVoltTable(table);
    schemas.put(table.getRelativeIndex(),schemaTable.getSchemaBytes());
  }
  List<DataTargetInfo> sdts=createDataTargets(localStreams,schemas);
  for (  final Table table : config.tables) {
    createTasksForTable(table,sdts,numTables,snapshotRecord);
    result.addRow(context.getHostId(),hostname,table.getTypeName(),"SUCCESS","");
  }
  return false;
}
