{
  assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());
  final List<Long> localHSIds=Longs.asList(tracker.getLocalSites());
  final StreamSnapshotRequestConfig config=new StreamSnapshotRequestConfig(jsData,context.getDatabase(),localHSIds);
  final Map<Long,Integer> tokensToAdd=createTokensToAdd(config);
  if (config.shouldTruncate) {
    final int newPartitionCount=calculateNewPartitionCount(context.getNumberOfPartitions(),tokensToAdd);
    coalesceTruncationSnapshotPlan(file_path,file_nonce,txnId,partitionTransactionIds,jsData,context,hostname,result,exportSequenceNumbers,tracker,timestamp,newPartitionCount);
  }
  List<Integer> localPartitions=tracker.getPartitionsForHost(context.getHostId());
  if (!tokensToAdd.isEmpty()) {
    createUpdateHashinatorTasksForSites(localPartitions,tokensToAdd,txnId);
  }
  final AtomicInteger numTables=new AtomicInteger(config.tables.length);
  final SnapshotRegistry.Snapshot snapshotRecord=SnapshotRegistry.startSnapshot(txnId,context.getHostId(),file_path,file_nonce,SnapshotFormat.STREAM,config.tables);
  Map<Integer,byte[]> schemas=new HashMap<Integer,byte[]>();
  for (  final Table table : config.tables) {
    VoltTable schemaTable=CatalogUtil.getVoltTable(table);
    schemas.put(table.getRelativeIndex(),schemaTable.getSchemaBytes());
  }
  List<DataTargetInfo> sdts=Lists.newArrayList();
  for (  StreamSnapshotRequestConfig.Stream stream : config.streams) {
    SNAP_LOG.debug("Sites to stream from: " + CoreUtils.hsIdCollectionToString(stream.streamPairs.keySet()));
    for (    Entry<Long,Long> entry : stream.streamPairs.entries()) {
      long srcHSId=entry.getKey();
      long destHSId=entry.getValue();
      sdts.add(new DataTargetInfo(stream,srcHSId,new StreamSnapshotDataTarget(destHSId,schemas)));
    }
  }
  for (  final Table table : config.tables) {
    createTasksForTable(table,sdts,config,numTables,snapshotRecord);
    result.addRow(context.getHostId(),hostname,table.getTypeName(),"SUCCESS","");
  }
  return false;
}
