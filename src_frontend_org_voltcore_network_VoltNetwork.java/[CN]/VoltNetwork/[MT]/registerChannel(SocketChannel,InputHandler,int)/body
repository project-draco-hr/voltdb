{
  channel.configureBlocking(false);
  channel.socket().setKeepAlive(true);
  Callable<Connection> registerTask=new Callable<Connection>(){
    @Override public Connection call() throws Exception {
      final VoltPort port=new VoltPort(VoltNetwork.this,handler,channel.socket().getInetAddress().getHostAddress(),m_pool);
      port.registering();
      if (m_es != null) {
synchronized (m_es) {
          m_es.schedule(new Runnable(){
            @Override public void run(){
              port.resolveHostname();
            }
          }
,5,TimeUnit.SECONDS);
        }
      }
 else {
        port.resolveHostname();
      }
      try {
        SelectionKey key=channel.register(m_selector,interestOps,null);
        port.setKey(key);
        port.registered();
        key.attach(port);
        return port;
      }
  finally {
        m_ports.add(port);
      }
    }
  }
;
  FutureTask<Connection> ft=new FutureTask<Connection>(registerTask);
  m_tasks.offer(ft);
  m_selector.wakeup();
  try {
    return ft.get();
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}
