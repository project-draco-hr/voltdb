{
  m_thread=new Thread(this,"Volt Network");
  m_thread.setDaemon(true);
  m_useBlockingSelect=blockingSelect;
  m_es=es;
  try {
    m_selector=Selector.open();
  }
 catch (  IOException ex) {
    m_logger.fatal(null,ex);
    throw new RuntimeException(ex);
  }
  final int availableProcessors=Runtime.getRuntime().availableProcessors();
  if (availableProcessors <= 4) {
    m_useExecutorService=false;
  }
 else {
    m_useExecutorService=useExecutorService;
  }
  if (!m_useExecutorService) {
    threadPoolSize=1;
    m_taskQueues=null;
    return;
  }
  if (threads != null)   threadPoolSize=threads.intValue();
 else   if (availableProcessors <= 4)   threadPoolSize=1;
 else   if (availableProcessors <= 8)   threadPoolSize=2;
 else   if (availableProcessors > 8)   threadPoolSize=2;
 else   threadPoolSize=1;
  final ThreadFactory tf=new ThreadFactory(){
    private final ThreadGroup group=new ThreadGroup(Thread.currentThread().getThreadGroup(),"Network threads");
    private int threadIndex=0;
    @Override public Thread newThread(    final Runnable run){
      final Thread t=new Thread(group,run,"Network Thread - " + threadIndex++){
        @Override public void run(){
          try {
            run.run();
          }
  finally {
synchronized (m_poolsToClearOnShutdown) {
              m_poolsToClearOnShutdown.add(VoltPort.m_pools.get());
            }
          }
        }
      }
;
synchronized (m_networkThreads) {
        m_networkThreads.add(new WeakReference<Thread>(t));
      }
      t.setDaemon(true);
      return t;
    }
  }
;
  m_taskQueues=new LinkedBlockingQueue[threadPoolSize];
  for (int ii=0; ii < threadPoolSize; ii++) {
    @SuppressWarnings("rawtypes") final LinkedBlockingQueue taskQueue=new LinkedBlockingQueue();
    m_taskQueues[ii]=taskQueue;
    tf.newThread(new Runnable(){
      @Override public void run(){
        while (true) {
          try {
            Runnable nextTask=(Runnable)taskQueue.take();
            nextTask.run();
          }
 catch (          InterruptedException e) {
            return;
          }
catch (          TerminateThreadException e) {
            return;
          }
catch (          Exception e) {
            e.printStackTrace();
            networkLog.error(e);
          }
catch (          AssertionError e) {
            e.printStackTrace();
            throw e;
          }
        }
      }
    }
).start();
  }
}
