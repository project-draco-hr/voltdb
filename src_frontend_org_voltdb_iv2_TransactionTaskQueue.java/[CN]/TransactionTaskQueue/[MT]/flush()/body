{
  int offered=0;
  if (!m_multipartBacklog.isEmpty()) {
    Deque<TransactionTask> backlog=m_multipartBacklog.firstEntry().getValue();
    if (backlog.peek().getTransactionState().isDone()) {
      backlog.removeFirst();
      m_multipartBacklog.remove(m_multipartBacklog.firstKey());
      for (      TransactionTask task : backlog) {
        taskQueueOffer(task);
        ++offered;
      }
      if (!m_multipartBacklog.isEmpty() && !m_multipartBacklog.firstEntry().getValue().isEmpty() && !m_multipartBacklog.firstEntry().getValue().getFirst().getTransactionState().isSinglePartition()) {
        Deque<TransactionTask> nextBacklog=m_multipartBacklog.firstEntry().getValue();
        long txnId=m_multipartBacklog.firstKey();
        Iterator<TransactionTask> iter=nextBacklog.iterator();
        TransactionTask task=null;
        boolean firstTask=true;
        while (iter.hasNext()) {
          task=iter.next();
          if (task.getTxnId() == txnId) {
            if (firstTask) {
              firstTask=false;
            }
 else {
              iter.remove();
            }
            taskQueueOffer(task);
            ++offered;
          }
        }
      }
      if (m_drMPSentinelBacklog > 0) {
        m_multipartBacklog.put(GENERIC_MP_SENTINEL,new ArrayDeque<TransactionTask>());
        m_drMPSentinelBacklog--;
      }
    }
  }
  return offered;
}
