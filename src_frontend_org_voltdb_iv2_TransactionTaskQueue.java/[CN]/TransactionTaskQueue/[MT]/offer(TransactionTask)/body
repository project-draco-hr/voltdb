{
  Iv2Trace.logTransactionTaskQueueOffer(task);
  boolean retval=false;
  final TransactionState ts=task.getTransactionState();
  boolean isDRReplicated=false;
  if (VoltDB.instance().getReplicationRole() == ReplicationRole.REPLICA && !ts.isReadOnly() && !(ts instanceof BorrowTransactionState)) {
    isDRReplicated=true;
  }
  if ((ts.isForReplay() || isDRReplicated) && (task instanceof FragmentTask)) {
    boolean hasSentinel=false;
    if (!m_multipartBacklog.isEmpty()) {
      long txnId=m_multipartBacklog.firstKey();
      if (ts.txnId == txnId) {
        hasSentinel=true;
      }
 else       if (txnId == GENERIC_MP_SENTINEL && isDRReplicated) {
        hasSentinel=true;
      }
    }
    if (hasSentinel) {
      Deque<TransactionTask> backlog=m_multipartBacklog.firstEntry().getValue();
      TransactionTask first=backlog.peekFirst();
      if (first != null) {
        if (first.m_txn.txnId != task.getTxnId()) {
          if (!first.m_txn.isSinglePartition()) {
            hostLog.fatal("Head of backlog is " + first.m_txn.txnId + " but task is "+ task.getClass().getCanonicalName()+ " "+ task.getTxnId());
            VoltDB.crashLocalVoltDB("If the first backlog task is multi-part, " + "but has a different transaction id it is a bug",true,null);
          }
          backlog.addFirst(task);
        }
      }
 else {
        backlog.offer(task);
      }
      taskQueueOffer(task);
    }
 else {
      if (m_multiPartPendingSentinelReceipt != null) {
        hostLog.fatal("\tBacklog length: " + m_multipartBacklog.size());
        if (!m_multipartBacklog.isEmpty()) {
          hostLog.fatal("\tBacklog first item: " + m_multipartBacklog.firstEntry().getValue().peekFirst());
        }
        hostLog.fatal("\tHave this one SentinelReceipt: " + m_multiPartPendingSentinelReceipt);
        hostLog.fatal("\tAnd got this one, too: " + task);
        VoltDB.crashLocalVoltDB("There should be only one multipart pending sentinel receipt at a time",true,null);
      }
      m_multiPartPendingSentinelReceipt=task;
      retval=true;
    }
  }
 else   if (!m_multipartBacklog.isEmpty()) {
    boolean isDRMPTask=false;
    if (((ts instanceof BorrowTransactionState) || !ts.isSinglePartition()) && !ts.isReadOnly() && m_multipartBacklog.firstKey() == GENERIC_MP_SENTINEL) {
      isDRMPTask=true;
    }
    if (!isDRMPTask && task.getTxnId() != m_multipartBacklog.firstKey()) {
      if (!ts.isSinglePartition()) {
        Deque<TransactionTask> d=m_multipartBacklog.get(task.getTxnId());
        if (d == null) {
          d=new ArrayDeque<TransactionTask>();
          m_multipartBacklog.put(task.getTxnId(),d);
        }
        d.offerLast(task);
      }
 else {
        m_multipartBacklog.lastEntry().getValue().addLast(task);
        retval=true;
      }
    }
 else {
      taskQueueOffer(task);
    }
  }
 else {
    if (!task.getTransactionState().isSinglePartition()) {
      Deque<TransactionTask> d=new ArrayDeque<TransactionTask>();
      d.offer(task);
      m_multipartBacklog.put(task.getTxnId(),d);
      retval=true;
    }
    taskQueueOffer(task);
  }
  return retval;
}
