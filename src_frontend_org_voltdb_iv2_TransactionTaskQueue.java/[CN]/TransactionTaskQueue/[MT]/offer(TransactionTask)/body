{
  Iv2Trace.logTransactionTaskQueueOffer(task);
  boolean retval=false;
  final TransactionState ts=task.getTransactionState();
  if (ts.isForReplay() && !ts.isSinglePartition()) {
    if (!m_multipartBacklog.isEmpty() && ts.txnId == m_multipartBacklog.firstKey()) {
      taskQueueOffer(task);
    }
 else     if (m_multipartBacklog.containsKey(ts.txnId)) {
      m_multipartBacklog.get(ts.txnId).addFirst(task);
      taskQueueOffer(task);
    }
 else {
      if (m_multiPartPendingSentinelReceipt != null) {
        VoltDB.crashLocalVoltDB("There should be only one multipart pending sentinel receipt at a time",true,null);
      }
      m_multiPartPendingSentinelReceipt=task;
      retval=true;
    }
  }
 else   if (!m_multipartBacklog.isEmpty()) {
    if (task.getTxnId() != m_multipartBacklog.firstKey()) {
      if (!ts.isSinglePartition()) {
        Deque<TransactionTask> d=m_multipartBacklog.get(task.getTxnId());
        if (d == null) {
          d=new ArrayDeque<TransactionTask>();
          m_multipartBacklog.put(task.getTxnId(),d);
        }
        d.offerLast(task);
      }
 else {
        m_multipartBacklog.lastEntry().getValue().addLast(task);
        retval=true;
      }
    }
 else {
      taskQueueOffer(task);
    }
  }
 else {
    if (!task.getTransactionState().isSinglePartition()) {
      Deque<TransactionTask> d=new ArrayDeque<TransactionTask>();
      d.offer(task);
      m_multipartBacklog.put(task.getTxnId(),d);
      retval=true;
    }
    taskQueueOffer(task);
  }
  return retval;
}
