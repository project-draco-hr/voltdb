{
  AdHocPlannerWork work=null;
  try {
    work=m_work.take();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  while (work.shouldShutdown == false) {
    if (work.shouldDump == true) {
      DumpManager.putDump(m_dumpId,m_currentDumpTimestamp,true,getDumpContents());
    }
 else {
      TrivialCostModel costModel=new TrivialCostModel();
      Cluster cluster=m_catalog.getClusters().get("cluster");
      Database database=cluster.getDatabases().get("database");
      QueryPlanner planner=new QueryPlanner(cluster,database,m_hsql,new DatabaseEstimates(),false,VoltDB.getQuietAdhoc());
      CompiledPlan plan=null;
      AdHocPlannedStmt plannedStmt=new AdHocPlannedStmt();
      plannedStmt.clientHandle=work.clientHandle;
      plannedStmt.connectionId=work.connectionId;
      plannedStmt.clientData=work.clientData;
      String error_msg=null;
      try {
        plan=planner.compilePlan(costModel,work.sql,"adhocsql-" + String.valueOf(counter++),"adhocproc",false,null);
        error_msg=planner.m_recentErrorMsg;
      }
 catch (      Exception e) {
        plan=null;
        error_msg=e.getMessage();
      }
      if (plan != null) {
        plan.sql=work.sql;
      }
 else {
        plannedStmt.errorMsg="Failed to ad-hoc-plan for stmt: " + work.sql;
        plannedStmt.errorMsg+=" with error: " + error_msg;
      }
      if (plan != null) {
        assert(plan.fragments.size() <= 2);
        for (int i=0; i < plan.fragments.size(); i++) {
          Fragment frag=plan.fragments.get(i);
          PlanNodeList planList=new PlanNodeList(frag.planGraph);
          String serializedPlan=planList.toJSONString();
          if (frag.multiPartition) {
            plannedStmt.collectorFragment=serializedPlan;
          }
 else {
            plannedStmt.aggregatorFragment=serializedPlan;
          }
        }
        plannedStmt.isReplicatedTableDML=plan.replicatedTableDML;
        plannedStmt.sql=plan.sql;
      }
synchronized (m_finished) {
        m_finished.add(plannedStmt);
      }
    }
    try {
      work=m_work.take();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  if (m_hsql != null)   m_hsql.close();
}
