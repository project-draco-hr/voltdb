{
  StoredProcedureInvocation task=new StoredProcedureInvocation();
  task.type=plannedStmtBatch.type;
  task.originalTxnId=plannedStmtBatch.originalTxnId;
  task.originalUniqueId=plannedStmtBatch.originalUniqueId;
  boolean isSinglePartition=plannedStmtBatch.isSinglePartitionCompatible() || m_isConfiguredForHSQL;
  int partition=-1;
  if (isSinglePartition) {
    if (plannedStmtBatch.isReadOnly()) {
      task.procName="@AdHoc_RO_SP";
    }
 else {
      task.procName="@AdHoc_RW_SP";
    }
    int type=VoltType.NULL.getValue();
    if (plannedStmtBatch.partitionParam != null) {
      type=VoltType.typeFromObject(plannedStmtBatch.partitionParam).getValue();
    }
    partition=TheHashinator.getPartitionForParameter(type,plannedStmtBatch.partitionParam);
  }
 else {
    if (plannedStmtBatch.isReadOnly()) {
      task.procName="@AdHoc_RO_MP";
    }
 else {
      task.procName="@AdHoc_RW_MP";
    }
  }
  ByteBuffer buf=ByteBuffer.allocate(plannedStmtBatch.getPlanArraySerializedSize());
  try {
    plannedStmtBatch.flattenPlanArrayToBuffer(buf);
  }
 catch (  Exception e) {
    VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
  }
  assert(buf.hasArray());
  if (isSinglePartition) {
    byte[] param=null;
    byte type=VoltType.NULL.getValue();
    if (plannedStmtBatch.partitionParam != null) {
      type=VoltType.typeFromClass(plannedStmtBatch.partitionParam.getClass()).getValue();
      param=TheHashinator.valueToBytes(plannedStmtBatch.partitionParam);
    }
    task.setParams(param,type,buf.array());
  }
 else {
    task.setParams(buf.array());
  }
  task.clientHandle=plannedStmtBatch.clientHandle;
  try {
    task=MiscUtils.roundTripForCL(task);
  }
 catch (  Exception e) {
    VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
  }
  createTransaction(plannedStmtBatch.connectionId,task,plannedStmtBatch.isReadOnly(),isSinglePartition,false,partition,task.getSerializedSize(),EstTime.currentTimeMillis());
}
