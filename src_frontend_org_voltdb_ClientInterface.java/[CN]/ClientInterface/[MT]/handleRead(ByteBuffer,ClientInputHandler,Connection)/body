{
  final FastDeserializer fds=new FastDeserializer(buf);
  final StoredProcedureInvocation task=fds.readObject(StoredProcedureInvocation.class);
  final Procedure catProc=m_catalogContext.procedures.get(task.procName);
  if (task.procName.startsWith("@")) {
    if (task.procName.equals("@AdHoc")) {
      if (!handler.m_user.hasAdhocPermission()) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User does not have @AdHoc permission",task.clientHandle);
        authLog.l7dlog(Level.INFO,LogKeys.auth_ClientInterface_LackingPermissionForAdhoc.name(),new String[]{handler.m_user.m_name},null);
        c.writeStream().enqueue(errorResponse);
        return;
      }
      task.buildParameterSet();
      if (task.params.m_params.length != 1) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"Adhoc system procedure requires exactly one parameter, the SQL statement to execute.",task.clientHandle);
        c.writeStream().enqueue(errorResponse);
        return;
      }
      String sql=(String)task.params.m_params[0];
      m_plannerThread.planSQL(sql,task.clientHandle,handler.connectionId(),handler.sequenceId(),c);
      return;
    }
    if (task.procName.equals("@UpdateApplicationCatalog")) {
      if (!handler.m_user.hasAdhocPermission()) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User does not have @AdHoc permission",task.clientHandle);
        authLog.l7dlog(Level.INFO,LogKeys.auth_ClientInterface_LackingPermissionForAdhoc.name(),new String[]{handler.m_user.m_name},null);
        c.writeStream().enqueue(errorResponse);
        return;
      }
      task.buildParameterSet();
      if (task.params.m_params.length != 1) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"Adhoc system procedure requires exactly one parameter, the SQL statement to execute.",task.clientHandle);
        c.writeStream().enqueue(errorResponse);
        return;
      }
      String catalogURL=(String)task.params.m_params[0];
      m_plannerThread.prepareCatalogUpdate(catalogURL,task.clientHandle,handler.connectionId(),handler.sequenceId(),c);
      return;
    }
    if (task.procName.equals("@dump")) {
      DumpManager.requestGlobalDump(System.currentTimeMillis());
      final ClientResponseImpl dumpResponse=new ClientResponseImpl(ClientResponseImpl.SUCCESS,new VoltTable[0],"Dump in progress...",task.clientHandle);
      c.writeStream().enqueue(dumpResponse);
      return;
    }
    if (!handler.m_user.hasSystemProcPermission()) {
      authLog.l7dlog(Level.INFO,LogKeys.auth_ClientInterface_LackingPermissionForSysproc.name(),new String[]{handler.m_user.m_name,task.procName},null);
      final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User " + handler.m_user.m_name + " does not have sysproc permission",task.clientHandle);
      c.writeStream().enqueue(errorResponse);
      return;
    }
  }
 else   if (!handler.m_user.hasPermission(catProc)) {
    authLog.l7dlog(Level.INFO,LogKeys.auth_ClientInterface_LackingPermissionForProcedure.name(),new String[]{handler.m_user.m_name,task.procName},null);
    final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User does not have permission to invoke " + catProc.getTypeName(),task.clientHandle);
    c.writeStream().enqueue(errorResponse);
    return;
  }
  if (catProc != null) {
    boolean isReadOnly=catProc.getReadonly();
    int[] involvedPartitions=null;
    if (catProc.getSinglepartition() == false) {
      involvedPartitions=m_allPartitions;
      task.buildParameterSet();
    }
 else {
      try {
        involvedPartitions=new int[]{getPartitionForProcedure(catProc.getPartitionparameter(),task)};
      }
 catch (      RuntimeException e) {
        String errorMessage="Error sending procedure " + task.procName + " to the correct partition. Make sure parameter values are correct.";
        authLog.l7dlog(Level.WARN,LogKeys.host_ClientInterface_unableToRouteSinglePartitionInvocation.name(),new Object[]{task.procName},null);
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],errorMessage,task.clientHandle);
        c.writeStream().enqueue(errorResponse);
      }
    }
    if (involvedPartitions != null) {
      m_initiator.createTransaction(handler.connectionId(),task,isReadOnly,catProc.getSinglepartition(),involvedPartitions,involvedPartitions.length,c);
    }
  }
 else {
    String errorMessage="Procedure " + task.procName + " was not found";
    authLog.l7dlog(Level.WARN,LogKeys.auth_ClientInterface_ProcedureNotFound.name(),new Object[]{task.procName},null);
    final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],errorMessage,task.clientHandle);
    c.writeStream().enqueue(errorResponse);
  }
}
