{
  final long now=System.currentTimeMillis();
  final FastDeserializer fds=new FastDeserializer(buf);
  final StoredProcedureInvocation task=fds.readObject(StoredProcedureInvocation.class);
  VoltDBInterface instance=VoltDB.instance();
  if (instance.getMode() == OperationMode.PAUSED && !handler.isAdmin()) {
    final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.SERVER_UNAVAILABLE,new VoltTable[0],"Server is currently unavailable; try again later",task.clientHandle);
    c.writeStream().enqueue(errorResponse);
    return;
  }
  final CatalogContext catalogContext=m_catalogContext.get();
  AuthSystem.AuthUser user=catalogContext.authSystem.getUser(handler.m_username);
  final Procedure catProc=catalogContext.procedures.get(task.procName);
  Config sysProc=SystemProcedureCatalog.listing.get(task.procName);
  if (user == null) {
    final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User " + handler.m_username + " has been removed from the system via a catalog update",task.clientHandle);
    authLog.info("User " + handler.m_username + " has been removed from the system via a catalog update");
    c.writeStream().enqueue(errorResponse);
    return;
  }
  if (catProc == null && sysProc == null) {
    String errorMessage="Procedure " + task.procName + " was not found";
    authLog.l7dlog(Level.WARN,LogKeys.auth_ClientInterface_ProcedureNotFound.name(),new Object[]{task.procName},null);
    final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],errorMessage,task.clientHandle);
    c.writeStream().enqueue(errorResponse);
    return;
  }
  if (!checkPolicies(null,user,task,catProc,sysProc,c.writeStream()) || !checkPolicies(task.procName,user,task,catProc,sysProc,c.writeStream())) {
    return;
  }
  if (sysProc != null) {
    if (task.procName.startsWith("@AdHoc")) {
      ParameterSet params=task.getParams();
      String sql=(String)params.m_params[0];
      Object partitionParam=null;
      if (params.m_params.length > 1) {
        if (params.m_params[1] == null) {
          partitionParam=new Long(0);
        }
 else {
          partitionParam=params.m_params[1];
        }
      }
      boolean success=m_asyncCompilerWorkThread.planSQL(sql,partitionParam,task.clientHandle,handler.connectionId(),handler.m_hostname,handler.isAdmin(),c);
      if (!success) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.GRACEFUL_FAILURE,new VoltTable[0],"Adhoc SQL planner busy. Try again later. " + "If you see this message repeatedly, you may try restarting the VoltDB node.",task.clientHandle);
        c.writeStream().enqueue(errorResponse);
      }
      return;
    }
    if (task.procName.equals("@LoadSinglepartitionTable")) {
      int[] involvedPartitions=null;
      try {
        CatalogMap<Table> tables=m_catalogContext.get().database.getTables();
        Object valueToHash=LoadSinglepartitionTable.partitionValueFromInvocation(tables,task);
        involvedPartitions=new int[]{TheHashinator.hashToPartition(valueToHash)};
      }
 catch (      Exception e) {
        authLog.warn(e.getMessage());
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],e.getMessage(),task.clientHandle);
        c.writeStream().enqueue(errorResponse);
        return;
      }
      assert(involvedPartitions != null);
      m_initiator.createTransaction(handler.connectionId(),handler.m_hostname,handler.isAdmin(),task,false,true,false,involvedPartitions,involvedPartitions.length,c,buf.capacity(),now);
      return;
    }
    if (task.procName.equals("@UpdateApplicationCatalog")) {
      ParameterSet params=task.getParams();
      byte[] catalogBytes=null;
      if (params.m_params[0] instanceof String) {
        catalogBytes=Encoder.hexDecode((String)params.m_params[0]);
      }
 else       if (params.m_params[0] instanceof byte[]) {
        catalogBytes=(byte[])params.m_params[0];
      }
      String deploymentString=(String)params.m_params[1];
      m_asyncCompilerWorkThread.prepareCatalogUpdate(catalogBytes,deploymentString,task.clientHandle,handler.connectionId(),handler.m_hostname,handler.isAdmin(),handler.sequenceId(),c);
      return;
    }
 else     if (task.procName.equals("@Pause") || task.procName.equals("@Resume")) {
      if (!handler.isAdmin()) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"" + task.procName + " is not available to this client",task.clientHandle);
        c.writeStream().enqueue(errorResponse);
        return;
      }
    }
 else     if (task.procName.equals("@SystemInformation")) {
      ParameterSet params=task.getParams();
      if (params.m_params.length == 0) {
        params.m_params=new Object[1];
        params.m_params[0]=new String("OVERVIEW");
      }
      task.unserializedParams=null;
    }
 else     if (task.procName.equals("@SnapshotSave")) {
      m_snapshotDaemon.requestUserSnapshot(task,c);
      return;
    }
 else     if (task.procName.equals("@Statistics")) {
      ParameterSet params=task.getParams();
      if (((String)params.toArray()[0]).equals("WAN")) {
        try {
          VoltDB.instance().getStatsAgent().collectStats(c,task.clientHandle,"WAN");
        }
 catch (        Exception e) {
          sendErrorResponse(c,task.clientHandle,ClientResponse.UNEXPECTED_FAILURE,null,e,true);
        }
        return;
      }
    }
  }
  if (catProc != null) {
    int[] involvedPartitions=null;
    if (catProc.getSinglepartition() == false) {
      involvedPartitions=m_allPartitions;
    }
 else {
      try {
        involvedPartitions=new int[]{getPartitionForProcedure(catProc.getPartitionparameter(),task)};
      }
 catch (      RuntimeException e) {
        String errorMessage="Error sending procedure " + task.procName + " to the correct partition. Make sure parameter values are correct.";
        authLog.l7dlog(Level.WARN,LogKeys.host_ClientInterface_unableToRouteSinglePartitionInvocation.name(),new Object[]{task.procName},null);
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],errorMessage,task.clientHandle);
        c.writeStream().enqueue(errorResponse);
      }
    }
    if (involvedPartitions != null) {
      boolean success=m_initiator.createTransaction(handler.connectionId(),handler.m_hostname,handler.isAdmin(),task,catProc.getReadonly(),catProc.getSinglepartition(),catProc.getEverysite(),involvedPartitions,involvedPartitions.length,c,buf.capacity(),now);
      if (!success) {
        final ClientResponseImpl errorResponse=new ClientResponseImpl(ClientResponseImpl.SUCCESS,new VoltTable[0],"Duplicate replicated transaction; already succeeded",task.clientHandle);
        c.writeStream().enqueue(errorResponse);
        return;
      }
    }
  }
 else   if (sysProc != null) {
    int[] involvedPartitions=m_allPartitions;
    m_initiator.createTransaction(handler.connectionId(),handler.m_hostname,handler.isAdmin(),task,sysProc.getReadonly(),sysProc.getSinglepartition(),sysProc.getEverysite(),involvedPartitions,involvedPartitions.length,c,buf.capacity(),now);
  }
}
