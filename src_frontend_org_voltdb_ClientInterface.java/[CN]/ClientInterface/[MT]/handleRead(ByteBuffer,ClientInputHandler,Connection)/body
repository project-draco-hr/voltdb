{
  final long nowNanos=System.nanoTime();
  StoredProcedureInvocation task=new StoredProcedureInvocation();
  try {
    task.initFromBuffer(buf);
  }
 catch (  Exception ex) {
    return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],ex.getMessage(),ccxn.connectionId());
  }
  final CatalogContext catalogContext=m_catalogContext.get();
  final AuthSystem.AuthUser user=catalogContext.authSystem.getUser(handler.m_username);
  Procedure catProc=getProcedureFromName(task.procName,catalogContext);
  if (user == null) {
    authLog.info("User " + handler.m_username + " has been removed from the system via a catalog update");
    return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"User " + handler.m_username + " has been removed from the system via a catalog update",task.clientHandle);
  }
  if (catProc == null) {
    String errorMessage="Procedure " + task.procName + " was not found";
    RateLimitedLogger.tryLogForMessage(System.currentTimeMillis(),60,TimeUnit.SECONDS,authLog,Level.WARN,errorMessage + ". This message is rate limited to once every 60 seconds.");
    return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],errorMessage,task.clientHandle);
  }
  if (!allowPauseModeExecution(handler,catProc,task)) {
    return new ClientResponseImpl(ClientResponseImpl.SERVER_UNAVAILABLE,new VoltTable[0],"Server is paused and is available in read-only mode - please try again later.",task.clientHandle);
  }
  ClientResponseImpl error=null;
  if ((error=m_permissionValidator.shouldAccept(task.procName,user,task,catProc)) != null) {
    return error;
  }
  if ((error=m_invocationValidator.shouldAccept(task.procName,user,task,catProc)) != null) {
    return error;
  }
  int batchTimeout=task.getBatchTimeout();
  if (BatchTimeoutOverrideType.isUserSetTimeout(batchTimeout)) {
    if (!user.hasPermission(Permission.ADMIN)) {
      int systemTimeout=catalogContext.cluster.getDeployment().get("deployment").getSystemsettings().get("systemsettings").getQuerytimeout();
      if (systemTimeout != ExecutionEngine.NO_BATCH_TIMEOUT_VALUE && (batchTimeout > systemTimeout || batchTimeout == ExecutionEngine.NO_BATCH_TIMEOUT_VALUE)) {
        String errorMessage="The attempted individual query timeout value " + batchTimeout + " milliseconds override was ignored because the connection lacks ADMIN privileges.";
        RateLimitedLogger.tryLogForMessage(System.currentTimeMillis(),60,TimeUnit.SECONDS,log,Level.INFO,errorMessage + " This message is rate limited to once every 60 seconds.");
        task.setBatchTimeout(systemTimeout);
      }
    }
  }
  if (catProc.getSystemproc()) {
    if (task.procName.equals("@Ping")) {
      return new ClientResponseImpl(ClientResponseImpl.SUCCESS,new VoltTable[0],"",task.clientHandle);
    }
 else     if (task.procName.equals("@GetPartitionKeys")) {
      return dispatchGetPartitionKeys(task);
    }
 else     if (task.procName.equals("@Subscribe")) {
      return dispatchSubscribe(handler,task);
    }
 else     if (task.procName.equals("@Statistics")) {
      return dispatchStatistics(OpsSelector.STATISTICS,task,ccxn);
    }
 else     if (task.procName.equals("@SystemCatalog")) {
      return dispatchStatistics(OpsSelector.SYSTEMCATALOG,task,ccxn);
    }
 else     if (task.procName.equals("@SystemInformation")) {
      return dispatchStatistics(OpsSelector.SYSTEMINFORMATION,task,ccxn);
    }
 else     if (task.procName.equals("@GC")) {
      return dispatchSystemGC(handler,task);
    }
 else     if (task.procName.equals("@StopNode")) {
      return dispatchStopNode(task);
    }
 else     if (task.procName.equals("@Explain")) {
      return dispatchAdHoc(task,handler,ccxn,true,user);
    }
 else     if (task.procName.equals("@ExplainProc")) {
      return dispatchExplainProcedure(task,handler,ccxn,user);
    }
 else     if (task.procName.equals("@SendSentinel")) {
      dispatchSendSentinel(handler.connectionId(),nowNanos,buf.capacity(),task);
      return null;
    }
 else     if (task.procName.equals("@AdHoc")) {
      return dispatchAdHoc(task,handler,ccxn,false,user);
    }
 else     if (task.procName.equals("@AdHocSpForTest")) {
      return dispatchAdHocSpForTest(task,handler,ccxn,false,user);
    }
 else     if (task.procName.equals("@LoadMultipartitionTable")) {
      if (ProcedureInvocationType.isDeprecatedInternalDRType(task.getType())) {
        sendSentinelsToAllPartitions(task.getOriginalTxnId());
      }
    }
 else     if (task.procName.equals("@LoadSinglepartitionTable")) {
      return dispatchLoadSinglepartitionTable(buf,catProc,task,handler,ccxn);
    }
 else     if (task.procName.equals("@ResetDR")) {
      return dispatchResetDR(task);
    }
    if (!MiscUtils.isPro()) {
      SystemProcedureCatalog.Config sysProcConfig=SystemProcedureCatalog.listing.get(task.procName);
      if ((sysProcConfig != null) && (sysProcConfig.commercial)) {
        return new ClientResponseImpl(ClientResponseImpl.GRACEFUL_FAILURE,new VoltTable[0],task.procName + " is available in the Enterprise Edition of VoltDB only.",task.clientHandle);
      }
    }
    if (task.procName.equals("@UpdateApplicationCatalog")) {
      return dispatchUpdateApplicationCatalog(task,handler,ccxn,user);
    }
 else     if (task.procName.equals("@UpdateClasses")) {
      return dispatchUpdateApplicationCatalog(task,handler,ccxn,user);
    }
 else     if (task.procName.equals("@SnapshotSave")) {
      m_snapshotDaemon.requestUserSnapshot(task,ccxn);
      return null;
    }
 else     if (task.procName.equals("@Promote")) {
      return dispatchPromote(catProc,buf,task,handler,ccxn);
    }
 else     if (task.procName.equals("@SnapshotStatus")) {
      Object[] params=new Object[1];
      params[0]="SNAPSHOTSTATUS";
      task.setParams(params);
      return dispatchStatistics(OpsSelector.STATISTICS,task,ccxn);
    }
 else     if (task.procName.equals("@SnapshotScan")) {
      return dispatchStatistics(OpsSelector.SNAPSHOTSCAN,task,ccxn);
    }
 else     if (task.procName.equals("@SnapshotDelete")) {
      return dispatchStatistics(OpsSelector.SNAPSHOTDELETE,task,ccxn);
    }
 else     if (task.procName.equals("@SnapshotRestore")) {
      ClientResponseImpl retval=SnapshotUtil.transformRestoreParamsToJSON(task);
      if (retval != null) {
        return retval;
      }
      if (catalogContext.database.getTables().size() == 0) {
        if (!VoltDB.instance().getCatalogContext().cluster.getUseddlschema()) {
          return new ClientResponseImpl(ClientResponseImpl.GRACEFUL_FAILURE,new VoltTable[0],"Cannot restore catalog from snapshot when schema is set to catalog in the deployment.",task.clientHandle);
        }
        log.warn("@SnapshotRestore called on an empty database, attempting to restore catalog from snapshot.");
        try {
          JSONObject jsObj=new JSONObject(task.getParams().getParam(0).toString());
          final String path=jsObj.getString(SnapshotUtil.JSON_PATH);
          final String nonce=jsObj.getString(SnapshotUtil.JSON_NONCE);
          final byte[] catalog=MiscUtils.fileToBytes(new File(path,nonce + ".jar"));
          final String dep=new String(catalogContext.getDeploymentBytes(),java.nio.charset.StandardCharsets.UTF_8);
          SyncCallback cb=new SyncCallback();
          getInternalConnectionHandler().callProcedure(new ClientInterfaceConnectionContext(),0,cb,user,"@UpdateApplicationCatalog",catalog,dep);
          cb.waitForResponse();
          m_catalogContext.set(VoltDB.instance().getCatalogContext());
          catProc=getProcedureFromName(task.procName,m_catalogContext.get());
        }
 catch (        JSONException e) {
          return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"Unable to parse parameters.",task.clientHandle);
        }
catch (        InterruptedException e) {
          return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"Unexpected failure while restoring catalog from snapshot.",task.clientHandle);
        }
      }
    }
    if (task.procName.equals("@Pause") || task.procName.equals("@Resume")) {
      if (!handler.isAdmin()) {
        return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],"" + task.procName + " is not available to this client",task.clientHandle);
      }
    }
  }
  int partition=-1;
  try {
    partition=getPartitionForProcedure(catProc,task);
  }
 catch (  Exception e) {
    return getMispartitionedErrorResponse(task,catProc,e);
  }
  boolean success=createTransaction(handler.connectionId(),task,catProc.getReadonly(),catProc.getSinglepartition(),catProc.getEverysite(),partition,buf.capacity(),nowNanos);
  if (!success) {
    return new ClientResponseImpl(ClientResponseImpl.UNEXPECTED_FAILURE,new VoltTable[0],ClientResponseImpl.IGNORED_TRANSACTION,task.clientHandle);
  }
  return null;
}
