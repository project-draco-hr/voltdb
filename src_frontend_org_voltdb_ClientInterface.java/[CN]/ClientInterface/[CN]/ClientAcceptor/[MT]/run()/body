{
  try {
    do {
      final SocketChannel socket;
      try {
        socket=m_serverSocket.accept();
      }
 catch (      IOException ioe) {
        if (ioe.getMessage() != null && ioe.getMessage().contains("Too many open files")) {
          networkLog.warn("Rejected accepting new connection due to too many open files");
          continue;
        }
 else {
          throw ioe;
        }
      }
      if (m_numConnections.get() == MAX_CONNECTIONS.get()) {
        networkLog.warn("Rejected connection from " + socket.socket().getRemoteSocketAddress() + " because the connection limit of "+ MAX_CONNECTIONS+ " has been reached");
        try {
          final ByteBuffer b=ByteBuffer.allocate(1);
          b.put(MAX_CONNECTIONS_LIMIT_ERROR);
          b.flip();
          socket.configureBlocking(true);
          for (int ii=0; ii < 4 && b.hasRemaining(); ii++) {
            socket.write(b);
          }
          socket.close();
        }
 catch (        IOException e) {
        }
        continue;
      }
      m_numConnections.incrementAndGet();
      m_executor.execute(new Runnable(){
        @Override public void run(){
          if (socket != null) {
            boolean success=false;
            try {
              final InputHandler handler=authenticate(socket);
              if (handler != null) {
                socket.configureBlocking(false);
                if (handler instanceof ClientInputHandler) {
                  socket.socket().setTcpNoDelay(true);
                }
                socket.socket().setKeepAlive(true);
                if (handler instanceof ClientInputHandler) {
                  final Connection c=m_network.registerChannel(socket,handler,0);
                  if (!m_isIV2Enabled) {
                    m_backpressureLock.lock();
                    try {
                      if (!m_hasDTXNBackPressure) {
                        c.enableReadSelection();
                      }
                      m_connections.add(c);
                    }
  finally {
                      m_backpressureLock.unlock();
                    }
                  }
                }
 else {
                  m_network.registerChannel(socket,handler,SelectionKey.OP_READ);
                }
                success=true;
              }
            }
 catch (            IOException e) {
              try {
                socket.close();
              }
 catch (              IOException e1) {
              }
              if (m_running) {
                hostLog.warn("Exception authenticating and registering user in ClientAcceptor",e);
              }
            }
 finally {
              if (!success) {
                m_numConnections.decrementAndGet();
              }
            }
          }
        }
      }
);
    }
 while (m_running);
  }
 catch (  IOException e) {
    if (m_running) {
      hostLog.fatal("Exception in ClientAcceptor. The acceptor has died",e);
    }
  }
 finally {
    try {
      m_serverSocket.close();
    }
 catch (    IOException e) {
      hostLog.fatal(null,e);
    }
synchronized (this) {
      Thread.interrupted();
      m_executor.shutdownNow();
      try {
        m_executor.awaitTermination(1,TimeUnit.DAYS);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }
}
