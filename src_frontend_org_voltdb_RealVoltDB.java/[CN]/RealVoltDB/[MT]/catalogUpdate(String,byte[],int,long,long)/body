{
synchronized (m_catalogUpdateLock) {
    if (currentTxnId <= m_catalogContext.m_transactionId && !m_txnIdToContextTracker.isEmpty()) {
      ContextTracker contextTracker=m_txnIdToContextTracker.get(currentTxnId);
      contextTracker.m_dispensedSites++;
      int ttlsites=VoltDB.instance().getSiteTrackerForSnapshot().getSitesForHost(m_messenger.getHostId()).size();
      if (contextTracker.m_dispensedSites == ttlsites) {
        m_txnIdToContextTracker.remove(currentTxnId);
      }
      return Pair.of(contextTracker.m_context,contextTracker.m_csp);
    }
 else     if (m_catalogContext.catalogVersion != expectedCatalogVersion) {
      throw new RuntimeException("Trying to update main catalog context with diff " + "commands generated for an out-of date catalog. Expected catalog version: " + expectedCatalogVersion + " does not match actual version: "+ m_catalogContext.catalogVersion);
    }
    m_catalogContext=m_catalogContext.update(currentTxnId,newCatalogBytes,diffCommands,true,deploymentCRC);
    final CatalogSpecificPlanner csp=new CatalogSpecificPlanner(m_asyncCompilerAgent,m_catalogContext);
    m_txnIdToContextTracker.put(currentTxnId,new ContextTracker(m_catalogContext,csp));
    m_catalogContext.logDebuggingInfoFromCatalog();
    ExportManager.instance().updateCatalog(m_catalogContext);
    for (    ClientInterface ci : m_clientInterfaces) {
      ci.notifyOfCatalogUpdate();
    }
    if (m_adminListener != null) {
      m_adminListener.notifyOfCatalogUpdate();
    }
    if (m_MPI != null) {
      m_MPI.updateCatalog(diffCommands,m_catalogContext,csp);
    }
    return Pair.of(m_catalogContext,csp);
  }
}
