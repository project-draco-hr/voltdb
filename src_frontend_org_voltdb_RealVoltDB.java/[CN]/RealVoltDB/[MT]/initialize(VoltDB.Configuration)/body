{
synchronized (m_startAndStopLock) {
    hostLog.l7dlog(Level.INFO,LogKeys.host_VoltDB_StartupString.name(),null);
    m_mode=OperationMode.INITIALIZING;
    m_config=config;
    m_clientInterfaces.clear();
    m_dtxns.clear();
    m_adminListener=null;
    m_commandLog=new DummyCommandLog();
    m_deployment=null;
    m_messenger=null;
    m_statsAgent=new StatsAgent();
    m_asyncCompilerAgent=new AsyncCompilerAgent();
    m_faultManager=null;
    m_snapshotCompletionMonitor=null;
    m_catalogContext=null;
    m_partitionCountStats=null;
    m_ioStats=null;
    m_memoryStats=null;
    m_statsManager=null;
    m_restoreAgent=null;
    m_hostIdWithStartupCatalog=0;
    m_pathToStartupCatalog=m_config.m_pathToCatalog;
    m_computationService=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(),new ThreadFactory(){
      private int threadIndex=0;
      @Override public synchronized Thread newThread(      Runnable r){
        Thread t=new Thread(null,r,"Computation service thread - " + threadIndex++,131072);
        t.setDaemon(true);
        return t;
      }
    }
);
    boolean isRejoin=config.m_rejoinToHostAndPort != null;
    try {
      System.setOut(new PrintStream(System.out,true,"UTF-8"));
      System.setErr(new PrintStream(System.err,true,"UTF-8"));
    }
 catch (    UnsupportedEncodingException e) {
      hostLog.fatal("Support for the UTF-8 encoding is required for VoltDB. This means you are likely running an unsupported JVM. Exiting.");
      System.exit(-1);
    }
    if (System.getProperty("java.vm.name").contains("64") == false) {
      hostLog.fatal("You are running on an unsupported (probably 32 bit) JVM. Exiting.");
      System.exit(-1);
    }
    m_snapshotCompletionMonitor=new SnapshotCompletionMonitor();
    readBuildInfo(config.m_isEnterprise ? "Enterprise Edition" : "Community Edition");
    ResponseSampler.initializeIfEnabled();
    readDeploymentAndCreateStarterCatalogContext();
    final int availableProcessors=Runtime.getRuntime().availableProcessors();
    int poolSize=1;
    if (availableProcessors > 4) {
      poolSize=2;
    }
    m_periodicWorkThread=MiscUtils.getScheduledThreadPoolExecutor("Periodic Work",poolSize,1024 * 128);
    buildClusterMesh(isRejoin);
    m_licenseApi=MiscUtils.licenseApiFactory(m_config.m_pathToLicense);
    Inits inits=new Inits(this,1);
    inits.doInitializationWork();
    m_localSites=Collections.synchronizedMap(new HashMap<Long,ExecutionSite>());
    m_siteThreads=Collections.synchronizedMap(new HashMap<Long,Thread>());
    m_runners=new ArrayList<ExecutionSiteRunner>();
    if (config.m_backend.isIPC) {
      int eeCount=0;
      for (      Site site : m_catalogContext.siteTracker.getUpSites()) {
        if (site.getIsexec() && m_myHostId == Integer.parseInt(site.getHost().getTypeName())) {
          eeCount++;
        }
      }
      if (config.m_ipcPorts.size() != eeCount) {
        hostLog.fatal("Specified an IPC backend but only supplied " + config.m_ipcPorts.size() + " backend ports when "+ eeCount+ " are required");
        System.exit(-1);
      }
    }
    collectLocalNetworkMetadata();
    m_clusterMetadata.put(m_messenger.getHostId(),getLocalMetadata());
    Site siteForThisThread=null;
    m_currentThreadSite=null;
    for (    Site site : m_catalogContext.siteTracker.getUpSites()) {
      int sitesHostId=Integer.parseInt(site.getHost().getTypeName());
      long siteId=Long.parseLong(site.getTypeName());
      if (sitesHostId == m_myHostId) {
        if (site.getIsexec()) {
          if (siteForThisThread == null) {
            siteForThisThread=site;
          }
 else {
            ExecutionSiteRunner runner=new ExecutionSiteRunner(m_catalogContext,m_serializedCatalog,m_recovering,m_replicationActive,m_downHosts,hostLog);
            m_runners.add(runner);
            Thread runnerThread=new Thread(runner,"Site " + siteId);
            runnerThread.start();
            log.l7dlog(Level.TRACE,LogKeys.org_voltdb_VoltDB_CreatingThreadForSite.name(),new Object[]{siteId},null);
            m_siteThreads.put(siteId,runnerThread);
          }
        }
      }
    }
    try {
      int siteId=Integer.parseInt(siteForThisThread.getTypeName());
      ExecutionSite siteObj=new ExecutionSite(VoltDB.instance(),VoltDB.instance().getMessenger().createMailbox(),m_serializedCatalog,null,m_recovering,m_replicationActive,m_downHosts,m_catalogContext.m_transactionId);
      m_localSites.put(Long.parseLong(siteForThisThread.getTypeName()),siteObj);
      m_currentThreadSite=siteObj;
    }
 catch (    Exception e) {
      VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
    }
    for (    ExecutionSiteRunner runner : m_runners) {
synchronized (runner) {
        if (!runner.m_isSiteCreated) {
          try {
            runner.wait();
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
        m_localSites.put(runner.m_siteId,runner.m_siteObj);
      }
    }
    try {
      m_catalogContext.siteTracker.setMailboxTracker(new MailboxTracker(m_messenger.getZK()));
    }
 catch (    Exception e) {
      VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
    }
    int portOffset=0;
    for (    Site site : m_catalogContext.siteTracker.getUpSites()) {
      int sitesHostId=Integer.parseInt(site.getHost().getTypeName());
      int currSiteId=Integer.parseInt(site.getTypeName());
      if ((sitesHostId == m_myHostId) && (site.getIsexec() == false)) {
        SimpleDtxnInitiator initiator=new SimpleDtxnInitiator(m_catalogContext,m_messenger,m_myHostId,site.getInitiatorid(),m_config.m_timestampTestingSalt);
        try {
          ClientInterface ci=ClientInterface.create(m_messenger,m_catalogContext,m_replicationRole,initiator,m_catalogContext.numberOfNodes,currSiteId,site.getInitiatorid(),config.m_port + portOffset,config.m_adminPort + portOffset,m_config.m_timestampTestingSalt);
          m_clientInterfaces.add(ci);
        }
 catch (        Exception e) {
          VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
        }
        portOffset+=2;
        m_dtxns.add(initiator);
      }
    }
    m_partitionCountStats=new PartitionCountStats(m_catalogContext.numberOfPartitions);
    m_statsAgent.registerStatsSource(SysProcSelector.PARTITIONCOUNT,0,m_partitionCountStats);
    m_ioStats=new IOStats();
    m_statsAgent.registerStatsSource(SysProcSelector.IOSTATS,0,m_ioStats);
    m_memoryStats=new MemoryStats();
    m_statsAgent.registerStatsSource(SysProcSelector.MEMORY,0,m_memoryStats);
    m_statsManager=null;
    try {
      final Class<?> statsManagerClass=Class.forName("org.voltdb.management.JMXStatsManager");
      m_statsManager=(StatsManager)statsManagerClass.newInstance();
      m_statsManager.initialize(new ArrayList<Long>(m_localSites.keySet()));
    }
 catch (    Exception e) {
    }
    try {
      m_snapshotCompletionMonitor.init(m_messenger.getZK());
    }
 catch (    Exception e) {
      hostLog.fatal("Error initializing snapshot completion monitor",e);
      VoltDB.crashVoltDB();
    }
    if (m_commandLog != null && isRejoin) {
      m_commandLog.initForRejoin(m_catalogContext,Long.MIN_VALUE,0,m_downSites);
    }
    try {
      m_messenger.getZK().create("/readyhosts/host",null,Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);
      if (config.m_rejoinToHostAndPort == null) {
        List<String> readyhosts=null;
        do {
          readyhosts=m_messenger.getZK().getChildren("/readyhosts",false);
        }
 while (readyhosts.size() < m_deployment.getCluster().getHostcount());
      }
    }
 catch (    Exception e) {
      hostLog.fatal("Failed to announce ready state.");
      VoltDB.crashVoltDB();
    }
    heartbeatThread=new HeartbeatThread(m_clientInterfaces);
    heartbeatThread.start();
    schedulePeriodicWorks();
    logDebuggingInfo(m_config.m_adminPort,m_config.m_httpPort,m_httpPortExtraLogMessage,m_jsonEnabled);
    int k=m_catalogContext.numberOfExecSites / m_catalogContext.numberOfPartitions;
    if (k == 1) {
      hostLog.warn("Running without redundancy (k=0) is not recommended for production use.");
    }
    assert(m_clientInterfaces.size() > 0);
    ClientInterface ci=m_clientInterfaces.get(0);
    ci.initializeSnapshotDaemon();
    TransactionInitiator initiator=m_dtxns.get(0);
    if (m_restoreAgent != null) {
      m_restoreAgent.setCatalogContext(m_catalogContext);
      m_restoreAgent.setInitiator(initiator);
    }
  }
}
