{
synchronized (m_startAndStopLock) {
    if (System.getProperty("java.vm.name").contains("64") == false) {
      hostLog.fatal("You are running on an unsupported (probably 32 bit) JVM. Exiting.");
      System.exit(-1);
    }
    consoleLog.l7dlog(Level.INFO,LogKeys.host_VoltDB_StartupString.name(),null);
    if (!config.m_enableIV2) {
      consoleLog.warn("Running 3.0 preview (legacy mode).  THIS MODE IS DEPRECATED.");
    }
    if (config.m_pathToDeployment == null) {
      try {
        config.m_pathToDeployment=setupDefaultDeployment();
      }
 catch (      IOException e) {
        VoltDB.crashLocalVoltDB("Failed to write default deployment.",false,null);
      }
    }
    m_mode=OperationMode.INITIALIZING;
    m_config=config;
    m_startMode=null;
    m_clientInterfaces.clear();
    m_adminListener=null;
    m_commandLog=new DummyCommandLog();
    m_deployment=null;
    m_messenger=null;
    m_startMode=null;
    m_statsAgent=new StatsAgent();
    m_asyncCompilerAgent=new AsyncCompilerAgent();
    m_faultManager=null;
    m_snapshotCompletionMonitor=null;
    m_catalogContext=null;
    m_partitionCountStats=null;
    m_ioStats=null;
    m_memoryStats=null;
    m_statsManager=null;
    m_restoreAgent=null;
    m_recoveryStartTime=System.currentTimeMillis();
    m_hostIdWithStartupCatalog=0;
    m_pathToStartupCatalog=m_config.m_pathToCatalog;
    m_replicationActive=false;
    m_localSites=new COWMap<Long,ExecutionSite>();
    m_siteThreads=new HashMap<Long,Thread>();
    m_runners=new ArrayList<ExecutionSiteRunner>();
    final int computationThreads=Math.max(2,CoreUtils.availableProcessors() / 4);
    m_computationService=CoreUtils.getListeningExecutorService("Computation service thread",computationThreads,m_config.m_computationCoreBindings);
    boolean isRejoin=false;
    if (config.m_startAction.doesRejoin()) {
      isRejoin=true;
    }
    m_rejoining=isRejoin;
    m_rejoinDataPending=isRejoin;
    m_joining=config.m_startAction == StartAction.JOIN;
    try {
      System.setOut(new PrintStream(System.out,true,"UTF-8"));
      System.setErr(new PrintStream(System.err,true,"UTF-8"));
    }
 catch (    UnsupportedEncodingException e) {
      hostLog.fatal("Support for the UTF-8 encoding is required for VoltDB. This means you are likely running an unsupported JVM. Exiting.");
      System.exit(-1);
    }
    m_snapshotCompletionMonitor=new SnapshotCompletionMonitor();
    readBuildInfo(config.m_isEnterprise ? "Enterprise Edition" : "Community Edition");
    buildClusterMesh(isRejoin || m_joining);
    final Future<?> buildStringValidation=validateBuildString(getBuildString(),m_messenger.getZK());
    final int numberOfNodes=readDeploymentAndCreateStarterCatalogContext();
    if (!isRejoin && !m_joining) {
      m_messenger.waitForGroupJoin(numberOfNodes);
    }
    m_faultManager=new FaultDistributor(this);
    m_faultManager.registerFaultHandler(SiteFailureFault.SITE_FAILURE_CATALOG,m_faultHandler,FaultType.SITE_FAILURE);
    if (!m_faultManager.testPartitionDetectionDirectory(m_catalogContext.cluster.getFaultsnapshots().get("CLUSTER_PARTITION"))) {
      VoltDB.crashLocalVoltDB("Unable to create partition detection snapshot directory at" + m_catalogContext.cluster.getFaultsnapshots().get("CLUSTER_PARTITION"),false,null);
    }
    m_periodicWorkThread=CoreUtils.getScheduledThreadPoolExecutor("Periodic Work",1,CoreUtils.SMALL_STACK_SIZE);
    m_periodicPriorityWorkThread=CoreUtils.getScheduledThreadPoolExecutor("Periodic Priority Work",1,CoreUtils.SMALL_STACK_SIZE);
    m_licenseApi=MiscUtils.licenseApiFactory(m_config.m_pathToLicense);
    if (m_licenseApi == null) {
      VoltDB.crashLocalVoltDB("Failed to initialize license verifier. " + "See previous log message for details.",false,null);
    }
    m_globalServiceElector=new GlobalServiceElector(m_messenger.getZK(),m_messenger.getHostId());
    Joiner joinCoordinator=null;
    if (m_joining) {
      Class<?> joinerClass=MiscUtils.loadProClass("org.voltdb.JoinerImpl","Elastic",false);
      try {
        Constructor<?> constructor=joinerClass.getConstructor(HostMessenger.class);
        joinCoordinator=(Joiner)constructor.newInstance(m_messenger);
        m_rejoinCoordinator=joinCoordinator;
        m_messenger.registerMailbox(m_rejoinCoordinator);
      }
 catch (      Exception e) {
        VoltDB.crashLocalVoltDB("Failed to instantiate joiner",true,e);
      }
    }
    ClusterConfig clusterConfig=null;
    JSONObject topo=getTopology(config.m_startAction,joinCoordinator);
    m_partitionsToSitesAtStartupForExportInit=new ArrayList<Pair<Integer,Long>>();
    try {
      clusterConfig=new ClusterConfig(topo);
      m_configuredNumberOfPartitions=clusterConfig.getPartitionCount();
      if (isIV2Enabled()) {
        m_cartographer=new Cartographer(m_messenger);
        List<Integer> partitions=null;
        if (isRejoin) {
          partitions=m_cartographer.getIv2PartitionsToReplace(topo);
          if (partitions.size() == 0) {
            VoltDB.crashLocalVoltDB("The VoltDB cluster already has enough nodes to satisfy " + "the requested k-safety factor of " + clusterConfig.getReplicationFactor() + ".\n"+ "No more nodes can join.",false,null);
          }
        }
 else         if (m_joining) {
          partitions=joinCoordinator.getPartitionsToAdd();
        }
 else {
          partitions=ClusterConfig.partitionsForHost(topo,m_messenger.getHostId());
        }
        for (int ii=0; ii < partitions.size(); ii++) {
          Integer partition=partitions.get(ii);
          m_iv2InitiatorStartingTxnIds.put(partition,TxnEgo.makeZero(partition).getTxnId());
        }
        m_iv2Initiators=createIv2Initiators(partitions,m_config.m_startAction,m_partitionsToSitesAtStartupForExportInit);
        m_iv2InitiatorStartingTxnIds.put(MpInitiator.MP_INIT_PID,TxnEgo.makeZero(MpInitiator.MP_INIT_PID).getTxnId());
        long mpiBuddyHSId=m_iv2Initiators.get(0).getInitiatorHSId();
        m_MPI=new MpInitiator(m_messenger,mpiBuddyHSId,m_statsAgent);
        m_iv2Initiators.add(m_MPI);
      }
      clusterConfig=new ClusterConfig(topo);
      final long statsHSId=m_messenger.getHSIdForLocalSite(HostMessenger.STATS_SITE_ID);
      m_messenger.generateMailboxId(statsHSId);
      hostLog.info("Registering stats mailbox id " + CoreUtils.hsIdToString(statsHSId));
      List<Long> hsidsToRejoin=new ArrayList<Long>();
      for (      Initiator init : m_iv2Initiators) {
        if (init.isRejoinable()) {
          hsidsToRejoin.add(init.getInitiatorHSId());
        }
      }
      if (isRejoin && isIV2Enabled()) {
        SnapshotSaveAPI.recoveringSiteCount.set(hsidsToRejoin.size());
        hostLog.info("Set recovering site count to " + hsidsToRejoin.size());
        m_rejoinCoordinator=new Iv2RejoinCoordinator(m_messenger,hsidsToRejoin,m_catalogContext.cluster.getVoltroot(),m_config.m_startAction == StartAction.LIVE_REJOIN);
        m_messenger.registerMailbox(m_rejoinCoordinator);
        if (m_config.m_startAction == StartAction.LIVE_REJOIN) {
          hostLog.info("Using live rejoin.");
        }
 else {
          hostLog.info("Using blocking rejoin.");
        }
      }
 else       if (m_joining) {
        joinCoordinator.setSites(hsidsToRejoin);
      }
    }
 catch (    Exception e) {
      VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
    }
    Inits inits=new Inits(this,1);
    inits.doInitializationWork();
    if (config.m_backend.isIPC) {
      int eeCount=clusterConfig.getSitesPerHost();
      if (config.m_ipcPorts.size() != eeCount) {
        hostLog.fatal("Specified an IPC backend but only supplied " + config.m_ipcPorts.size() + " backend ports when "+ eeCount+ " are required");
        System.exit(-1);
      }
    }
    collectLocalNetworkMetadata();
    final CatalogSpecificPlanner csp=new CatalogSpecificPlanner(m_asyncCompilerAgent,m_catalogContext);
    File drOverflowDir=new File(m_catalogContext.cluster.getVoltroot(),"dr_overflow");
    if (m_config.m_isEnterprise) {
      try {
        Class<?> ndrgwClass=Class.forName("org.voltdb.dr.InvocationBufferServer");
        Constructor<?> ndrgwConstructor=ndrgwClass.getConstructor(File.class,boolean.class);
        m_nodeDRGateway=(NodeDRGateway)ndrgwConstructor.newInstance(drOverflowDir,m_replicationActive);
      }
 catch (      Exception e) {
        VoltDB.crashLocalVoltDB("Unable to load DR system",true,e);
      }
    }
    m_ioStats=new IOStats();
    m_statsAgent.registerStatsSource(SysProcSelector.IOSTATS,0,m_ioStats);
    m_memoryStats=new MemoryStats();
    m_statsAgent.registerStatsSource(SysProcSelector.MEMORY,0,m_memoryStats);
    m_statsAgent.registerStatsSource(SysProcSelector.TOPO,0,m_cartographer);
    m_partitionCountStats=new PartitionCountStats(m_cartographer);
    m_statsAgent.registerStatsSource(SysProcSelector.PARTITIONCOUNT,0,m_partitionCountStats);
    m_initiatorStats=new InitiatorStats(m_myHostId);
    m_latencyStats=new LatencyStats(m_myHostId);
    if (m_commandLog != null && isRejoin) {
      m_commandLog.initForRejoin(m_catalogContext,Long.MIN_VALUE,m_iv2InitiatorStartingTxnIds,true,m_config.m_commandLogBinding);
    }
    try {
      boolean usingCommandLog=m_config.m_isEnterprise && m_catalogContext.cluster.getLogconfig().get("log").getEnabled();
      m_leaderAppointer=new LeaderAppointer(m_messenger,clusterConfig.getPartitionCount(),m_deployment.getCluster().getKfactor(),m_catalogContext.cluster.getNetworkpartition(),m_catalogContext.cluster.getFaultsnapshots().get("CLUSTER_PARTITION"),usingCommandLog,topo,m_MPI);
      m_globalServiceElector.registerService(m_leaderAppointer);
      for (      Initiator iv2init : m_iv2Initiators) {
        iv2init.configure(getBackendTargetType(),m_serializedCatalog,m_catalogContext,m_deployment.getCluster().getKfactor(),csp,clusterConfig.getPartitionCount(),m_config.m_startAction,m_statsAgent,m_memoryStats,m_commandLog,m_nodeDRGateway,m_config.m_executionCoreBindings.poll());
      }
    }
 catch (    Exception e) {
      Throwable toLog=e;
      if (e instanceof ExecutionException) {
        toLog=((ExecutionException)e).getCause();
      }
      VoltDB.crashLocalVoltDB("Error configuring IV2 initiator.",true,toLog);
    }
    try {
      m_globalServiceElector.start();
    }
 catch (    Exception e) {
      VoltDB.crashLocalVoltDB("Unable to start GlobalServiceElector",true,e);
    }
    int portOffset=0;
    for (int i=0; i < 1; i++) {
      try {
        ClientInterface ci=ClientInterface.create(m_messenger,m_catalogContext,m_config.m_replicationRole,m_cartographer,clusterConfig.getPartitionCount(),config.m_port + portOffset,config.m_adminPort + portOffset,m_config.m_timestampTestingSalt);
        portOffset+=2;
        m_clientInterfaces.add(ci);
      }
 catch (      Exception e) {
        VoltDB.crashLocalVoltDB(e.getMessage(),true,e);
      }
      portOffset+=2;
    }
    m_statsManager=null;
    try {
      final Class<?> statsManagerClass=MiscUtils.loadProClass("org.voltdb.management.JMXStatsManager","JMX",true);
      if (statsManagerClass != null) {
        ArrayList<Long> localHSIds;
        Long MPHSId;
        if (isIV2Enabled()) {
          localHSIds=new ArrayList<Long>();
          for (          Initiator iv2Initiator : m_iv2Initiators) {
            localHSIds.add(iv2Initiator.getInitiatorHSId());
          }
          MPHSId=m_MPI.getInitiatorHSId();
        }
 else {
          localHSIds=new ArrayList<Long>(m_localSites.keySet());
          MPHSId=null;
        }
        m_statsManager=(StatsManager)statsManagerClass.newInstance();
        m_statsManager.initialize(localHSIds,MPHSId);
      }
    }
 catch (    Exception e) {
      hostLog.error("Failed to instantiate the JMX stats manager: " + e.getMessage() + ". Disabling JMX.");
      e.printStackTrace();
    }
    try {
      m_snapshotCompletionMonitor.init(m_messenger.getZK());
    }
 catch (    Exception e) {
      hostLog.fatal("Error initializing snapshot completion monitor",e);
      VoltDB.crashLocalVoltDB("Error initializing snapshot completion monitor",true,e);
    }
    try {
      buildStringValidation.get();
    }
 catch (    Exception e) {
      VoltDB.crashLocalVoltDB("Failed to validate cluster build string",false,e);
    }
    if (!isRejoin && !m_joining) {
      try {
        m_messenger.waitForAllHostsToBeReady(m_deployment.getCluster().getHostcount());
      }
 catch (      Exception e) {
        hostLog.fatal("Failed to announce ready state.");
        VoltDB.crashLocalVoltDB("Failed to announce ready state.",false,null);
      }
    }
    if (!m_joining && (m_cartographer.getPartitions().size() - 1) != m_configuredNumberOfPartitions) {
      for (      Map.Entry<Integer,ImmutableList<Long>> entry : getSiteTrackerForSnapshot().m_partitionsToSitesImmutable.entrySet()) {
        hostLog.info(entry.getKey() + " -- " + CoreUtils.hsIdCollectionToString(entry.getValue()));
      }
      VoltDB.crashGlobalVoltDB("Mismatch between configured number of partitions (" + m_configuredNumberOfPartitions + ") and actual ("+ (m_cartographer.getPartitions().size() - 1)+ ")",true,null);
    }
    schedulePeriodicWorks();
    m_clientInterfaces.get(0).schedulePeriodicWorks();
    logDebuggingInfo(m_config.m_adminPort,m_config.m_httpPort,m_httpPortExtraLogMessage,m_jsonEnabled);
    if (clusterConfig.getReplicationFactor() == 0) {
      hostLog.warn("Running without redundancy (k=0) is not recommended for production use.");
    }
    if ((m_catalogContext.cluster.getNetworkpartition() == false) && (clusterConfig.getReplicationFactor() > 0)) {
      hostLog.warn("Running a redundant (k-safe) cluster with network " + "partition detection disabled is not recommended for production use.");
    }
    assert(m_clientInterfaces.size() > 0);
    ClientInterface ci=m_clientInterfaces.get(0);
    ci.initializeSnapshotDaemon(m_messenger.getZK(),m_globalServiceElector);
    if (m_restoreAgent != null) {
      ci.bindAdapter(m_restoreAgent.getAdapter());
      m_restoreAgent.setCatalogContext(m_catalogContext);
      m_restoreAgent.setInitiator(new Iv2TransactionCreator(m_clientInterfaces.get(0)));
    }
  }
}
