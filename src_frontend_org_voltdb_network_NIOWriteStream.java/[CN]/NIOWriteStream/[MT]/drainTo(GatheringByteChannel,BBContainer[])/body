{
  if (additional != null) {
    for (    final BBContainer c : additional) {
      m_queuedBuffers.offer(c);
    }
  }
  int bytesWritten=0;
  long rc=0;
  do {
    ByteBuffer buffers[]=null;
    ByteBuffer buffer=null;
    if (m_queuedBuffers.isEmpty()) {
      if (m_hadBackPressure && m_queuedWrites.size() <= m_maxQueuedWritesBeforeBackpressure) {
        backpressureEnded();
      }
      m_lastPendingWriteTime=-1;
      updateQueued(-bytesWritten,false);
      m_bytesWritten+=bytesWritten;
      return bytesWritten;
    }
    final int queuedForWrite=0;
    final BBContainer peekedBuffer=m_queuedBuffers.peek();
    if (peekedBuffer.b.remaining() > MAX_GATHERING_WRITE) {
      if (!peekedBuffer.b.isDirect()) {
        m_queuedBuffers.push(peekedBuffer);
        final int originalPosition=peekedBuffer.b.position();
        do {
          final int amountToSplit=Math.min(peekedBuffer.b.remaining(),MAX_GATHERING_WRITE);
          peekedBuffer.b.position(peekedBuffer.b.limit() - amountToSplit);
          final BBContainer splice=DBBPool.wrapBB(peekedBuffer.b.slice());
          m_queuedBuffers.push(splice);
          m_messagesWritten--;
          peekedBuffer.b.limit(peekedBuffer.b.position());
          peekedBuffer.b.position(originalPosition);
        }
 while (peekedBuffer.b.hasRemaining());
        buffer=m_queuedBuffers.peek().b;
      }
 else {
        buffer=peekedBuffer.b;
      }
    }
 else {
      final int queuedBuffersSize=m_queuedBuffers.size();
      buffers=new ByteBuffer[queuedBuffersSize < 10 ? queuedBuffersSize : 10];
      int ii=0;
      for (      final BBContainer c : m_queuedBuffers) {
        final int potentialQueuedForWrite=queuedForWrite + c.b.remaining();
        if (potentialQueuedForWrite > MAX_GATHERING_WRITE) {
          final ByteBuffer oldArray[]=buffers;
          buffers=new ByteBuffer[ii];
          for (int zz=0; zz < ii; zz++) {
            buffers[zz]=oldArray[zz];
          }
          break;
        }
        if (!c.b.isDirect()) {
          if (ii == 0) {
            buffers=null;
            buffer=c.b;
            break;
          }
 else {
            final ByteBuffer oldArray[]=buffers;
            buffers=new ByteBuffer[ii];
            for (int zz=0; zz < ii; zz++) {
              buffers[zz]=oldArray[zz];
            }
            break;
          }
        }
        buffers[ii++]=c.b;
        if (ii == 10) {
          break;
        }
      }
    }
    rc=0;
    if (buffers != null) {
      assert(checkAllDirect(buffers));
      rc=channel.write(buffers);
      for (      final ByteBuffer b : buffers) {
        if (!b.hasRemaining()) {
          m_queuedBuffers.poll().discard();
          m_messagesWritten++;
        }
 else {
          if (!m_hadBackPressure) {
            backpressureStarted();
          }
          break;
        }
      }
    }
 else {
      rc=channel.write(buffer);
      if (buffer.hasRemaining()) {
        if (!m_hadBackPressure) {
          backpressureStarted();
        }
      }
 else {
        m_queuedBuffers.poll().discard();
        m_messagesWritten++;
      }
    }
    bytesWritten+=rc;
  }
 while (rc > 0);
  if (m_queuedBuffers.isEmpty() && m_hadBackPressure && m_queuedWrites.size() <= m_maxQueuedWritesBeforeBackpressure) {
    backpressureEnded();
  }
  if (!isEmpty()) {
    if (bytesWritten > 0) {
      m_lastPendingWriteTime=EstTime.currentTimeMillis();
    }
  }
 else {
    m_lastPendingWriteTime=-1;
  }
  updateQueued(-bytesWritten,false);
  m_bytesWritten+=bytesWritten;
  return bytesWritten;
}
