{
  final String className=procedureDescriptor.m_className;
  if (className.indexOf('@') != -1) {
    throw compiler.new VoltCompilerException("User procedure names can't contain \"@\".");
  }
  String shortName=className;
  if (procedureDescriptor.m_builtInStmt == false) {
    String[] parts=className.split("\\.");
    shortName=parts[parts.length - 1];
  }
  final Procedure procedure=db.getProcedures().add(shortName);
  for (  String groupName : procedureDescriptor.m_authGroups) {
    final Group group=db.getGroups().get(groupName);
    if (group == null) {
      throw compiler.new VoltCompilerException("Procedure " + className + " has a group "+ groupName+ " that does not exist");
    }
    final GroupRef groupRef=procedure.getAuthgroups().add(groupName);
    groupRef.setGroup(group);
  }
  procedure.setClassname(className);
  procedure.setSystemproc(false);
  procedure.setDefaultproc(procedureDescriptor.m_builtInStmt);
  procedure.setHasjava(false);
  ProcInfoData info=compiler.getProcInfoOverride(shortName);
  if (info == null) {
    info=new ProcInfoData();
    if (procedureDescriptor.m_partitionString != null) {
      info.partitionInfo=procedureDescriptor.m_partitionString;
      info.singlePartition=true;
    }
  }
  assert(info != null);
  Statement catalogStmt=procedure.getStatements().add(VoltDB.ANON_STMT_NAME);
  StatementPartitioning partitioning=info.singlePartition ? StatementPartitioning.forceSP() : StatementPartitioning.forceMP();
  StatementCompiler.compile(compiler,hsql,catalog,db,estimates,catalogStmt,procedureDescriptor.m_singleStmt,procedureDescriptor.m_joinOrder,DeterminismMode.FASTER,partitioning);
  boolean procHasWriteStmts=(catalogStmt.getReadonly() == false);
  procedure.setReadonly(procHasWriteStmts == false);
  int seqs=catalogStmt.getSeqscancount();
  procedure.setHasseqscans(seqs > 0);
  CatalogMap<ProcParameter> params=procedure.getParameters();
  CatalogMap<StmtParameter> stmtParams=catalogStmt.getParameters();
  int paramCount=0;
  for (  StmtParameter stmtParam : CatalogUtil.getSortedCatalogItems(stmtParams,"index")) {
    ProcParameter procParam=params.add("param" + String.valueOf(paramCount));
    procParam.setIndex(stmtParam.getIndex());
    procParam.setIsarray(stmtParam.getIsarray());
    procParam.setType(stmtParam.getJavatype());
    paramCount++;
  }
  procedure.setSinglepartition(info.singlePartition);
  if (info.singlePartition) {
    parsePartitionInfo(compiler,db,procedure,info.partitionInfo);
    if (procedure.getPartitionparameter() >= params.size()) {
      String msg="PartitionInfo parameter not a valid parameter for procedure: " + procedure.getClassname();
      throw compiler.new VoltCompilerException(msg);
    }
  }
 else {
    if (partitioning.getCountOfIndependentlyPartitionedTables() == 1) {
      AbstractExpression statementPartitionExpression=partitioning.singlePartitioningExpressionForReport();
      if (statementPartitionExpression != null) {
        String msg=null;
        if (statementPartitionExpression instanceof ParameterValueExpression) {
          msg="This procedure would benefit from setting the attribute 'partitioninfo=" + partitioning.getFullColumnName() + ":"+ ((ParameterValueExpression)statementPartitionExpression).getParameterIndex()+ "'";
        }
 else {
          String valueDescription=null;
          Object partitionValue=partitioning.getInferredPartitioningValue();
          if (partitionValue == null) {
            valueDescription="of " + statementPartitionExpression.explain("");
          }
 else {
            valueDescription=partitionValue.toString();
          }
          msg="This procedure would benefit from adding a parameter to be passed the value " + valueDescription + " and setting the attribute 'partitioninfo="+ partitioning.getFullColumnName()+ ":"+ paramCount+ "'";
        }
        compiler.addWarn(msg);
      }
    }
  }
}
