{
  assert(serializedBatchData != null);
  ByteBuffer buf=ByteBuffer.wrap(serializedBatchData);
  AdHocPlannedStatement[] statements=null;
  Object[] userparams=null;
  try {
    userparams=AdHocPlannedStmtBatch.userParamsFromBuffer(buf);
    statements=AdHocPlannedStmtBatch.planArrayFromBuffer(buf);
  }
 catch (  IOException e) {
    throw new VoltAbortException(e);
  }
  if (statements.length == 0) {
    return new VoltTable[]{};
  }
  for (  AdHocPlannedStatement statement : statements) {
    byte[] catalogHash=ctx.getCatalogContext().getCatalogHash();
    if (!statement.core.wasPlannedAgainstHash(catalogHash)) {
      String msg="AdHoc transaction " + m_runner.getTransactionId() + " was planned against the past catalog version ("+ statement.core.obsoleteCatalogHashTokenForMessage()+ ") and wasn't planned against the current catalog version ("+ Encoder.hexEncode(catalogHash).substring(0,10)+ "). Statement: "+ new String(statement.sql,Constants.UTF8ENCODING);
      throw new VoltAbortException(msg);
    }
    long aggFragId=ActivePlanRepository.loadOrAddRefPlanFragment(statement.core.aggregatorHash,statement.core.aggregatorFragment,null);
    long collectorFragId=0;
    if (statement.core.collectorFragment != null) {
      collectorFragId=ActivePlanRepository.loadOrAddRefPlanFragment(statement.core.collectorHash,statement.core.collectorFragment,null);
    }
    SQLStmt stmt=SQLStmtAdHocHelper.createWithPlan(statement.sql,aggFragId,statement.core.aggregatorHash,true,collectorFragId,statement.core.collectorHash,true,statement.core.isReplicatedTableDML,statement.core.readOnly,statement.core.parameterTypes,m_site);
    Object[] params;
    if (userparams.length > 0) {
      params=userparams;
    }
 else {
      params=statement.extractedParamArray();
    }
    voltQueueSQL(stmt,params);
  }
  return voltExecuteSQL(true);
}
