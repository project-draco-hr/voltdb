{
  assert(serializedBatchData != null);
  ByteBuffer buf=ByteBuffer.wrap(serializedBatchData);
  AdHocPlannedStatement[] statements=null;
  Object[] userparams=null;
  try {
    userparams=AdHocPlannedStmtBatch.userParamsFromBuffer(buf);
    statements=AdHocPlannedStmtBatch.planArrayFromBuffer(buf);
  }
 catch (  IOException e) {
    throw new VoltAbortException(e);
  }
  if (statements.length == 0) {
    return new VoltTable[]{};
  }
  int currentCatalogVersion=ctx.getCatalogVersion();
  for (  AdHocPlannedStatement statement : statements) {
    if (currentCatalogVersion != statement.core.catalogVersion) {
      String msg=String.format("AdHoc transaction %d wasn't planned " + "against the current catalog version. Statement: %s",getVoltPrivateRealTransactionIdDontUseMe(),new String(statement.sql,Constants.UTF8ENCODING));
      throw new VoltAbortException(msg);
    }
    long aggFragId=ActivePlanRepository.loadOrAddRefPlanFragment(statement.core.aggregatorHash,statement.core.aggregatorFragment);
    long collectorFragId=0;
    if (statement.core.collectorFragment != null) {
      collectorFragId=ActivePlanRepository.loadOrAddRefPlanFragment(statement.core.collectorHash,statement.core.collectorFragment);
    }
    SQLStmt stmt=SQLStmtAdHocHelper.createWithPlan(statement.sql,aggFragId,statement.core.aggregatorHash,true,collectorFragId,statement.core.collectorHash,true,statement.core.isReplicatedTableDML,statement.core.readOnly,statement.core.parameterTypes,m_site);
    Object[] params;
    if (userparams.length > 0) {
      params=userparams;
    }
 else {
      params=statement.extractedParamArray();
    }
    voltQueueSQL(stmt,params);
  }
  return voltExecuteSQL(true);
}
