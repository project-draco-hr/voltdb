{
  if (m_bestAndOnlyPlanWasGenerated) {
    return null;
  }
  m_bestAndOnlyPlanWasGenerated=true;
  AbstractPlanNode subUnionRoot=new UnionPlanNode(m_parsedUnion.m_unionType);
  m_recentErrorMsg=null;
  ArrayList<CompiledPlan> childrenPlans=new ArrayList<CompiledPlan>();
  ParsedResultAccumulator parsedResult=new ParsedResultAccumulator();
  for (  AbstractParsedStmt parsedChildStmt : m_parsedUnion.m_children) {
    parsedResult=planForParsedStmt(parsedChildStmt,parsedResult);
    parsedResult=setCommonPartitioning(parsedResult);
    if (parsedResult.m_compiledPlan == null) {
      return null;
    }
    childrenPlans.add(parsedResult.m_compiledPlan);
  }
  if (parsedResult.m_commonPartitioning != null) {
    m_partitioning=(PartitioningForStatement)parsedResult.m_commonPartitioning.clone();
  }
  m_planSelector.m_planId=parsedResult.m_planId;
  for (  CompiledPlan selectPlan : childrenPlans) {
    subUnionRoot.addAndLinkChild(selectPlan.rootPlanGraph);
  }
  CompiledPlan retval=new CompiledPlan();
  retval.rootPlanGraph=subUnionRoot;
  retval.readOnly=true;
  retval.sql=m_planSelector.m_sql;
  boolean orderIsDeterministic=m_parsedUnion.isOrderDeterministic();
  boolean hasLimitOrOffset=m_parsedUnion.hasLimitOrOffset();
  retval.statementGuaranteesDeterminism(hasLimitOrOffset,orderIsDeterministic);
  retval.cost=0.0;
  for (  CompiledPlan bestChildPlan : childrenPlans) {
    retval.cost+=bestChildPlan.cost;
  }
  return retval;
}
