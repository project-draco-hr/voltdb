{
  AbstractParsedStmt subQuery=subqueryScan.getSubqueryStmt();
  assert(subQuery != null);
  PlanSelector selector=(PlanSelector)m_planSelector.clone();
  selector.m_planId=planId;
  StatementPartitioning currentPartitioning=(StatementPartitioning)m_partitioning.clone();
  PlanAssembler assembler=new PlanAssembler(m_catalogCluster,m_catalogDb,currentPartitioning,selector);
  CompiledPlan compiledPlan=assembler.getBestCostPlan(subQuery);
  if (compiledPlan == null) {
    String tbAlias=subqueryScan.getTableAlias();
    m_recentErrorMsg="Subquery statement for table " + tbAlias + " has error: "+ assembler.getErrorMessage();
    if (m_recentErrorMsg == null) {
      m_recentErrorMsg="Unable to plan for subquery statement for table " + tbAlias;
    }
    return null;
  }
  subqueryScan.setSubqueriesPartitioning(currentPartitioning);
  compiledPlan.rootPlanGraph=subqueryScan.processReceiveNode(compiledPlan.rootPlanGraph);
  subqueryScan.setBestCostPlan(compiledPlan);
  ParsedResultAccumulator parsedResult=new ParsedResultAccumulator(compiledPlan.isOrderDeterministic(),compiledPlan.hasLimitOrOffset(),selector.m_planId);
  return parsedResult;
}
