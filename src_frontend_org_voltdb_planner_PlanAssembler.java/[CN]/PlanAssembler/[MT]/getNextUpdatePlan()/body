{
  assert(subAssembler != null);
  AbstractPlanNode subSelectRoot=subAssembler.nextPlan();
  if (subSelectRoot == null)   return null;
  UpdatePlanNode updateNode=new UpdatePlanNode();
  Table targetTable=m_parsedUpdate.tableList.get(0);
  updateNode.setTargetTableName(targetTable.getTypeName());
  updateNode.setUpdateIndexes(false);
  ProjectionPlanNode projectionNode=new ProjectionPlanNode();
  TupleAddressExpression tae=new TupleAddressExpression();
  NodeSchema proj_schema=new NodeSchema();
  proj_schema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE","tuple_address","tuple_address",tae));
  Set<String> affectedColumns=getIndexedColumnSetForTable(targetTable);
  for (  Entry<Column,AbstractExpression> col : m_parsedUpdate.columns.entrySet()) {
    AbstractExpression castedExpr=null;
    try {
      castedExpr=(AbstractExpression)col.getValue().clone();
      ExpressionUtil.setOutputTypeForInsertExpression(castedExpr,VoltType.get((byte)col.getKey().getType()),col.getKey().getSize(),m_paramTypeOverrideMap);
    }
 catch (    Exception e) {
      throw new PlanningErrorException(e.getMessage());
    }
    proj_schema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE",col.getKey().getTypeName(),col.getKey().getTypeName(),castedExpr));
    if (affectedColumns.contains(col.getKey().getTypeName())) {
      updateNode.setUpdateIndexes(true);
    }
  }
  projectionNode.setOutputSchema(proj_schema);
  if (m_partitioning.wasSpecifiedAsSingle()) {
    assert(subSelectRoot instanceof AbstractScanPlanNode);
    subSelectRoot.addInlinePlanNode(projectionNode);
    updateNode.addAndLinkChild(subSelectRoot);
    updateNode.generateOutputSchema(m_catalogDb);
    return updateNode;
  }
 else {
    subSelectRoot=subAssembler.addSendReceivePair(subSelectRoot);
    assert(subSelectRoot instanceof ReceivePlanNode);
    ReceivePlanNode recvNode=(ReceivePlanNode)subSelectRoot;
    assert(recvNode.getChildCount() == 1);
    AbstractPlanNode sendNode=recvNode.getChild(0);
    assert(sendNode.getChildCount() == 1);
    AbstractPlanNode scanNode=sendNode.getChild(0);
    sendNode.unlinkChild(scanNode);
    assert(scanNode instanceof AbstractScanPlanNode);
    scanNode.addInlinePlanNode(projectionNode);
    updateNode.addAndLinkChild(scanNode);
    updateNode.generateOutputSchema(m_catalogDb);
    sendNode.addAndLinkChild(updateNode);
    sendNode.generateOutputSchema(m_catalogDb);
    recvNode.generateOutputSchema(m_catalogDb);
    return addSumAndSendToDMLNode(subSelectRoot);
  }
}
