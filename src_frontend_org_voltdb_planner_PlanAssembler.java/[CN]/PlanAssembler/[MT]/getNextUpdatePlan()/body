{
  assert(subAssembler != null);
  assert(m_parsedUpdate.tableList.size() == 1);
  Table targetTable=m_parsedUpdate.tableList.get(0);
  if (m_singlePartition && (targetTable.getIsreplicated())) {
    String msg="Trying to update replicated table '" + targetTable.getTypeName() + "'";
    msg+=" in a single-partition procedure.";
    throw new PlanningErrorException(msg);
  }
  AbstractPlanNode subSelectRoot=subAssembler.nextPlan();
  if (subSelectRoot == null)   return null;
  UpdatePlanNode updateNode=new UpdatePlanNode(m_context);
  updateNode.setTargetTableName(targetTable.getTypeName());
  updateNode.setUpdateIndexes(false);
  ProjectionPlanNode projectionNode=new ProjectionPlanNode(m_context);
  TupleAddressExpression tae=new TupleAddressExpression();
  PlanColumn colInfo=m_context.getPlanColumn(tae,"tuple_address");
  projectionNode.appendOutputColumn(colInfo);
  Set<String> affectedColumns=getIndexedColumnSetForTable(targetTable);
  int index=1;
  for (  Entry<Column,AbstractExpression> col : m_parsedUpdate.columns.entrySet()) {
    colInfo=m_context.getPlanColumn(col.getValue(),col.getKey().getTypeName());
    projectionNode.appendOutputColumn(colInfo);
    index++;
    if (affectedColumns.contains(colInfo.displayName()))     updateNode.setUpdateIndexes(true);
  }
  if (m_singlePartition == true) {
    assert(subSelectRoot instanceof AbstractScanPlanNode);
    subSelectRoot.addInlinePlanNode(projectionNode);
    updateNode.addAndLinkChild(subSelectRoot);
    return updateNode;
  }
 else {
    assert(subSelectRoot instanceof ReceivePlanNode);
    ReceivePlanNode recvNode=(ReceivePlanNode)subSelectRoot;
    assert(recvNode.getChildCount() == 1);
    AbstractPlanNode sendNode=recvNode.getChild(0);
    assert(sendNode.getChildCount() == 1);
    AbstractPlanNode scanNode=sendNode.getChild(0);
    sendNode.unlinkChild(scanNode);
    assert(scanNode instanceof AbstractScanPlanNode);
    scanNode.addInlinePlanNode(projectionNode);
    updateNode.addAndLinkChild(scanNode);
    sendNode.addAndLinkChild(updateNode);
    recvNode.updateOutputColumns(m_catalogDb);
    return addSumAndSendToDMLNode(subSelectRoot);
  }
}
