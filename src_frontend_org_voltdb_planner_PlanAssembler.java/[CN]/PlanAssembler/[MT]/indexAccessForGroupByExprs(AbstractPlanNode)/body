{
  if (root.getPlanNodeType() == PlanNodeType.SEQSCAN && m_parsedSelect.isGrouped()) {
    Table targetTable=m_catalogDb.getTables().get(((SeqScanPlanNode)root).getTargetTableName());
    CatalogMap<Index> allIndexes=targetTable.getIndexes();
    ArrayList<ParsedColInfo> groupBys=m_parsedSelect.groupByColumns;
    List<AbstractExpression> tves=groupBys.get(0).expression.findBaseTVEs();
    String fromTable=null;
    for (    AbstractExpression expr : tves) {
      String newTableAlias=((TupleValueExpression)expr).getTableAlias();
      if (fromTable == null) {
        fromTable=newTableAlias;
      }
 else       if (!fromTable.equals(newTableAlias)) {
        return root;
      }
    }
    assert(fromTable != null);
    for (    Index index : allIndexes) {
      if (!IndexType.isScannable(index.getType())) {
        continue;
      }
      boolean replacable=true;
      String exprsjson=index.getExpressionsjson();
      if (exprsjson.isEmpty()) {
        List<ColumnRef> indexedColRefs=CatalogUtil.getSortedCatalogItems(index.getColumns(),"index");
        if (groupBys.size() > indexedColRefs.size()) {
          continue;
        }
        for (int i=0; i < groupBys.size(); i++) {
          AbstractExpression expr=groupBys.get(i).expression;
          if (expr.getExpressionType() != ExpressionType.VALUE_TUPLE) {
            replacable=false;
            break;
          }
          if (!fromTable.equals(((TupleValueExpression)expr).getTableAlias())) {
            replacable=false;
            break;
          }
          boolean foundMatch=false;
          for (int j=0; j < groupBys.size(); j++) {
            if (indexedColRefs.get(j).getColumn().getName().equals(groupBys.get(i).columnName)) {
              foundMatch=true;
              break;
            }
          }
          if (!foundMatch) {
            replacable=false;
            break;
          }
        }
        if (replacable) {
          IndexScanPlanNode indexScanNode=new IndexScanPlanNode((SeqScanPlanNode)root,null,index,SortDirectionType.ASC);
          return indexScanNode;
        }
      }
 else {
        int idx=m_parsedSelect.tableAliasIndexMap.get(fromTable);
        StmtTableScan fromTableScan=m_parsedSelect.stmtCache.get(idx);
        List<AbstractExpression> indexedExprs=null;
        try {
          indexedExprs=AbstractExpression.fromJSONArrayString(exprsjson);
        }
 catch (        JSONException e) {
          e.printStackTrace();
          assert(false);
          return root;
        }
        if (groupBys.size() > indexedExprs.size()) {
          continue;
        }
        for (int i=0; i < groupBys.size(); i++) {
          boolean foundMatch=false;
          for (int j=0; j < groupBys.size(); j++) {
            AbstractExpression indexExpr=indexedExprs.get(j).replaceTVEsWithAlias(fromTableScan);
            if (groupBys.get(i).expression.bindingToIndexedExpression(indexExpr) != null) {
              foundMatch=true;
              break;
            }
          }
          if (!foundMatch) {
            replacable=false;
            break;
          }
        }
        if (replacable) {
          IndexScanPlanNode indexScanNode=new IndexScanPlanNode((SeqScanPlanNode)root,null,index,SortDirectionType.ASC);
          return indexScanNode;
        }
      }
    }
  }
  return root;
}
