{
  if (m_insertPlanWasGenerated)   return null;
  m_insertPlanWasGenerated=true;
  assert(m_parsedInsert.tableList.size() == 1);
  Table targetTable=m_parsedInsert.tableList.get(0);
  if (m_singlePartition && targetTable.getIsreplicated()) {
    String msg="Trying to insert into replicated table '" + targetTable.getTypeName() + "'";
    msg+=" in a single-partition procedure.";
    throw new PlanningErrorException(msg);
  }
  InsertPlanNode insertNode=new InsertPlanNode();
  insertNode.setTargetTableName(targetTable.getTypeName());
  insertNode.setMultiPartition(m_singlePartition == false);
  MaterializePlanNode materializeNode=new MaterializePlanNode();
  NodeSchema mat_schema=new NodeSchema();
  List<Column> columns=CatalogUtil.getSortedCatalogItems(targetTable.getColumns(),"index");
  for (  Column column : columns) {
    AbstractExpression expr=m_parsedInsert.columns.get(column);
    if (expr == null) {
      if (column.getNullable() == false && column.getDefaulttype() == 0) {
        throw new PlanningErrorException("Column " + column.getName() + " has no default and is not nullable.");
      }
      ConstantValueExpression const_expr=new ConstantValueExpression();
      expr=const_expr;
      if (column.getDefaulttype() != 0) {
        const_expr.setValue(column.getDefaultvalue());
        const_expr.setValueType(VoltType.get((byte)column.getDefaulttype()));
      }
 else {
        const_expr.setValue(null);
      }
    }
    if (expr.getValueType() == VoltType.NULL) {
      ConstantValueExpression const_expr=new ConstantValueExpression();
      const_expr.setValue("NULL");
    }
    try {
      ExpressionUtil.setOutputTypeForInsertExpression(expr,VoltType.get((byte)column.getType()),column.getSize(),m_paramTypeOverrideMap);
    }
 catch (    Exception e) {
      throw new PlanningErrorException(e.getMessage());
    }
    mat_schema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE",column.getTypeName(),column.getTypeName(),expr));
  }
  materializeNode.setOutputSchema(mat_schema);
  insertNode.addAndLinkChild(materializeNode);
  insertNode.generateOutputSchema(m_catalogDb);
  AbstractPlanNode rootNode=insertNode;
  if (m_singlePartition == false) {
    SendPlanNode sendNode=new SendPlanNode();
    sendNode.isMultiPartition=true;
    sendNode.addAndLinkChild(rootNode);
    sendNode.generateOutputSchema(m_catalogDb);
    ReceivePlanNode recvNode=new ReceivePlanNode();
    recvNode.addAndLinkChild(sendNode);
    recvNode.generateOutputSchema(m_catalogDb);
    rootNode=recvNode;
    rootNode=addSumAndSendToDMLNode(rootNode);
  }
  return rootNode;
}
