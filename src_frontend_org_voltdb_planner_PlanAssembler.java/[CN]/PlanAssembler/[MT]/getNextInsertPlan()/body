{
  if (m_bestAndOnlyPlanWasGenerated)   return null;
  m_bestAndOnlyPlanWasGenerated=true;
  assert(m_parsedInsert.m_tableList.size() == 1);
  Table targetTable=m_parsedInsert.m_tableList.get(0);
  for (  Column col : targetTable.getColumns()) {
    boolean needsValue=col.getNullable() == false && col.getDefaulttype() == 0;
    if (needsValue && !m_parsedInsert.columns.containsKey(col)) {
      throw new PlanningErrorException("Column " + col.getName() + " has no default and is not nullable.");
    }
  }
  InsertPlanNode insertNode=new InsertPlanNode();
  insertNode.setTargetTableName(targetTable.getTypeName());
  MaterializePlanNode matNode=new MaterializePlanNode();
  NodeSchema matSchema=new NodeSchema();
  int[] fieldMap=new int[m_parsedInsert.columns.size()];
  int i=0;
  for (  Map.Entry<Column,AbstractExpression> e : m_parsedInsert.columns.entrySet()) {
    Column col=e.getKey();
    AbstractExpression valExpr=e.getValue();
    fieldMap[i]=col.getIndex();
    valExpr=castExprIfNeeded(valExpr,col);
    matSchema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE","VOLT_TEMP_TABLE",col.getTypeName(),col.getTypeName(),valExpr));
    i++;
  }
  insertNode.setFieldMap(fieldMap);
  matNode.setOutputSchema(matSchema);
  insertNode.addAndLinkChild(matNode);
  if (m_partitioning.wasSpecifiedAsSingle() || m_partitioning.isInferredSingle()) {
    insertNode.setMultiPartition(false);
    return insertNode;
  }
  insertNode.setMultiPartition(true);
  AbstractPlanNode recvNode=SubPlanAssembler.addSendReceivePair(insertNode);
  return addSumOrLimitAndSendToDMLNode(recvNode,targetTable.getIsreplicated());
}
