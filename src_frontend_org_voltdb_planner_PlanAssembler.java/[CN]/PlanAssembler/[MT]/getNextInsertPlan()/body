{
  if (m_bestAndOnlyPlanWasGenerated)   return null;
  m_bestAndOnlyPlanWasGenerated=true;
  assert(m_parsedInsert.m_tableList.size() == 1);
  Table targetTable=m_parsedInsert.m_tableList.get(0);
  final boolean hasSubquery=(m_parsedInsert.getSubquery() != null);
  CompiledPlan retval=null;
  if (hasSubquery) {
    if (m_parsedInsert.getSubquery().getBestCostPlan() == null) {
      throw new PlanningErrorException("INSERT INTO ... SELECT subquery could not be planned: " + m_recentErrorMsg);
    }
    InsertSubPlanAssembler subPlanAssembler=new InsertSubPlanAssembler(m_catalogDb,m_parsedInsert,m_partitioning);
    AbstractPlanNode subplan=subPlanAssembler.nextPlan();
    if (subplan == null) {
      throw new PlanningErrorException(subPlanAssembler.m_recentErrorMsg);
    }
    assert(m_partitioning.isJoinValid());
    retval=m_parsedInsert.getSubquery().getBestCostPlan();
  }
 else {
    retval=new CompiledPlan();
  }
  retval.setReadOnly(false);
  CatalogMap<Column> targetTableColumns=targetTable.getColumns();
  for (  Column col : targetTableColumns) {
    boolean needsValue=col.getNullable() == false && col.getDefaulttype() == 0;
    if (needsValue && !m_parsedInsert.m_columns.containsKey(col)) {
      throw new PlanningErrorException("Column " + col.getName() + " has no default and is not nullable.");
    }
    if (col.equals(m_partitioning.getPartitionColForDML()) && !hasSubquery) {
      AbstractExpression expr=m_parsedInsert.getExpressionForPartitioning(col);
      String fullColumnName=targetTable.getTypeName() + "." + col.getTypeName();
      m_partitioning.addPartitioningExpression(fullColumnName,expr,expr.getValueType());
    }
  }
  NodeSchema matSchema=null;
  if (!hasSubquery) {
    matSchema=new NodeSchema();
  }
  int[] fieldMap=new int[m_parsedInsert.m_columns.size()];
  int i=0;
  for (  Map.Entry<Column,AbstractExpression> e : m_parsedInsert.m_columns.entrySet()) {
    Column col=e.getKey();
    fieldMap[i]=col.getIndex();
    if (matSchema != null) {
      AbstractExpression valExpr=e.getValue();
      valExpr.setInBytes(col.getInbytes());
      valExpr=castExprIfNeeded(valExpr,col);
      matSchema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE","VOLT_TEMP_TABLE",col.getTypeName(),col.getTypeName(),valExpr));
    }
    i++;
  }
  InsertPlanNode insertNode=new InsertPlanNode();
  insertNode.setTargetTableName(targetTable.getTypeName());
  insertNode.setFieldMap(fieldMap);
  if (matSchema != null) {
    MaterializePlanNode matNode=new MaterializePlanNode();
    matNode.setOutputSchema(matSchema);
    insertNode.addAndLinkChild(matNode);
    retval.statementGuaranteesDeterminism(false,true);
  }
 else {
    insertNode.addAndLinkChild(retval.rootPlanGraph);
  }
  if (m_partitioning.wasSpecifiedAsSingle() || m_partitioning.isInferredSingle()) {
    insertNode.setMultiPartition(false);
    retval.rootPlanGraph=insertNode;
    return retval;
  }
  insertNode.setMultiPartition(true);
  AbstractPlanNode recvNode=SubPlanAssembler.addSendReceivePair(insertNode);
  retval.rootPlanGraph=addSumOrLimitAndSendToDMLNode(recvNode,targetTable.getIsreplicated());
  return retval;
}
