{
  CompiledPlan retval=new CompiledPlan();
  AbstractParsedStmt nextStmt=null;
  if (m_parsedUnion != null) {
    nextStmt=m_parsedUnion;
    retval=getNextUnionPlan();
    if (retval != null) {
      retval.readOnly=true;
    }
  }
 else   if (m_parsedSelect != null) {
    nextStmt=m_parsedSelect;
    retval.rootPlanGraph=getNextSelectPlan();
    retval.readOnly=true;
    if (retval.rootPlanGraph != null) {
      addColumns(retval,m_parsedSelect);
      boolean orderIsDeterministic=m_parsedSelect.isOrderDeterministic();
      boolean contentIsDeterministic=(m_parsedSelect.hasLimitOrOffset() == false) || orderIsDeterministic;
      retval.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    }
  }
 else {
    retval.readOnly=false;
    if (m_parsedInsert != null) {
      nextStmt=m_parsedInsert;
      retval.rootPlanGraph=getNextInsertPlan();
    }
 else     if (m_parsedUpdate != null) {
      nextStmt=m_parsedUpdate;
      retval.rootPlanGraph=getNextUpdatePlan();
    }
 else     if (m_parsedDelete != null) {
      nextStmt=m_parsedDelete;
      retval.rootPlanGraph=getNextDeletePlan();
    }
 else {
      throw new RuntimeException("setupForNewPlans not called or not successfull.");
    }
    assert(nextStmt.tableList.size() == 1);
    if (nextStmt.tableList.get(0).getIsreplicated())     retval.replicatedTableDML=true;
    retval.statementGuaranteesDeterminism(true,true);
  }
  if (retval == null || retval.rootPlanGraph == null) {
    return null;
  }
  assert(nextStmt != null);
  retval.parameters=nextStmt.getParameters();
  retval.rootPlanGraph.generateOutputSchema(m_catalogDb);
  retval.setPartitioningKey(m_partitioning.effectivePartitioningValue());
  return retval;
}
