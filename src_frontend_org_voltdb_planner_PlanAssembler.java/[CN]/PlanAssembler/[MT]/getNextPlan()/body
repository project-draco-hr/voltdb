{
  CompiledPlan retval=new CompiledPlan();
  CompiledPlan.Fragment fragment=new CompiledPlan.Fragment();
  retval.fragments.add(fragment);
  AbstractParsedStmt nextStmt=null;
  if (m_parsedSelect != null) {
    nextStmt=m_parsedSelect;
    fragment.planGraph=getNextSelectPlan();
    if (fragment.planGraph != null) {
      addColumns(retval,m_parsedSelect);
      boolean orderIsDeterministic=m_parsedSelect.isOrderDeterministic();
      boolean contentIsDeterministic=(m_parsedSelect.hasLimitOrOffset() == false) || orderIsDeterministic;
      retval.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    }
  }
 else {
    if (m_parsedInsert != null) {
      nextStmt=m_parsedInsert;
      fragment.planGraph=getNextInsertPlan();
    }
 else     if (m_parsedUpdate != null) {
      nextStmt=m_parsedUpdate;
      fragment.planGraph=getNextUpdatePlan();
    }
 else     if (m_parsedDelete != null) {
      nextStmt=m_parsedDelete;
      fragment.planGraph=getNextDeletePlan();
    }
 else {
      throw new RuntimeException("setupForNewPlans not called or not successfull.");
    }
    assert(nextStmt.tableList.size() == 1);
    if (nextStmt.tableList.get(0).getIsreplicated())     retval.replicatedTableDML=true;
    retval.statementGuaranteesDeterminism(true,true);
  }
  if (fragment.planGraph == null) {
    return null;
  }
  assert(nextStmt != null);
  addParameters(retval,nextStmt);
  retval.fullWhereClause=nextStmt.where;
  retval.fullWinnerPlan=fragment.planGraph;
  fragment.planGraph.generateOutputSchema(m_catalogDb);
  retval.setPartitioningKey(m_partitioning.effectivePartitioningValue());
  return retval;
}
