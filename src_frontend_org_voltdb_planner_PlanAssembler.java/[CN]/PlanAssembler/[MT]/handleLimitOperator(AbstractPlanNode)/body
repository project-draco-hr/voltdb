{
  Stack<AbstractPlanNode> coordGraph=new Stack<AbstractPlanNode>();
  Stack<AbstractPlanNode> distGraph=new Stack<AbstractPlanNode>();
  int limitParamIndex=m_parsedSelect.getLimitParameterIndex();
  int offsetParamIndex=m_parsedSelect.getOffsetParameterIndex();
  LimitPlanNode topLimit=new LimitPlanNode();
  topLimit.setLimit((int)m_parsedSelect.limit);
  topLimit.setOffset((int)m_parsedSelect.offset);
  topLimit.setLimitParameterIndex(limitParamIndex);
  topLimit.setOffsetParameterIndex(offsetParamIndex);
  boolean canPushDown=true;
  if (m_parsedSelect.distinct || checkPushDownViability(root) == null) {
    canPushDown=false;
  }
  for (  ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.displayColumns) {
    AbstractExpression rootExpr=col.expression;
    if (rootExpr instanceof AggregateExpression) {
      if (((AggregateExpression)rootExpr).m_distinct) {
        canPushDown=false;
        break;
      }
    }
  }
  if ((canPushDown == false) || (root.hasAnyNodeOfType(PlanNodeType.RECEIVE) == false)) {
    distGraph.push(topLimit);
  }
 else {
    coordGraph.push(topLimit);
    LimitPlanNode distLimit=new LimitPlanNode();
    if (m_parsedSelect.limit != -1) {
      distLimit.setLimit((int)(m_parsedSelect.limit + m_parsedSelect.offset));
    }
    if (m_parsedSelect.hasLimitOrOffsetParameters()) {
      AbstractExpression left=m_parsedSelect.getOffsetExpression();
      assert(left != null);
      AbstractExpression right=m_parsedSelect.getLimitExpression();
      assert(right != null);
      OperatorExpression expr=new OperatorExpression(ExpressionType.OPERATOR_PLUS,left,right);
      expr.setValueType(VoltType.INTEGER);
      expr.setValueSize(VoltType.INTEGER.getLengthInBytesForFixedTypes());
      distLimit.setLimitExpression(expr);
    }
    distGraph.push(distLimit);
  }
  return pushDownLimit(root,distGraph,coordGraph);
}
