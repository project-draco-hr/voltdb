{
  List<StmtSubqueryScan> subqueryNodes=parsedStmt.getSubqueryScans();
  ParsedResultAccumulator fromSubqueryResult=null;
  if (!subqueryNodes.isEmpty()) {
    fromSubqueryResult=getBestCostPlanForFromSubQueries(subqueryNodes);
    if (fromSubqueryResult == null) {
      return null;
    }
  }
  List<AbstractExpression> subqueryExprs=parsedStmt.findAllSubexpressionsOfClass(SelectSubqueryExpression.class);
  if (!subqueryExprs.isEmpty()) {
    if (parsedStmt instanceof ParsedSelectStmt == false) {
      m_recentErrorMsg="Subquery expressions are only supported in SELECT statements";
      return null;
    }
    if (!getBestCostPlanForExpressionSubQueries(subqueryExprs)) {
      return null;
    }
  }
  setupForNewPlans(parsedStmt);
  CompiledPlan rawplan=null;
  while (true) {
    rawplan=getNextPlan();
    if (rawplan == null)     break;
    m_planSelector.considerCandidatePlan(rawplan,parsedStmt);
  }
  CompiledPlan retval=m_planSelector.m_bestPlan;
  if (retval == null) {
    return null;
  }
  if (fromSubqueryResult != null) {
    boolean orderIsDeterministic=retval.isOrderDeterministic();
    if (orderIsDeterministic && !fromSubqueryResult.m_orderIsDeterministic) {
      orderIsDeterministic=parsedStmt.isOrderDeterministicInSpiteOfUnorderedSubqueries();
    }
    boolean hasLimitOrOffset=fromSubqueryResult.m_hasLimitOrOffset || retval.hasLimitOrOffset();
    retval.statementGuaranteesDeterminism(hasLimitOrOffset,orderIsDeterministic);
    retval.rootPlanGraph=connectChildrenBestPlans(retval.rootPlanGraph);
  }
  failIfNonDeterministicDml(parsedStmt,retval);
  if (m_partitioning != null) {
    retval.setStatementPartitioning(m_partitioning);
  }
  return retval;
}
