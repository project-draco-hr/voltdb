{
  int countOfPartitionedTables=0;
  Map<String,String> partitionColumnByTable=new HashMap<String,String>();
  for (  Table table : parsedStmt.tableList) {
    if (table.getIsreplicated()) {
      continue;
    }
    ++countOfPartitionedTables;
    String colName=null;
    Column partitionCol=table.getPartitioncolumn();
    if (partitionCol != null) {
      colName=partitionCol.getTypeName();
    }
    String partitionedTable=table.getTypeName();
    partitionColumnByTable.put(partitionedTable,colName);
  }
  m_partitioning.setPartitionedTables(partitionColumnByTable,countOfPartitionedTables);
  if ((m_partitioning.wasSpecifiedAsSingle() == false) && m_partitioning.getCountOfPartitionedTables() > 0) {
    m_partitioning.analyzeForMultiPartitionAccess(parsedStmt.tableList,parsedStmt.valueEquivalence);
    int multiPartitionScanCount=m_partitioning.getCountOfIndependentlyPartitionedTables();
    if (multiPartitionScanCount > 1) {
      String msg="Join or union of multiple partitioned tables has insufficient join criteria.";
      throw new PlanningErrorException(msg);
    }
  }
}
