{
  assert(root.getPlanNodeType() == PlanNodeType.SEQSCAN);
  String fromTableAlias=null;
  ArrayList<ParsedColInfo> groupBys=m_parsedSelect.m_groupByColumns;
  for (  ParsedColInfo col : groupBys) {
    List<AbstractExpression> baseTVEs=col.expression.findBaseTVEs();
    for (    AbstractExpression baseTVE : baseTVEs) {
      String nextTableAlias=((TupleValueExpression)baseTVE).getTableAlias();
      assert(nextTableAlias != null);
      if (fromTableAlias == null) {
        fromTableAlias=nextTableAlias;
      }
 else       if (!fromTableAlias.equals(nextTableAlias)) {
        return root;
      }
    }
  }
  assert(fromTableAlias != null);
  Table targetTable=m_catalogDb.getTables().get(((SeqScanPlanNode)root).getTargetTableName());
  if (targetTable == null) {
    return root;
  }
  assert(targetTable != null);
  CatalogMap<Index> allIndexes=targetTable.getIndexes();
  List<Integer> maxCoveredGroupByColumns=new ArrayList<>();
  ArrayList<AbstractExpression> allBindings=new ArrayList<AbstractExpression>();
  Index pickedupInde=null;
  boolean foundAllGroupByCoveredIndex=false;
  for (  Index index : allIndexes) {
    if (!IndexType.isScannable(index.getType()) || foundAllGroupByCoveredIndex) {
      continue;
    }
    List<Integer> coveredGroupByColumns=new ArrayList<>();
    processGroupbyColumnsCovered(index,fromTableAlias,coveredGroupByColumns,allBindings);
    if (coveredGroupByColumns.size() > maxCoveredGroupByColumns.size()) {
      maxCoveredGroupByColumns=coveredGroupByColumns;
      pickedupInde=index;
      if (maxCoveredGroupByColumns.size() == groupBys.size()) {
        foundAllGroupByCoveredIndex=true;
        break;
      }
    }
  }
  if (pickedupInde == null) {
    return root;
  }
  IndexScanPlanNode indexScanNode=new IndexScanPlanNode((SeqScanPlanNode)root,null,pickedupInde,SortDirectionType.INVALID);
  indexScanNode.setForGroupingOnly();
  indexScanNode.setBindings(allBindings);
  gbInfo.m_coveredGroupByColumns=maxCoveredGroupByColumns;
  gbInfo.m_serialAgg=foundAllGroupByCoveredIndex;
  return indexScanNode;
}
