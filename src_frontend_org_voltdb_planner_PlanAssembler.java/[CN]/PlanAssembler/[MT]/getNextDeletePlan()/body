{
  assert(subAssembler != null);
  assert(m_parsedDelete.m_tableList.size() == 1);
  Table targetTable=m_parsedDelete.m_tableList.get(0);
  AbstractPlanNode subSelectRoot=subAssembler.nextPlan();
  if (subSelectRoot == null) {
    return null;
  }
  if (disableNestedLoopIndexJoinForInComparison(subSelectRoot,m_parsedDelete)) {
    return getNextDeletePlan();
  }
  DeletePlanNode deleteNode=new DeletePlanNode();
  deleteNode.setTargetTableName(targetTable.getTypeName());
  ProjectionPlanNode projectionNode=new ProjectionPlanNode();
  AbstractExpression addressExpr=new TupleAddressExpression();
  NodeSchema proj_schema=new NodeSchema();
  proj_schema.addColumn(new SchemaColumn("VOLT_TEMP_TABLE","VOLT_TEMP_TABLE","tuple_address","tuple_address",addressExpr));
  projectionNode.setOutputSchema(proj_schema);
  assert(subSelectRoot instanceof AbstractScanPlanNode);
  if ((subSelectRoot instanceof SeqScanPlanNode) && (((SeqScanPlanNode)subSelectRoot).getPredicate() == null)) {
    deleteNode.setTruncate(true);
    if (m_partitioning.wasSpecifiedAsSingle()) {
      return deleteNode;
    }
  }
 else {
    if (m_parsedDelete.hasOrderByColumns()) {
      subSelectRoot=handleOrderBy(m_parsedDelete,subSelectRoot);
    }
    deleteNode.addAndLinkChild(subSelectRoot);
    subSelectRoot.addInlinePlanNode(projectionNode);
  }
  if (m_partitioning.wasSpecifiedAsSingle() || m_partitioning.isInferredSingle()) {
    return deleteNode;
  }
  AbstractPlanNode recvNode=SubPlanAssembler.addSendReceivePair(deleteNode);
  return addSumOrLimitAndSendToDMLNode(recvNode,targetTable.getIsreplicated());
}
