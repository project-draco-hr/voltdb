{
  CompiledPlan retval=new CompiledPlan();
  m_recentErrorMsg=null;
  ArrayList<CompiledPlan> childrenPlans=new ArrayList<CompiledPlan>();
  boolean orderIsDeterministic=true;
  boolean contentIsDeterministic=true;
  boolean isPlanFinal=false;
  ArrayList<PartitioningForStatement> partitioningList=new ArrayList<PartitioningForStatement>();
  for (  AbstractParsedStmt parsedChildStmt : m_parsedUnion.m_children) {
    PartitioningForStatement partitioning=new PartitioningForStatement(null,false,true);
    CompiledPlan bestChildPlan=getBestCostPlan(parsedChildStmt,planProcessor,partitioning,isPlanFinal);
    if (bestChildPlan == null) {
      if (m_recentErrorMsg == null) {
        m_recentErrorMsg="Unable to plan for statement. Error unknown.";
      }
      return null;
    }
    childrenPlans.add(bestChildPlan);
    orderIsDeterministic=orderIsDeterministic && bestChildPlan.isOrderDeterministic();
    contentIsDeterministic=contentIsDeterministic && bestChildPlan.isContentDeterministic();
    partitioningList.add(partitioning);
  }
  boolean hasPrtitionedTable=false;
  for (  PartitioningForStatement partition : partitioningList) {
    if (partition.getCountOfIndependentlyPartitionedTables() > 0)     if (!hasPrtitionedTable) {
      hasPrtitionedTable=true;
    }
 else {
      m_recentErrorMsg="Unable to plan for statement. More than one partitioned table in the union.";
      return null;
    }
  }
  AbstractPlanNode root=new UnionPlanNode(m_parsedUnion.m_unionType);
  for (  CompiledPlan selectPlan : childrenPlans) {
    root.addAndLinkChild(selectPlan.rootPlanGraph);
  }
  SendPlanNode sendNode=new SendPlanNode();
  sendNode.addAndLinkChild(root);
  sendNode.generateOutputSchema(m_catalogDb);
  retval.rootPlanGraph=sendNode;
  retval.readOnly=true;
  retval.sql=planProcessor.m_sql;
  retval.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
  retval.cost=0.0;
  for (  CompiledPlan bestChildPlan : childrenPlans) {
    retval.cost+=bestChildPlan.cost;
  }
  return retval;
}
