{
  int countOfPartitionedTables=0;
  Map<String,String> partitionColumnByTable=new HashMap<String,String>();
  for (  Table table : parsedStmt.tableList) {
    Table viewTable=null;
    Table baseTable=table.getMaterializer();
    while (baseTable != null) {
      if (viewTable == null) {
        viewTable=table;
      }
      table=baseTable;
      baseTable=table.getMaterializer();
    }
    if (table.getIsreplicated()) {
      continue;
    }
    ++countOfPartitionedTables;
    String colName=null;
    Column partitionCol=table.getPartitioncolumn();
    if ((partitionCol != null) && (viewTable == null)) {
      colName=partitionCol.getTypeName();
    }
    if (viewTable != null) {
      table=viewTable;
    }
    String partitionedTable=table.getTypeName();
    partitionColumnByTable.put(partitionedTable,colName);
  }
  m_partitioning.setPartitionedTables(partitionColumnByTable,countOfPartitionedTables);
  if ((m_partitioning.wasSpecifiedAsSingle() == false) && m_partitioning.getCountOfPartitionedTables() > 0) {
    m_partitioning.analyzeForMultiPartitionAccess(parsedStmt.tableList,parsedStmt.valueEquivalence);
    int multiPartitionScanCount=m_partitioning.getCountOfIndependentlyPartitionedTables();
    if (multiPartitionScanCount > 1) {
      String msg="Join of multiple partitioned tables has insufficient join criteria.";
      throw new PlanningErrorException(msg);
    }
  }
  if (parsedStmt instanceof ParsedSelectStmt) {
    if (tableListIncludesExportOnly(parsedStmt.tableList)) {
      throw new RuntimeException("Illegal to read an export table.");
    }
    m_parsedSelect=(ParsedSelectStmt)parsedStmt;
    subAssembler=new SelectSubPlanAssembler(m_catalogDb,parsedStmt,m_partitioning);
  }
 else {
    if (tableListIncludesView(parsedStmt.tableList)) {
      throw new RuntimeException("Illegal to modify a materialized view.");
    }
    assert(parsedStmt.tableList.size() == 1);
    Table targetTable=parsedStmt.tableList.get(0);
    if (targetTable.getIsreplicated()) {
      if (m_partitioning.wasSpecifiedAsSingle()) {
        String msg="Trying to write to replicated table '" + targetTable.getTypeName() + "' in a single-partition procedure.";
        throw new PlanningErrorException(msg);
      }
    }
 else     if (m_partitioning.wasSpecifiedAsSingle() == false) {
      m_partitioning.setPartitioningColumn(targetTable.getPartitioncolumn());
    }
    if (parsedStmt instanceof ParsedInsertStmt) {
      m_parsedInsert=(ParsedInsertStmt)parsedStmt;
      return;
    }
    if (parsedStmt instanceof ParsedUpdateStmt) {
      if (tableListIncludesExportOnly(parsedStmt.tableList)) {
        throw new RuntimeException("Illegal to update an export table.");
      }
      m_parsedUpdate=(ParsedUpdateStmt)parsedStmt;
    }
 else     if (parsedStmt instanceof ParsedDeleteStmt) {
      if (tableListIncludesExportOnly(parsedStmt.tableList)) {
        throw new RuntimeException("Illegal to delete from an export table.");
      }
      m_parsedDelete=(ParsedDeleteStmt)parsedStmt;
    }
 else {
      throw new RuntimeException("Unknown subclass of AbstractParsedStmt.");
    }
    subAssembler=new WriterSubPlanAssembler(m_catalogDb,parsedStmt,m_partitioning);
  }
}
