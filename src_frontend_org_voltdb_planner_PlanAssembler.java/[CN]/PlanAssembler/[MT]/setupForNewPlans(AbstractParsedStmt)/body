{
  m_bestAndOnlyPlanWasGenerated=false;
  m_partitioning.analyzeTablePartitioning(parsedStmt.stmtCache);
  if (parsedStmt instanceof ParsedUnionStmt) {
    m_parsedUnion=(ParsedUnionStmt)parsedStmt;
    return;
  }
  if (parsedStmt instanceof ParsedSelectStmt) {
    if (tableListIncludesExportOnly(parsedStmt.tableList)) {
      throw new RuntimeException("Illegal to read an export table.");
    }
    m_parsedSelect=(ParsedSelectStmt)parsedStmt;
    subAssembler=new SelectSubPlanAssembler(m_catalogDb,parsedStmt,m_partitioning);
    return;
  }
 else {
    if (tableListIncludesView(parsedStmt.tableList)) {
      throw new RuntimeException("Illegal to modify a materialized view.");
    }
    assert(parsedStmt.tableList.size() == 1);
    Table targetTable=parsedStmt.tableList.get(0);
    if (targetTable.getIsreplicated()) {
      if (m_partitioning.wasSpecifiedAsSingle()) {
        String msg="Trying to write to replicated table '" + targetTable.getTypeName() + "' in a single-partition procedure.";
        throw new PlanningErrorException(msg);
      }
    }
 else     if (m_partitioning.wasSpecifiedAsSingle() == false) {
      m_partitioning.setPartitioningColumn(targetTable.getPartitioncolumn());
    }
    if (parsedStmt instanceof ParsedInsertStmt) {
      m_parsedInsert=(ParsedInsertStmt)parsedStmt;
      return;
    }
    if (parsedStmt instanceof ParsedUpdateStmt) {
      if (tableListIncludesExportOnly(parsedStmt.tableList)) {
        throw new RuntimeException("Illegal to update an export table.");
      }
      m_parsedUpdate=(ParsedUpdateStmt)parsedStmt;
    }
 else     if (parsedStmt instanceof ParsedDeleteStmt) {
      if (tableListIncludesExportOnly(parsedStmt.tableList)) {
        throw new RuntimeException("Illegal to delete from an export table.");
      }
      m_parsedDelete=(ParsedDeleteStmt)parsedStmt;
    }
 else {
      throw new RuntimeException("Unknown subclass of AbstractParsedStmt.");
    }
    if (!m_partitioning.wasSpecifiedAsSingle()) {
      HashMap<AbstractExpression,Set<AbstractExpression>> valueEquivalence=parsedStmt.analyzeValueEquivalence();
      m_partitioning.analyzeForMultiPartitionAccess(parsedStmt.stmtCache,valueEquivalence);
    }
    subAssembler=new WriterSubPlanAssembler(m_catalogDb,parsedStmt,m_partitioning);
  }
}
