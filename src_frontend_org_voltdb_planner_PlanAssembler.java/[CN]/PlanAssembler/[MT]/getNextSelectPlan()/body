{
  assert(subAssembler != null);
  Map<String,AbstractParsedStmt> childrenStmt=m_parsedSelect.extractAndRemoveSubQueries();
  if (childrenStmt.isEmpty()) {
    CompiledPlan retval=new CompiledPlan();
    retval.rootPlanGraph=getNextSubSelectPlan();
    retval.readOnly=true;
    if (retval.rootPlanGraph != null) {
      retval.selectStmt=m_parsedSelect;
      boolean orderIsDeterministic=m_parsedSelect.isOrderDeterministic();
      boolean contentIsDeterministic=(m_parsedSelect.hasLimitOrOffset() == false) || orderIsDeterministic;
      retval.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    }
    return retval;
  }
 else {
    Map<String,CompiledPlan> childrenPlans=new HashMap<String,CompiledPlan>();
    boolean orderIsDeterministic=true;
    boolean contentIsDeterministic=true;
    int planId=0;
    for (    Map.Entry<String,AbstractParsedStmt> parsedChildStmtEntry : childrenStmt.entrySet()) {
      AbstractParsedStmt parsedChildStmt=parsedChildStmtEntry.getValue();
      PartitioningForStatement partitioning=(PartitioningForStatement)m_partitioning.clone();
      PlanSelector processor=(PlanSelector)m_planSelector.clone();
      processor.m_planId=planId;
      PlanAssembler assembler=new PlanAssembler(m_catalogCluster,m_catalogDb,partitioning,processor);
      CompiledPlan bestChildPlan=assembler.getBestCostPlan(parsedChildStmt);
      if (bestChildPlan == null) {
        if (m_recentErrorMsg == null) {
          m_recentErrorMsg="Unable to plan for statement. Error unknown.";
        }
        return null;
      }
      childrenPlans.put(parsedChildStmtEntry.getKey(),bestChildPlan);
      orderIsDeterministic=orderIsDeterministic && bestChildPlan.isOrderDeterministic();
      contentIsDeterministic=contentIsDeterministic && bestChildPlan.isContentDeterministic();
      planId=processor.m_planId;
    }
    CompiledPlan parentPlan=getBestCostPlan(m_parsedSelect);
    orderIsDeterministic=orderIsDeterministic && parentPlan.isOrderDeterministic();
    contentIsDeterministic=contentIsDeterministic && parentPlan.isContentDeterministic();
    parentPlan.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    parentPlan.readOnly=true;
    parentPlan.sql=m_planSelector.m_sql;
    return connectSubQueriesPlans(parentPlan,childrenPlans);
  }
}
