{
  assert(subAssembler != null);
  AbstractPlanNode subSelectRoot=subAssembler.nextPlan();
  if (subSelectRoot == null) {
    m_recentErrorMsg=subAssembler.m_recentErrorMsg;
    return null;
  }
  AbstractPlanNode root=subSelectRoot;
  if (m_partitioning.requiresTwoFragments()) {
    ArrayList<AbstractPlanNode> receivers=root.findAllNodesOfType(PlanNodeType.RECEIVE);
    if (receivers.size() == 1) {
      HashSet<String> tablesRead=new HashSet<String>();
      root.getTablesReadByFragment(tablesRead);
      for (      String tableName : tablesRead) {
        Table table=m_parsedSelect.getTableFromDB(tableName);
        if (!table.getIsreplicated()) {
          throw new PlanningErrorException("This special case join between an outer replicated table and " + "an inner partitioned table is too complex and is not supported.");
        }
      }
    }
 else     if (receivers.size() > 0) {
      throw new PlanningErrorException("This special case join between an outer replicated table and " + "an inner partitioned table is too complex and is not supported.");
    }
 else {
      root=subAssembler.addSendReceivePair(root);
      assert(root instanceof ReceivePlanNode);
      if (m_parsedSelect.mayNeedAvgPushdown()) {
        m_parsedSelect.switchOptimalSuiteForAvgPushdown();
      }
      if (m_parsedSelect.tableList.size() > 1 && m_parsedSelect.mvFixInfo.needed() && subSelectRoot.hasInlinedIndexScanOfTable(m_parsedSelect.mvFixInfo.getMVTableName())) {
        return getNextSelectPlan();
      }
    }
  }
  boolean mvFixInfoCoordinatorNeeded=true;
  boolean mvFixInfoEdgeCaseOuterJoin=false;
  if (root instanceof ReceivePlanNode == false) {
    if (m_parsedSelect.mvFixInfo.needed()) {
      List<AbstractPlanNode> recList=root.findAllNodesOfType(PlanNodeType.RECEIVE);
      if (recList.size() == 1) {
        mvFixInfoCoordinatorNeeded=false;
        AbstractPlanNode receiveNode=recList.get(0);
        if (receiveNode.getParent(0) instanceof NestLoopPlanNode) {
          if (subSelectRoot.hasInlinedIndexScanOfTable(m_parsedSelect.mvFixInfo.getMVTableName())) {
            return getNextSelectPlan();
          }
          List<AbstractPlanNode> nljs=receiveNode.findAllNodesOfType(PlanNodeType.NESTLOOP);
          List<AbstractPlanNode> nlijs=receiveNode.findAllNodesOfType(PlanNodeType.NESTLOOPINDEX);
          if (nljs.size() + nlijs.size() == 0) {
            mvFixInfoEdgeCaseOuterJoin=true;
          }
          root=handleMVBasedMultiPartQuery(root,mvFixInfoEdgeCaseOuterJoin);
        }
      }
 else {
        m_parsedSelect.mvFixInfo.setNeeded(false);
      }
    }
  }
  root=handleAggregationOperators(root);
  boolean mvFixNeedsProjection=false;
  if (m_parsedSelect.mvFixInfo.needed() && mvFixInfoCoordinatorNeeded) {
    AbstractPlanNode tmpRoot=root;
    root=handleMVBasedMultiPartQuery(root,mvFixInfoEdgeCaseOuterJoin);
    if (root != tmpRoot) {
      mvFixNeedsProjection=true;
    }
  }
  if (m_parsedSelect.hasComplexAgg()) {
    AbstractPlanNode aggNode=root.getChild(0);
    root.clearChildren();
    aggNode.clearParents();
    aggNode=handleOrderBy(aggNode);
    root.addAndLinkChild(aggNode);
  }
 else {
    root=handleOrderBy(root);
  }
  if (mvFixNeedsProjection || needProjectionNode(root)) {
    root=addProjection(root);
  }
  if (m_parsedSelect.hasLimitOrOffset()) {
    root=handleLimitOperator(root);
  }
  return root;
}
