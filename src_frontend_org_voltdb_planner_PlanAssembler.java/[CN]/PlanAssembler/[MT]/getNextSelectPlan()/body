{
  assert(subAssembler != null);
  AbstractPlanNode subSelectRoot=subAssembler.nextPlan();
  if (subSelectRoot == null)   return null;
  AbstractPlanNode root=subSelectRoot;
  root.generateOutputSchema(m_catalogDb);
  root=handleAggregationOperators(root);
  if ((subSelectRoot.getPlanNodeType() != PlanNodeType.INDEXSCAN || ((IndexScanPlanNode)subSelectRoot).getSortDirection() == SortDirectionType.INVALID) && m_parsedSelect.orderColumns.size() > 0) {
    root=addOrderBy(root);
  }
  if ((root.getPlanNodeType() != PlanNodeType.AGGREGATE) && (root.getPlanNodeType() != PlanNodeType.HASHAGGREGATE) && (root.getPlanNodeType() != PlanNodeType.DISTINCT)&& (root.getPlanNodeType() != PlanNodeType.PROJECTION)) {
    root=addProjection(root);
  }
  if ((m_parsedSelect.limit != -1) || (m_parsedSelect.limitParameterId != -1) || (m_parsedSelect.offset > 0)|| (m_parsedSelect.offsetParameterId != -1)) {
    LimitPlanNode limit=new LimitPlanNode();
    limit.setLimit((int)m_parsedSelect.limit);
    limit.setOffset((int)m_parsedSelect.offset);
    if (m_parsedSelect.offsetParameterId != -1) {
      ParameterInfo parameterInfo=m_parsedSelect.paramsById.get(m_parsedSelect.offsetParameterId);
      limit.setOffsetParameterIndex(parameterInfo.index);
    }
    if (m_parsedSelect.limitParameterId != -1) {
      ParameterInfo parameterInfo=m_parsedSelect.paramsById.get(m_parsedSelect.limitParameterId);
      limit.setLimitParameterIndex(parameterInfo.index);
    }
    limit.addAndLinkChild(root);
    limit.generateOutputSchema(m_catalogDb);
    root=limit;
  }
  SendPlanNode sendNode=new SendPlanNode();
  sendNode.addAndLinkChild(root);
  sendNode.generateOutputSchema(m_catalogDb);
  return sendNode;
}
