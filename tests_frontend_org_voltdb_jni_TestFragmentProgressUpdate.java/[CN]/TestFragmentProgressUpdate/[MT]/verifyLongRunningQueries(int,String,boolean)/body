{
  m_ee.loadCatalog(0,m_catalog.serialize());
  m_itemData.clearRowData();
  for (int i=0; i < m_tableSize; ++i) {
    m_itemData.addRow(i,i + 50,"item" + i,(double)i / 2,"data" + i);
  }
  m_ee.loadTable(ITEM_TABLEID,m_itemData,0,0,0,false,false,WRITE_TOKEN);
  assertEquals(m_tableSize,m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  System.out.println("Rows loaded to table " + m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  Statement selectStmt=m_testProc.getStatements().getIgnoreCase(query);
  int fragSize=selectStmt.getFragments().size();
  PlanFragment frag=selectStmt.getFragments().iterator().next();
  if (fragSize == 2) {
    int j=0;
    for (    PlanFragment f : selectStmt.getFragments()) {
      if (j != 0)       frag=f;
      j++;
    }
  }
  ActivePlanRepository.clear();
  ActivePlanRepository.addFragmentForTest(CatalogUtil.getUniqueIdForFragment(frag),Encoder.decodeBase64AndDecompressToBytes(frag.getPlannodetree()),selectStmt.getSqltext());
  ParameterSet params=ParameterSet.emptyParameterSet();
  VoltLogger mockedLogger=Mockito.mock(VoltLogger.class);
  ExecutionEngine.setVoltLoggerForTest(mockedLogger);
  m_ee.setTimeoutLatency(timeout);
  try {
    m_ee.executePlanFragments(1,new long[]{CatalogUtil.getUniqueIdForFragment(frag)},null,new ParameterSet[]{params},new String[]{selectStmt.getSqltext()},3,3,2,42,readOnly ? READ_ONLY_TOKEN : WRITE_TOKEN);
    if (readOnly && timeout > 0) {
      fail();
    }
  }
 catch (  Exception ex) {
    String msg=String.format("A SQL query was interrupted after %.2f seconds " + "because it exceeded the query timeout period.",timeout / 1000.0);
    System.err.println(msg);
    assertEquals(msg,ex.getMessage());
  }
  verify(mockedLogger,atLeastOnce()).info(contains(String.format("Executing SQL statement is \"%s\".",selectStmt.getSqltext())));
}
