{
  m_tableSize=scale;
  m_ee.loadCatalog(0,m_catalog.serialize());
  m_itemData.clearRowData();
  for (int i=0; i < m_tableSize; ++i) {
    m_itemData.addRow(i,i + 50,"item" + i,(double)i / 2,"data" + i);
  }
  m_ee.loadTable(ITEM_TABLEID,m_itemData,0,0,0,false,false,WRITE_TOKEN);
  assertEquals(m_tableSize,m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  System.out.println("Rows loaded to table " + m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  Statement queryStmt=m_testProc.getStatements().getIgnoreCase(query);
  String sqlText=queryStmt.getSqltext();
  PlanFragment frag=null;
  for (  PlanFragment f : queryStmt.getFragments()) {
    frag=f;
  }
  ActivePlanRepository.clear();
  ActivePlanRepository.addFragmentForTest(CatalogUtil.getUniqueIdForFragment(frag),Encoder.decodeBase64AndDecompressToBytes(frag.getPlannodetree()),sqlText);
  ParameterSet params=ParameterSet.emptyParameterSet();
  VoltLogger mockedLogger=Mockito.mock(VoltLogger.class);
  ExecutionEngine.setVoltLoggerForTest(mockedLogger);
  m_ee.setTimeoutLatency(timeout);
  try {
    String[] sqlTexts;
switch (sqlTextExpectation) {
case SQL_STATEMENT:
      sqlTexts=new String[]{sqlText};
    break;
case NO_STATEMENT:
  sqlTexts=null;
break;
default :
assert(sqlTextExpectation == SqlTextExpectation.STATEMENT_LIST);
sqlTexts=new String[]{};
}
m_ee.executePlanFragments(1,new long[]{CatalogUtil.getUniqueIdForFragment(frag)},null,new ParameterSet[]{params},sqlTexts,3,3,2,42,readOnly ? READ_ONLY_TOKEN : WRITE_TOKEN);
if (readOnly && timeout > 0) {
fail();
}
}
 catch (Exception ex) {
String msg=String.format("A SQL query was terminated after %.2f seconds " + "because it exceeded the query timeout period.",timeout / 1000.0);
assertEquals(msg,ex.getMessage());
}
String expectedSqlTextMsg;
switch (sqlTextExpectation) {
case SQL_STATEMENT:
expectedSqlTextMsg=String.format("Executing SQL statement is \"%s\".",sqlText);
break;
case NO_STATEMENT:
expectedSqlTextMsg="SQL statement text is not available.";
break;
default :
assert(sqlTextExpectation == SqlTextExpectation.STATEMENT_LIST);
expectedSqlTextMsg="Unable to report specific SQL statement text for batch index";
}
verify(mockedLogger,atLeastOnce()).info(contains(expectedSqlTextMsg));
}
