{
  m_ee.loadCatalog(0,m_catalog.serialize());
  m_tableSize=500;
  int timeout=1000 * 10;
  m_itemData.clearRowData();
  for (int i=0; i < m_tableSize; ++i) {
    m_itemData.addRow(i,i + 50,"item" + i,(double)i / 2,"data" + i);
  }
  m_ee.loadTable(ITEM_TABLEID,m_itemData,0,0,0,false,false,Long.MAX_VALUE);
  assertEquals(m_tableSize,m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  System.out.println("Rows loaded to table " + m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  Statement selectStmt=m_testProc.getStatements().getIgnoreCase("item_crazy_join");
  assertEquals(1,selectStmt.getFragments().size());
  PlanFragment frag=selectStmt.getFragments().iterator().next();
  ActivePlanRepository.clear();
  ActivePlanRepository.addFragmentForTest(CatalogUtil.getUniqueIdForFragment(frag),Encoder.decodeBase64AndDecompressToBytes(frag.getPlannodetree()),selectStmt.getSqltext());
  ParameterSet params=ParameterSet.emptyParameterSet();
  VoltLogger mockedLogger=Mockito.mock(VoltLogger.class);
  ExecutionEngine.setVoltLoggerForTest(mockedLogger);
  m_ee.setTimeoutLatency(timeout);
  try {
    m_ee.executePlanFragments(1,new long[]{CatalogUtil.getUniqueIdForFragment(frag)},null,new ParameterSet[]{params},new String[]{selectStmt.getSqltext()},3,3,2,42,Long.MAX_VALUE);
    fail();
  }
 catch (  Exception ex) {
    String msg=String.format("Query/Procedure timing out in %.2f seconds.",timeout / 1000.0);
    assertEquals(msg,ex.getMessage());
  }
  verify(mockedLogger,atLeastOnce()).info(contains("Executing SQL statement is \"SELECT COUNT(*) FROM ITEM i1, ITEM i2, ITEM i3;\"."));
}
