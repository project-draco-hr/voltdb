{
  m_tableSize=scale;
  m_ee.loadCatalog(0,m_catalog.serialize());
  m_itemData.clearRowData();
  for (int i=0; i < m_tableSize; ++i) {
    m_itemData.addRow(i,i + 50,"item" + i,(double)i / 2,"data" + i);
  }
  m_ee.loadTable(ITEM_TABLEID,m_itemData,0,0,0,false,false,WRITE_TOKEN);
  assertEquals(m_tableSize,m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  System.out.println("Rows loaded to table " + m_ee.serializeTable(ITEM_TABLEID).getRowCount());
  Statement queryStmt=m_testProc.getStatements().getIgnoreCase(query);
  String sqlText=queryStmt.getSqltext();
  PlanFragment frag=null;
  for (  PlanFragment f : queryStmt.getFragments()) {
    frag=f;
  }
  ActivePlanRepository.clear();
  ActivePlanRepository.addFragmentForTest(CatalogUtil.getUniqueIdForFragment(frag),Encoder.decodeBase64AndDecompressToBytes(frag.getPlannodetree()),sqlText);
  ParameterSet params=ParameterSet.emptyParameterSet();
  VoltLogger mockedLogger=Mockito.mock(VoltLogger.class);
  ExecutionEngine.setVoltLoggerForTest(mockedLogger);
  m_ee.setTimeoutLatency(timeout);
  try {
    m_ee.executePlanFragments(1,new long[]{CatalogUtil.getUniqueIdForFragment(frag)},null,new ParameterSet[]{params},new String[]{sqlText},3,3,2,42,readOnly ? READ_ONLY_TOKEN : WRITE_TOKEN);
    if (readOnly && timeout > 0) {
      fail();
    }
  }
 catch (  Exception ex) {
    String msg=String.format("A SQL query was terminated after %.2f seconds " + "because it exceeded the query timeout period.",timeout / 1000.0);
    assertEquals(msg,ex.getMessage());
  }
  verify(mockedLogger,atLeastOnce()).info(contains(String.format("Executing SQL statement is \"%s\".",sqlText)));
}
