def RealMain(argv, data=None):
    'The real main function.\n\n  Args:\n    argv: Command line arguments.\n    data: Diff contents. If None (default) the diff is generated by\n      the VersionControlSystem implementation returned by GuessVCS().\n\n  Returns:\n    A 2-tuple (issue id, patchset id).\n    The patchset id is None if the base files are not uploaded by this\n    script (applies only to SVN checkouts).\n  '
    logging.basicConfig(format='%(asctime).19s %(levelname)s %(filename)s:%(lineno)s %(message)s ')
    os.environ['LC_ALL'] = 'C'
    (options, args) = parser.parse_args(argv[1:])
    global verbosity
    verbosity = options.verbose
    if (verbosity >= 3):
        logging.getLogger().setLevel(logging.DEBUG)
    elif (verbosity >= 2):
        logging.getLogger().setLevel(logging.INFO)
    vcs = GuessVCS(options)
    if isinstance(vcs, SubversionVCS):
        base = vcs.GuessBase(options.download_base)
    else:
        base = None
    if ((not base) and options.download_base):
        options.download_base = True
        logging.info('Enabled upload of base file')
    if (not options.assume_yes):
        vcs.CheckForUnknownFiles()
    if (data is None):
        data = vcs.GenerateDiff(args)
    files = vcs.GetBaseFiles(data)
    if (verbosity >= 1):
        print 'Upload server:', options.server, '(change with -s/--server)'
    if options.issue:
        prompt = 'Message describing this patch set: '
    else:
        prompt = 'New issue subject: '
    message = (options.message or raw_input(prompt).strip())
    if (not message):
        ErrorExit('A non-empty message is required')
    rpc_server = GetRpcServer(options)
    form_fields = [('subject', message)]
    if base:
        form_fields.append(('base', base))
    if options.issue:
        form_fields.append(('issue', str(options.issue)))
    if options.email:
        form_fields.append(('user', options.email))
    if options.reviewers:
        for reviewer in options.reviewers.split(','):
            if (('@' in reviewer) and (not (reviewer.split('@')[1].count('.') == 1))):
                ErrorExit(('Invalid email address: %s' % reviewer))
        form_fields.append(('reviewers', options.reviewers))
    if options.cc:
        for cc in options.cc.split(','):
            if (('@' in cc) and (not (cc.split('@')[1].count('.') == 1))):
                ErrorExit(('Invalid email address: %s' % cc))
        form_fields.append(('cc', options.cc))
    description = options.description
    if options.description_file:
        if options.description:
            ErrorExit("Can't specify description and description_file")
        file = open(options.description_file, 'r')
        description = file.read()
        file.close()
    if description:
        form_fields.append(('description', description))
    base_hashes = ''
    for (file, info) in files.iteritems():
        if (not (info[0] is None)):
            checksum = md5.new(info[0]).hexdigest()
            if base_hashes:
                base_hashes += '|'
            base_hashes += ((checksum + ':') + file)
    form_fields.append(('base_hashes', base_hashes))
    if (options.send_mail and options.download_base):
        form_fields.append(('send_mail', '1'))
    if (not options.download_base):
        form_fields.append(('content_upload', '1'))
    if (len(data) > MAX_UPLOAD_SIZE):
        print 'Patch is large, so uploading file patches separately.'
        uploaded_diff_file = []
        form_fields.append(('separate_patches', '1'))
    else:
        uploaded_diff_file = [('data', 'data.diff', data)]
    (ctype, body) = EncodeMultipartFormData(form_fields, uploaded_diff_file)
    response_body = rpc_server.Send('/upload', body, content_type=ctype)
    patchset = None
    if ((not options.download_base) or (not uploaded_diff_file)):
        lines = response_body.splitlines()
        if (len(lines) >= 2):
            msg = lines[0]
            patchset = lines[1].strip()
            patches = [x.split(' ', 1) for x in lines[2:]]
        else:
            msg = response_body
    else:
        msg = response_body
    StatusUpdate(msg)
    if ((not response_body.startswith('Issue created.')) and (not response_body.startswith('Issue updated.'))):
        sys.exit(0)
    issue = msg[(msg.rfind('/') + 1):]
    if (not uploaded_diff_file):
        result = UploadSeparatePatches(issue, rpc_server, patchset, data, options)
        if (not options.download_base):
            patches = result
    if (not options.download_base):
        vcs.UploadBaseFiles(issue, rpc_server, patches, patchset, options, files)
        if options.send_mail:
            rpc_server.Send((('/' + issue) + '/mail'), payload='')
    return (issue, patchset)
