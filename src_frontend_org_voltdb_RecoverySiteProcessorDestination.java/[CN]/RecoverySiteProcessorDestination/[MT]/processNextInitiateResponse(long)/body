{
  final long startTime=System.currentTimeMillis();
  while (m_incoming.peek() == null && System.currentTimeMillis() - startTime < 5000) {
    checkMailbox(false,txnId);
    Thread.yield();
  }
  if (m_incoming.peek() == null) {
    VoltDB.crashLocalVoltDB("Timed out waiting to read recovery initiate ack message",false,null);
  }
  if (m_iodaemon.m_lastException != null) {
    VoltDB.crashLocalVoltDB("There was an error while reading the recovery initiate ack message",true,m_iodaemon.m_lastException);
  }
  BBContainer ackMessageContainer=m_incoming.poll();
  ByteBuffer ackMessage=ackMessageContainer.b;
  final long sourceSite=ackMessage.getLong();
  final boolean stopBeforeOrSkipPast=ackMessage.get() == 0 ? true : false;
  if (stopBeforeOrSkipPast) {
    m_stopBeforeTxnId=ackMessage.getLong();
    recoveryLog.info("Recovery initiate ack received at site " + CoreUtils.hsIdToString(m_HSId) + " from site "+ CoreUtils.hsIdToString(sourceSite)+ " will sync before txnId "+ m_stopBeforeTxnId);
  }
 else {
    m_skipPastTxnId=ackMessage.getLong();
    recoveryLog.info("Recovery initiate ack received at site " + CoreUtils.hsIdToString(m_HSId) + " from site "+ CoreUtils.hsIdToString(sourceSite)+ " will delay sync until after executing txnId "+ m_skipPastTxnId);
  }
  int byteLen=ackMessage.getInt();
  if (byteLen > 0) {
    byte[] exportUSOBytes=new byte[byteLen];
    ackMessage.get(exportUSOBytes);
    String exportUSOs=new String(exportUSOBytes,"UTF-8");
    String[] tableUSOs=exportUSOs.trim().split("\n");
    for (    String tableUSO : tableUSOs) {
      String[] parts=tableUSO.trim().split(",");
      assert(parts.length == 3);
      long ackOffset=Long.parseLong(parts[1]);
      long seqNo=Long.parseLong(parts[2]);
      m_engine.exportAction(true,ackOffset,seqNo,m_partitionId,parts[0]);
    }
  }
  ackMessageContainer.discard();
}
