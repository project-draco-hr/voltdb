{
  ServerSocketChannel ssc=ServerSocketChannel.open();
  ssc.configureBlocking(false);
  InetAddress addr=InetAddress.getByName(VoltDB.instance().getConfig().m_selectedRejoinInterface);
  InetSocketAddress sockAddr=new InetSocketAddress(addr,0);
  ssc.socket().bind(sockAddr);
  final int port=ssc.socket().getLocalPort();
  final byte address[]=ssc.socket().getInetAddress().getAddress();
  ByteBuffer buf=ByteBuffer.allocate(2048);
  BBContainer container=DBBPool.wrapBB(buf);
  RecoveryMessage recoveryMessage=new RecoveryMessage(container,m_siteId,txnId,address,port);
  recoveryLog.trace("Sending recovery initiate request before txnid " + txnId + " from site "+ m_siteId+ " to "+ m_sourceSiteId);
  try {
    m_mailbox.send(m_sourceSiteId,0,recoveryMessage);
  }
 catch (  MessagingException e) {
    throw new RuntimeException(e);
  }
  final long startTime=System.currentTimeMillis();
  while (System.currentTimeMillis() - startTime < 5000) {
    try {
      m_sc=ssc.accept();
      if (m_sc != null) {
        break;
      }
    }
 catch (    IOException e) {
      ssc.close();
    }
  }
  if (m_sc == null) {
    recoveryLog.fatal("Timed out waiting for connection from source partition");
    VoltDB.crashVoltDB();
  }
  m_sc.configureBlocking(true);
  m_sc.socket().setTcpNoDelay(true);
  ByteBuffer messageLength=ByteBuffer.allocate(4);
  while (messageLength.hasRemaining()) {
    int read=m_sc.read(messageLength);
    if (read == -1) {
      throw new EOFException();
    }
  }
  messageLength.flip();
  ByteBuffer response=ByteBuffer.allocate(messageLength.getInt());
  while (response.hasRemaining()) {
    int read=m_sc.read(response);
    if (read == -1) {
      throw new EOFException();
    }
  }
  response.flip();
  final int sourceSite=response.getInt();
  m_stopBeforeTxnId=response.getLong();
  recoveryLog.info("Recovery initiate ack received at site " + m_siteId + " from site "+ sourceSite+ " will sync after txnId "+ m_stopBeforeTxnId);
  m_iodaemon=new IODaemon(m_sc);
  ssc.close();
  return;
}
