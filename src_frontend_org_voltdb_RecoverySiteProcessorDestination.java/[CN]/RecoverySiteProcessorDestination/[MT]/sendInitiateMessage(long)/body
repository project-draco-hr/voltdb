{
  ServerSocketChannel ssc=ServerSocketChannel.open();
  ssc.configureBlocking(false);
  InetAddress addr=InetAddress.getByName(VoltDB.instance().getConfig().m_selectedRejoinInterface);
  InetSocketAddress sockAddr=new InetSocketAddress(addr,0);
  ssc.socket().bind(sockAddr);
  final int port=ssc.socket().getLocalPort();
  final byte address[]=ssc.socket().getInetAddress().getAddress();
  ByteBuffer buf=ByteBuffer.allocate(2048);
  BBContainer container=DBBPool.wrapBB(buf);
  RecoveryMessage recoveryMessage=new RecoveryMessage(container,m_siteId,txnId,address,port);
  recoveryLog.trace("Sending recovery initiate request before txnid " + txnId + " from site "+ m_siteId+ " to "+ m_sourceSiteId);
  try {
    m_mailbox.send(m_sourceSiteId,0,recoveryMessage);
  }
 catch (  MessagingException e) {
    throw new RuntimeException(e);
  }
  final long startTime=System.currentTimeMillis();
  while (System.currentTimeMillis() - startTime < 5000) {
    try {
      m_sc=ssc.accept();
      if (m_sc != null) {
        break;
      }
    }
 catch (    IOException e) {
      ssc.close();
    }
    Thread.yield();
  }
  if (m_sc == null) {
    recoveryLog.fatal("Timed out waiting for connection from source partition");
    VoltDB.crashVoltDB();
  }
  ssc.close();
  final AtomicBoolean recoveryAckReaderSuccess=new AtomicBoolean(false);
  final Thread recoveryAckReader=new Thread(){
    @Override public void run(){
      try {
        m_sc.configureBlocking(true);
        m_sc.socket().setTcpNoDelay(true);
        ByteBuffer messageLength=ByteBuffer.allocate(4);
        while (messageLength.hasRemaining()) {
          final int read=m_sc.read(messageLength);
          if (read == -1) {
            throw new EOFException();
          }
        }
        messageLength.flip();
        ByteBuffer response=ByteBuffer.allocate(messageLength.getInt());
        while (response.hasRemaining()) {
          int read=m_sc.read(response);
          if (read == -1) {
            throw new EOFException();
          }
        }
        response.flip();
        final int sourceSite=response.getInt();
        m_stopBeforeTxnId=response.getLong();
        recoveryLog.info("Recovery initiate ack received at site " + m_siteId + " from site "+ sourceSite+ " will sync after txnId "+ m_stopBeforeTxnId);
        m_iodaemon=new IODaemon(m_sc);
        recoveryAckReaderSuccess.set(true);
      }
 catch (      Exception e) {
        recoveryLog.fatal("Failure while attempting to read recovery initiate ack message",e);
        VoltDB.crashVoltDB();
      }
    }
  }
;
  recoveryAckReader.start();
  while (recoveryAckReader.isAlive() && System.currentTimeMillis() - startTime < 5000) {
    checkMailbox(false);
    Thread.yield();
  }
  if (recoveryAckReader.isAlive()) {
    recoveryLog.fatal("Timed out waiting to read recovery initiate ack message");
    VoltDB.crashVoltDB();
  }
  if (recoveryAckReaderSuccess.get() == false) {
    recoveryLog.fatal("There was an error while reading the recovery initiate ack message");
    VoltDB.crashVoltDB();
  }
  try {
    recoveryAckReader.join();
  }
 catch (  InterruptedException e) {
    throw new java.io.InterruptedIOException("Interrupted while joining on recovery initiate ack reader");
  }
  return;
}
