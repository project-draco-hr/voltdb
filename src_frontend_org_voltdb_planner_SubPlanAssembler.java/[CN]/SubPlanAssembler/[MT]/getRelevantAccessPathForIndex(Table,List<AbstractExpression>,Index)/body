{
  assert(index != null);
  assert(table != null);
  if (!index.getExpressionsjson().equals("")) {
    return null;
  }
  if (exprs == null) {
    return null;
  }
  AccessPath retval=new AccessPath();
  retval.use=IndexUseType.COVERING_UNIQUE_EQUALITY;
  retval.index=index;
  final boolean indexScannable=(index.getType() == IndexType.BALANCED_TREE.getValue()) || (index.getType() == IndexType.BTREE.getValue());
  HashMap<Column,ArrayList<AbstractExpression>> eqColumns=new HashMap<Column,ArrayList<AbstractExpression>>();
  HashMap<Column,ArrayList<AbstractExpression>> gtColumns=new HashMap<Column,ArrayList<AbstractExpression>>();
  HashMap<Column,ArrayList<AbstractExpression>> ltColumns=new HashMap<Column,ArrayList<AbstractExpression>>();
  for (  AbstractExpression ae : exprs) {
    AbstractExpression expr=getIndexableExpressionForFilter(table,ae);
    if (expr != null) {
      AbstractExpression indexable=expr.getLeft();
      assert(indexable.getExpressionType() == ExpressionType.VALUE_TUPLE);
      TupleValueExpression tve=(TupleValueExpression)indexable;
      Column col=getTableColumn(table,tve.getColumnName());
      assert(col != null);
      if (expr.getExpressionType() == ExpressionType.COMPARE_EQUAL) {
        if (eqColumns.containsKey(col) == false)         eqColumns.put(col,new ArrayList<AbstractExpression>());
        eqColumns.get(col).add(expr);
        continue;
      }
      if ((expr.getExpressionType() == ExpressionType.COMPARE_GREATERTHAN) || (expr.getExpressionType() == ExpressionType.COMPARE_GREATERTHANOREQUALTO)) {
        if (gtColumns.containsKey(col) == false)         gtColumns.put(col,new ArrayList<AbstractExpression>());
        gtColumns.get(col).add(expr);
        continue;
      }
      if ((expr.getExpressionType() == ExpressionType.COMPARE_LESSTHAN) || (expr.getExpressionType() == ExpressionType.COMPARE_LESSTHANOREQUALTO)) {
        if (ltColumns.containsKey(col) == false)         ltColumns.put(col,new ArrayList<AbstractExpression>());
        ltColumns.get(col).add(expr);
        continue;
      }
    }
    retval.otherExprs.add(ae);
  }
  if (indexScannable && m_parsedStmt instanceof ParsedSelectStmt) {
    ParsedSelectStmt parsedSelectStmt=(ParsedSelectStmt)m_parsedStmt;
    if (!parsedSelectStmt.orderColumns.isEmpty()) {
      List<ColumnRef> sortedColumns=CatalogUtil.getSortedCatalogItems(index.getColumns(),"index");
      Iterator<ColumnRef> colRefIter=sortedColumns.iterator();
      boolean ascending=parsedSelectStmt.orderColumns.get(0).ascending;
      for (      ParsedColInfo colInfo : parsedSelectStmt.orderColumns) {
        if (!colRefIter.hasNext()) {
          retval.sortDirection=SortDirectionType.INVALID;
          break;
        }
        ColumnRef colRef=colRefIter.next();
        if (colInfo.expression instanceof TupleValueExpression && colInfo.tableName.equals(table.getTypeName()) && colInfo.columnName.equals(colRef.getColumn().getTypeName())&& colInfo.ascending == ascending) {
          if (ascending)           retval.sortDirection=SortDirectionType.ASC;
 else           retval.sortDirection=SortDirectionType.DESC;
          retval.use=IndexUseType.INDEX_SCAN;
        }
 else {
          retval.sortDirection=SortDirectionType.INVALID;
          break;
        }
      }
    }
  }
  for (  ColumnRef colRef : CatalogUtil.getSortedCatalogItems(index.getColumns(),"index")) {
    Column col=colRef.getColumn();
    if (eqColumns.containsKey(col) && (eqColumns.get(col).size() >= 0)) {
      AbstractExpression expr=eqColumns.get(col).remove(0);
      retval.indexExprs.add(expr);
      retval.endExprs.add(expr);
      if (retval.sortDirection == SortDirectionType.DESC) {
        retval.sortDirection=SortDirectionType.INVALID;
      }
    }
 else {
      if (gtColumns.containsKey(col) && (gtColumns.get(col).size() >= 0)) {
        AbstractExpression expr=gtColumns.get(col).remove(0);
        if (retval.sortDirection != SortDirectionType.DESC)         retval.indexExprs.add(expr);
        if (retval.sortDirection == SortDirectionType.DESC)         retval.endExprs.add(expr);
        if (expr.getExpressionType() == ExpressionType.COMPARE_GREATERTHAN)         retval.lookupType=IndexLookupType.GT;
 else         if (expr.getExpressionType() == ExpressionType.COMPARE_GREATERTHANOREQUALTO) {
          retval.lookupType=IndexLookupType.GTE;
        }
 else         assert(false);
        retval.use=IndexUseType.INDEX_SCAN;
      }
      if (ltColumns.containsKey(col) && (ltColumns.get(col).size() >= 0)) {
        AbstractExpression expr=ltColumns.get(col).remove(0);
        retval.endExprs.add(expr);
        if (retval.indexExprs.size() == 0) {
          retval.lookupType=IndexLookupType.GTE;
        }
      }
      break;
    }
  }
  if (retval.indexExprs.size() == 0 && retval.endExprs.size() == 0 && retval.sortDirection == SortDirectionType.INVALID)   return null;
  if (retval.use == IndexUseType.COVERING_UNIQUE_EQUALITY && retval.indexExprs.size() < index.getColumns().size()) {
    retval.use=IndexUseType.INDEX_SCAN;
    retval.lookupType=IndexLookupType.GTE;
  }
  if ((indexScannable == false)) {
    if (retval.indexExprs.size() < index.getColumns().size())     return null;
    if ((retval.use == IndexUseType.INDEX_SCAN))     return null;
  }
  for (  ArrayList<AbstractExpression> list : eqColumns.values()) {
    assert(list != null);
    for (    AbstractExpression expr : list) {
      assert(expr != null);
      retval.otherExprs.add(expr);
    }
  }
  for (  ArrayList<AbstractExpression> list : gtColumns.values()) {
    assert(list != null);
    for (    AbstractExpression expr : list) {
      assert(expr != null);
      retval.otherExprs.add(expr);
    }
  }
  for (  ArrayList<AbstractExpression> list : ltColumns.values()) {
    assert(list != null);
    for (    AbstractExpression expr : list) {
      assert(expr != null);
      retval.otherExprs.add(expr);
    }
  }
  return retval;
}
