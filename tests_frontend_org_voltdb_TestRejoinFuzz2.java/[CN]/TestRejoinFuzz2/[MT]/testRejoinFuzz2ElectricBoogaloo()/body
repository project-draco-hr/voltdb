{
  VoltProjectBuilder builder=getBuilderForTest();
  builder.setSecurityEnabled(true);
  int processors=CoreUtils.availableProcessors();
  final int numHosts=processors >= 8 ? 6 : 3;
  final int numTuples=204800 * (processors >= 8 ? 6 : 1);
  final int kfactor=2;
  final LocalCluster cluster=new LocalCluster("rejoin.jar",1,numHosts,kfactor,BackendTarget.NATIVE_EE_JNI,LocalCluster.FailureState.ALL_RUNNING,false,true,false,null);
  cluster.setMaxHeap(256);
  cluster.overrideAnyRequestForValgrind();
  if (cluster.isValgrind() || cluster.isMemcheckDefined()) {
    return;
  }
  boolean success=cluster.compile(builder);
  assertTrue(success);
  MiscUtils.copyFile(builder.getPathToDeployment(),Configuration.getPathToCatalogForTest("rejoin.xml"));
  cluster.setHasLocalServer(false);
  cluster.startUp();
  Client client=ClientFactory.createClient(m_cconfig);
  client.createConnection("localhost",cluster.port(0));
  Random r=new Random();
  StringBuilder sb=new StringBuilder(512);
  for (int ii=0; ii < 512; ii++) {
    sb.append((char)(34 + r.nextInt(90)));
  }
  String theString=sb.toString();
  final Semaphore rateLimit=new Semaphore(1000);
  for (int ii=0; ii < numTuples; ii++) {
    rateLimit.acquire();
    int value=r.nextInt(numTuples);
    client.callProcedure(new ProcedureCallback(){
      @Override public void clientCallback(      ClientResponse clientResponse) throws Exception {
        if (clientResponse.getStatus() != ClientResponse.SUCCESS) {
          System.err.println(clientResponse.getStatusString());
          return;
        }
        if (clientResponse.getResults()[0].asScalarLong() != 1) {
          System.err.println("Update didn't happen");
          return;
        }
        rateLimit.release();
      }
    }
,"InsertPartitionedLarge",ii,value,theString);
  }
  client.drain();
  client.close();
  final java.util.concurrent.atomic.AtomicBoolean haveFailed=new AtomicBoolean(false);
  Random forWhomTheBellTolls=new Random();
  for (int zz=0; zz < 5; zz++) {
    final ArrayList<Integer> toKillFirst=new ArrayList<Integer>();
    final ArrayList<Integer> toKillDuringRecovery=new ArrayList<Integer>();
    while (toKillFirst.size() < kfactor / 2) {
      int candidate=forWhomTheBellTolls.nextInt(numHosts);
      if (!toKillFirst.contains(candidate)) {
        toKillFirst.add(candidate);
      }
    }
    while (toKillDuringRecovery.size() < kfactor / 2) {
      int candidate=forWhomTheBellTolls.nextInt(numHosts);
      if (!toKillFirst.contains(candidate) && !toKillDuringRecovery.contains(candidate)) {
        toKillDuringRecovery.add(candidate);
      }
    }
    System.out.println("Killing " + toKillFirst.toString() + toKillDuringRecovery.toString());
    int toConnectToTemp=forWhomTheBellTolls.nextInt(numHosts);
    while (toKillFirst.contains(toConnectToTemp) || toKillDuringRecovery.contains(toConnectToTemp)) {
      toConnectToTemp=forWhomTheBellTolls.nextInt(numHosts);
    }
    final int toConnectTo=toConnectToTemp;
    for (    Integer uhoh : toKillFirst) {
      cluster.shutDownSingleHost(uhoh);
    }
    Thread recoveryThread=new Thread(){
      @Override public void run(){
        for (        Integer dead : toKillFirst) {
          int attempts=0;
          while (true) {
            if (attempts == 6) {
              haveFailed.set(true);
              break;
            }
            if (cluster.recoverOne(dead,toConnectTo,"")) {
              break;
            }
            attempts++;
          }
        }
      }
    }
;
    final java.util.concurrent.atomic.AtomicBoolean killerFail=new java.util.concurrent.atomic.AtomicBoolean(false);
    Thread killerThread=new Thread(){
      @Override public void run(){
        try {
          Random r=new Random();
          for (          Integer toKill : toKillDuringRecovery) {
            Thread.sleep(r.nextInt(5000));
            cluster.shutDownSingleHost(toKill);
          }
        }
 catch (        Exception e) {
          killerFail.set(true);
          e.printStackTrace();
        }
      }
    }
;
    recoveryThread.start();
    killerThread.start();
    recoveryThread.join();
    killerThread.join();
    if (killerFail.get()) {
      fail("Exception in killer thread");
    }
    for (    Integer recoverNow : toKillDuringRecovery) {
      int attempts=0;
      while (true) {
        if (attempts == 6) {
          haveFailed.set(true);
          break;
        }
        if (cluster.recoverOne(recoverNow,toConnectTo,"")) {
          break;
        }
        attempts++;
      }
    }
    System.out.println("Finished iteration " + zz);
  }
  cluster.shutDown();
  assertFalse(haveFailed.get());
}
