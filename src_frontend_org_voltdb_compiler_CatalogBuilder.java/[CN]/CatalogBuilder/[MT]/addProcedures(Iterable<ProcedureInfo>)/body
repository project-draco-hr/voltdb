{
  final HashSet<ProcedureInfo> newProcs=new HashSet<ProcedureInfo>();
  for (  final ProcedureInfo procedure : procedures) {
    assert(newProcs.contains(procedure) == false);
    assert(m_procedures.contains(procedure) == false);
    newProcs.add(procedure);
  }
  for (  final ProcedureInfo procedure : procedures) {
    m_procedures.add(procedure);
    StringBuffer roleInfo=new StringBuffer();
    if (procedure.groups.length != 0) {
      roleInfo.append(" ALLOW ");
      for (int i=0; i < procedure.groups.length; i++) {
        roleInfo.append(procedure.groups[i] + ",");
      }
      int length=roleInfo.length();
      roleInfo.replace(length - 1,length," ");
    }
    if (procedure.cls != null) {
      transformer.append("CREATE PROCEDURE " + roleInfo.toString() + " FROM CLASS "+ procedure.cls.getName()+ ";");
    }
 else     if (procedure.sql != null) {
      transformer.append("CREATE PROCEDURE " + procedure.name + roleInfo.toString()+ " AS "+ procedure.sql);
    }
    if (procedure.partitionInfo != null) {
      String[] parameter=procedure.partitionInfo.split(":");
      String[] token=parameter[0].split("\\.");
      String position="";
      if (Integer.parseInt(parameter[1].trim()) > 0) {
        position=" PARAMETER " + parameter[1];
      }
      transformer.append("PARTITION PROCEDURE " + procedure.name + " ON TABLE "+ token[0]+ " COLUMN "+ token[1]+ position+ ";");
    }
  }
}
