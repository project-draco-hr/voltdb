{
  assert(m_initialized);
  assert(message != null);
  assert(siteIds != null);
  final HashMap<ForeignHost,ForeignHostBundle> foreignHosts=new HashMap<ForeignHost,ForeignHostBundle>(32);
  for (  int siteId : siteIds) {
    ForeignHost host=presend(siteId,mailboxId,message);
    if (host == null)     continue;
    ForeignHostBundle bundle=foreignHosts.get(host);
    if (bundle == null) {
      bundle=new ForeignHostBundle();
      foreignHosts.put(host,bundle);
    }
    bundle.add(siteId);
  }
  if (foreignHosts.size() == 0)   return;
  final FutureTask<ByteBuffer> buildMessageTask=new FutureTask<ByteBuffer>(new Callable<ByteBuffer>(){
    @Override public final ByteBuffer call() throws IOException {
      return message.getBufferForMessaging(heapPool).b;
    }
  }
);
  for (  Entry<ForeignHost,ForeignHostBundle> e : foreignHosts.entrySet()) {
    e.getKey().send(mailboxId,e.getValue().siteIds,e.getValue().count,new DeferredSerialization(){
      @Override public final BBContainer serialize(      DBBPool pool) throws IOException {
        ByteBuffer messageBytes=null;
        try {
          buildMessageTask.run();
          messageBytes=buildMessageTask.get();
        }
 catch (        InterruptedException e) {
          m_logger.fatal("Should not be interrupted while serializing messages",e);
          throw new IOException(e);
        }
catch (        ExecutionException e) {
          if (e.getCause() instanceof IOException) {
            throw (IOException)e.getCause();
          }
 else {
            m_logger.fatal("Error while serializing message",e);
            throw new IOException(e);
          }
        }
        ByteBuffer view=messageBytes.duplicate();
        view.position(0);
        BBContainer stupidCopy=pool.acquire(view.remaining());
        stupidCopy.b.put(view);
        stupidCopy.b.flip();
        return stupidCopy;
      }
      @Override public final void cancel(){
      }
    }
);
  }
  foreignHosts.clear();
}
