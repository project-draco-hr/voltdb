{
  while ((config.limitrows-- > 0)) {
    try {
      if (listReader.getLineNumber() == 0) {
        totalLineCount.set(config.skip);
      }
 else {
        totalLineCount.set(listReader.getLineNumber());
      }
      long st=System.nanoTime();
      List<String> lineList=listReader.read();
      long end=System.nanoTime();
      parsingTimeEnd+=(end - st);
      if (lineList == null) {
        if (totalLineCount.get() > listReader.getLineNumber()) {
          totalLineCount.set(listReader.getLineNumber());
        }
        break;
      }
      totalRowCount.incrementAndGet();
      String lineCheckResult;
      String[] correctedLine=lineList.toArray(new String[0]);
      if ((lineCheckResult=checkparams_trimspace(correctedLine,columnCnt)) != null) {
        String[] info={lineList.toString(),lineCheckResult};
        if (synchronizeErrorInfo(totalLineCount.get() + 1,info)) {
          errored=true;
          break;
        }
        continue;
      }
      CSVLineWithMetaData lineData=new CSVLineWithMetaData();
      lineData.line=correctedLine;
      lineData.lineNumber=listReader.getLineNumber();
      int partitionId=0;
      if (!CSVPartitionProcessor.isMP) {
        partitionId=TheHashinator.getPartitionForParameter(partitionColumnType.getValue(),(Object)lineData.line[partitionedColumnIndex - 1]);
      }
      BlockingQueue<CSVLineWithMetaData> q=lineq.get(partitionId);
      if (!q.offer(lineData)) {
        q.put(lineData);
      }
    }
 catch (    SuperCsvException e) {
      e.printStackTrace();
      String[] info={e.getMessage(),""};
      if (synchronizeErrorInfo(totalLineCount.get() + 1,info)) {
        errored=true;
        break;
      }
    }
catch (    IOException ioex) {
      ioex.printStackTrace();
      break;
    }
catch (    InterruptedException ex) {
      break;
    }
  }
  try {
    listReader.close();
  }
 catch (  IOException ex) {
    m_log.error("Error cloging Reader: " + ex);
  }
 finally {
    for (    BlockingQueue<CSVLineWithMetaData> q : lineq.values()) {
      try {
        if (errored) {
          q.clear();
        }
        q.put(dummy);
      }
 catch (      InterruptedException ex) {
        ;
      }
    }
    m_log.info("Rows Queued by Reader: " + totalRowCount.get());
  }
  try {
    m_log.info("Waiting for partition processors to finish.");
    pcount.await();
    m_log.info("Partition Processors Done.");
  }
 catch (  InterruptedException ex) {
    ;
  }
}
