{
  List<String> lineList=new ArrayList<String>();
  long ecnt=0;
  while ((config.limitrows-- > 0)) {
    try {
      if (listReader.getLineNumber() == 0) {
        totalLineCount.set(config.skip);
      }
 else {
        totalLineCount.set(listReader.getLineNumber());
      }
      long st=System.nanoTime();
      lineList=listReader.read();
      long end=System.nanoTime();
      parsingTimeEnd+=(end - st);
      if (lineList == null) {
        if (totalLineCount.get() > listReader.getLineNumber()) {
          totalLineCount.set(listReader.getLineNumber());
        }
        break;
      }
      String lineCheckResult;
      String[] correctedLine=lineList.toArray(new String[0]);
      if ((lineCheckResult=CSVLoaderMT.checkparams_trimspace(correctedLine,columnCnt)) != null) {
        String[] info={lineList.toString(),lineCheckResult};
        CSVLoaderMT.synchronizeErrorInfoForFuture(totalLineCount.get() + 1,info);
        if (++ecnt > config.maxerrors) {
          break;
        }
        totalRowCount.getAndIncrement();
        continue;
      }
      CSVLineWithMetaData lineData=new CSVLineWithMetaData();
      lineData.parColumnName=parColumnName;
      lineData.line=correctedLine;
      int partitionId=0;
      if (!config.check) {
        if (!CSVPartitionProcessor.isMP) {
          partitionId=TheHashinator.getPartitionForParameter(VoltType.BIGINT.getValue(),(Object)lineData.line[partitionedColumnIndex - 1]);
        }
        if (lineq.get(partitionId) == null) {
          ArrayBlockingQueue<CSVLineWithMetaData> q=new ArrayBlockingQueue<CSVLineWithMetaData>(2000);
          q.put(lineData);
          lineq.put(partitionId,q);
          CSVPartitionProcessor pp=new CSVPartitionProcessor();
          pp.csvClient=csvClient;
          pp.partitionId=partitionId;
          pp.tableName=tableName;
          pp.columnCnt=columnCnt;
          pp.lineq=q;
          pp.rdr=this;
          pp.dummy=dummy;
          Thread th=new Thread(pp);
          th.setName("PartitionProcessor-" + partitionId);
          th.setDaemon(true);
          th.start();
          spawned.add(th);
        }
 else {
          BlockingQueue<CSVLineWithMetaData> q=lineq.get(partitionId);
          q.put(lineData);
        }
      }
      totalRowCount.getAndIncrement();
    }
 catch (    SuperCsvException e) {
      e.printStackTrace();
      totalRowCount.getAndIncrement();
      String[] info={e.getMessage(),""};
      try {
        CSVLoaderMT.synchronizeErrorInfo(totalLineCount.get() + 1,info);
      }
 catch (      IOException ex) {
      }
catch (      InterruptedException ex) {
      }
      break;
    }
catch (    Throwable ex) {
      ex.printStackTrace();
      totalRowCount.getAndIncrement();
      String[] info={ex.getMessage(),""};
      try {
        CSVLoaderMT.synchronizeErrorInfo(totalLineCount.get() + 1,info);
      }
 catch (      IOException ex1) {
      }
catch (      InterruptedException ex2) {
      }
      break;
    }
  }
  try {
    listReader.close();
  }
 catch (  IOException ex) {
    m_log.error("Error cloging Reader: " + ex);
  }
  done=true;
  for (  BlockingQueue<CSVLineWithMetaData> q : lineq.values()) {
    try {
      q.put(dummy);
    }
 catch (    InterruptedException ex) {
      Logger.getLogger(CSVLoaderMT.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  m_log.info("Rows Queued by Reader: " + totalRowCount.get());
}
