{
  CacheUse cacheUse=CacheUse.FAIL;
  if (m_plannerStats != null) {
    m_plannerStats.startStatsCollection();
  }
  try {
    if ((sqlIn == null) || (sqlIn.length() == 0)) {
      throw new RuntimeException("Can't plan empty or null SQL.");
    }
    String sql=sqlIn.trim();
    hostLog.debug("received sql stmt: " + sql);
    boolean cacheable=(partitionParam == null) && (inferSP);
    if (cacheable) {
      AdHocPlannedStatement cachedPlan=m_cache.getWithSQL(sqlIn);
      if (cachedPlan != null) {
        cacheUse=CacheUse.HIT1;
        return cachedPlan;
      }
 else {
        cacheUse=CacheUse.MISS;
      }
    }
    AbstractPlanNode.resetPlanNodeIds();
    TrivialCostModel costModel=new TrivialCostModel();
    PartitioningForStatement partitioning=new PartitioningForStatement(partitionParam,inferSP,inferSP);
    QueryPlanner planner=new QueryPlanner(sql,"PlannerTool","PlannerToolProc",m_cluster,m_database,partitioning,m_hsql,new DatabaseEstimates(),true,AD_HOC_JOINED_TABLE_LIMIT,costModel,null,null,null);
    CompiledPlan plan=null;
    String[] extractedLiterals=null;
    String parsedToken=null;
    try {
      planner.parse();
      parsedToken=planner.parameterize();
      if (cacheable) {
        assert(parsedToken != null);
        extractedLiterals=planner.extractedParamLiteralValues();
        List<BoundPlan> boundVariants=m_cache.getWithParsedToken(parsedToken);
        if (boundVariants != null) {
          assert(!boundVariants.isEmpty());
          BoundPlan matched=null;
          for (          BoundPlan boundPlan : boundVariants) {
            if (boundPlan.allowsParams(extractedLiterals)) {
              matched=boundPlan;
              break;
            }
          }
          if (matched != null) {
            CorePlan core=matched.core;
            ParameterSet params=new ParameterSet();
            planner.buildParameterSetFromExtractedLiteralsAndReturnPartitionIndex(boundVariants.get(0).core.parameterTypes,params);
            Object[] paramArray=params.toArray();
            Object partitionKey=null;
            if (core.partitioningParamIndex >= 0) {
              partitionKey=paramArray[core.partitioningParamIndex];
            }
            AdHocPlannedStatement ahps=new AdHocPlannedStatement(sql.getBytes(VoltDB.UTF8ENCODING),core,params,extractedLiterals,matched.constants,partitionKey);
            m_cache.put(sql,parsedToken,ahps);
            cacheUse=CacheUse.HIT2;
            return ahps;
          }
        }
      }
      plan=planner.plan();
      assert(plan != null);
    }
 catch (    Exception e) {
      throw new RuntimeException("Error compiling query: " + e.toString(),e);
    }
    if (plan == null) {
      throw new RuntimeException("Null plan received in PlannerTool.planSql");
    }
    if (!allowParameterization && (plan.extractedParamValues.size() == 0) && (plan.parameters.length > 0)) {
      throw new RuntimeException("ERROR: PARAMETERIZATION IN AD HOC QUERY");
    }
    if (plan.isContentDeterministic() == false) {
      String potentialErrMsg="Statement has a non-deterministic result - statement: \"" + sql + "\" , reason: "+ plan.nondeterminismDetail();
      hostLog.warn(potentialErrMsg);
    }
    AdHocPlannedStatement ahps=new AdHocPlannedStatement(plan,m_catalogVersion,extractedLiterals);
    if (cacheable && planner.compiledAsParameterizedPlan()) {
      assert(parsedToken != null);
      assert(((ahps.partitionParam == null) && (ahps.core.partitioningParamIndex == -1)) || ((ahps.partitionParam != null) && (ahps.core.partitioningParamIndex >= 0)));
      m_cache.put(sqlIn,parsedToken,ahps);
    }
    return ahps;
  }
  finally {
    if (m_plannerStats != null) {
      m_plannerStats.endStatsCollection(m_cache.getLiteralCacheSize(),m_cache.getCoreCacheSize(),cacheUse,-1);
    }
  }
}
