{
  Result retval=new Result();
  if ((sql == null) || (sql.length() == 0)) {
    throw new RuntimeException("Can't plan empty or null SQL.");
  }
  sql=sql.trim();
  hostLog.debug("received sql stmt: " + sql);
  TrivialCostModel costModel=new TrivialCostModel();
  QueryPlanner planner=new QueryPlanner(m_context.cluster,m_context.database,singlePartition,m_hsql,new DatabaseEstimates(),false,true);
  CompiledPlan plan=null;
  try {
    plan=planner.compilePlan(costModel,sql,null,"PlannerTool","PlannerToolProc",AD_HOC_JOINED_TABLE_LIMIT,null);
  }
 catch (  Exception e) {
    throw new RuntimeException("Error creating planner: " + e.getMessage(),e);
  }
  if (plan == null) {
    String plannerMsg=planner.getErrorMessage();
    if (plannerMsg != null) {
      throw new RuntimeException("ERROR: " + plannerMsg + "\n");
    }
 else {
      throw new RuntimeException("ERROR: UNKNOWN PLANNING ERROR\n");
    }
  }
  if (plan.parameters.size() > 0) {
    throw new RuntimeException("ERROR: PARAMETERIZATION IN AD HOC QUERY");
  }
  if (plan.isContentDeterministic() == false) {
    String potentialErrMsg="Statement has a non-deterministic result - statement: \"" + sql + "\" , reason: "+ plan.nondeterminismDetail();
    hostLog.warn(potentialErrMsg);
  }
  assert(plan.fragments.size() <= 2);
  for (int i=0; i < plan.fragments.size(); i++) {
    Fragment frag=plan.fragments.get(i);
    PlanNodeList planList=new PlanNodeList(frag.planGraph);
    String serializedPlan=planList.toJSONString();
    String encodedPlan=serializedPlan;
    if (frag.multiPartition) {
      retval.allPlan=encodedPlan;
    }
 else {
      retval.onePlan=encodedPlan;
    }
  }
  retval.replicatedDML=plan.replicatedTableDML;
  return retval;
}
