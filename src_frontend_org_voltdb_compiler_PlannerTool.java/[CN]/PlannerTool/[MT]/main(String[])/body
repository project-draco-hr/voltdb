{
  Thread.currentThread().setName("VoltDB Planner Process Main");
  m_logfile=new File("plannerlog.txt");
  log("\ngetting started at: " + new Date().toString());
  BufferedReader br=null;
  final int TEN_MEGS=10 * 1024 * 1024;
  br=new BufferedReader(new InputStreamReader(System.in),TEN_MEGS);
  String encodedSerializedCatalog=null;
  try {
    encodedSerializedCatalog=br.readLine();
  }
 catch (  IOException e) {
    log("Couldn't read catalog: " + e.getMessage());
    System.exit(50);
  }
  final String serializedCatalog=Encoder.decodeBase64AndDecompress(encodedSerializedCatalog);
  if ((serializedCatalog == null) || (serializedCatalog.length() == 0)) {
    log("Catalog is null or empty");
    System.exit(28);
  }
  Catalog catalog=new Catalog();
  catalog.execute(serializedCatalog);
  Cluster cluster=catalog.getClusters().get("cluster");
  Database db=cluster.getDatabases().get("database");
  log("catalog loaded");
  HSQLInterface hsql=HSQLInterface.loadHsqldb();
  String hexDDL=db.getSchema();
  String ddl=Encoder.hexDecodeToString(hexDDL);
  String[] commands=ddl.split("\n");
  for (  String command : commands) {
    String decoded_cmd=Encoder.hexDecodeToString(command);
    decoded_cmd=decoded_cmd.trim();
    if (decoded_cmd.length() == 0)     continue;
    try {
      hsql.runDDLCommand(decoded_cmd);
    }
 catch (    HSQLParseException e) {
      log("Error creating hsql: " + e.getMessage());
      log("   in DDL statement: " + decoded_cmd);
      System.exit(82);
    }
  }
  log("hsql loaded");
  String inputLine="";
  while (true) {
    try {
      inputLine=br.readLine();
    }
 catch (    IOException e) {
      log("Exception: " + e.getMessage());
      System.out.println("ERROR: " + e.getMessage() + "\n");
      System.exit(81);
    }
    if (inputLine.length() == 0) {
      log("got a zero-length sql statement");
      continue;
    }
    inputLine=inputLine.trim();
    log("recieved sql stmt: " + inputLine);
    if (inputLine.compareTo(POISON_SQL) == 0) {
      log("Dying a horrible death (on purpose).");
      System.exit(-1);
    }
    TrivialCostModel costModel=new TrivialCostModel();
    QueryPlanner planner=new QueryPlanner(cluster,db,hsql,new DatabaseEstimates(),false,true);
    CompiledPlan plan=null;
    try {
      plan=planner.compilePlan(costModel,inputLine,"PlannerTool","PlannerToolProc",false,null);
    }
 catch (    Exception e) {
      log("Error creating planner: " + e.getMessage());
      String plannerMsg=e.getMessage();
      if (plannerMsg != null) {
        System.out.println("ERROR: " + plannerMsg + "\n");
      }
 else {
        System.out.println("ERROR: UNKNOWN PLANNING ERROR\n");
      }
      continue;
    }
    if (plan == null) {
      String plannerMsg=planner.getErrorMessage();
      if (plannerMsg != null) {
        System.out.println("ERROR: " + plannerMsg + "\n");
      }
 else {
        System.out.println("ERROR: UNKNOWN PLANNING ERROR\n");
      }
      continue;
    }
    log("finished planning stmt");
    assert(plan.fragments.size() <= 2);
    for (int i=0; i < plan.fragments.size(); i++) {
      Fragment frag=plan.fragments.get(i);
      PlanNodeList planList=new PlanNodeList(frag.planGraph);
      String serializedPlan=planList.toJSONString();
      String encodedPlan=serializedPlan;
      if (frag.multiPartition) {
        log("PLAN-ALL GENERATED");
        System.out.println("PLAN-ALL: " + encodedPlan);
      }
 else {
        log("PLAN-ONE GENERATED");
        System.out.println("PLAN-ONE: " + encodedPlan);
      }
    }
    if (plan.replicatedTableDML) {
      System.out.println("REPLICATED-DML: true");
    }
    log("finished loop");
    System.out.println();
    System.out.flush();
  }
}
