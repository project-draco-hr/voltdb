{
  m_endOfStream=true;
  m_onDrain=new Runnable(){
    @Override public void run(){
      try {
        onDrain.run();
      }
  finally {
        m_onDrain=null;
        forwardAckToOtherReplicas(Long.MIN_VALUE);
      }
    }
  }
;
  String overflowPath=adFile.getParent();
  byte data[]=Files.toByteArray(adFile);
  try {
    JSONObject jsObj=new JSONObject(new String(data,Charsets.UTF_8));
    long version=jsObj.getLong("adVersion");
    if (version != 0) {
      throw new IOException("Unsupported ad file version " + version);
    }
    m_HSId=jsObj.getLong("hsId");
    m_database=jsObj.getString("database");
    m_generation=jsObj.getLong("generation");
    m_partitionId=jsObj.getInt("partitionId");
    m_signature=jsObj.getString("signature");
    m_signatureBytes=m_signature.getBytes(Constants.UTF8ENCODING);
    m_tableName=jsObj.getString("tableName");
    JSONArray columns=jsObj.getJSONArray("columns");
    for (int ii=0; ii < columns.length(); ii++) {
      JSONObject column=columns.getJSONObject(ii);
      m_columnNames.add(column.getString("name"));
      int columnType=column.getInt("type");
      m_columnTypes.add(columnType);
      m_columnLengths.add(column.getInt("length"));
    }
  }
 catch (  JSONException e) {
    throw new IOException(e);
  }
  String nonce=m_signature + "_" + m_HSId+ "_"+ m_partitionId;
  m_committedBuffers=new StreamBlockQueue(overflowPath,nonce);
  m_nullArrayLength=((m_columnTypes.size() + 7) & -8) >> 3;
  m_es=CoreUtils.getListeningExecutorService("ExportDataSource gen " + m_generation + " table "+ m_tableName+ " partition "+ m_partitionId,1);
}
