{
  if (checkDeleteIgnoreList(prevType,newlyChildlessParent,mapName,name)) {
    return;
  }
  String errorMessage=checkAddDropWhitelist(prevType,ChangeType.DELETION);
  if (errorMessage != null) {
    String[] response=checkAddDropIfEmptyTableWhitelist(prevType,ChangeType.DELETION);
    assert((response == null) || (response.length == 2));
    if (response == null) {
      m_supported=false;
      m_errors.append(errorMessage);
    }
 else {
      assert(response.length == 2);
      String tableName=response[0];
      assert(tableName != null);
      String nonEmptyErrorMessage=response[1];
      assert(nonEmptyErrorMessage != null);
      String existingErrorMessagesForNonEmptyTable=m_tablesThatMustBeEmpty.get(tableName);
      if (nonEmptyErrorMessage.length() == 0) {
        assert(existingErrorMessagesForNonEmptyTable != null);
      }
 else {
        if (existingErrorMessagesForNonEmptyTable != null) {
          nonEmptyErrorMessage=nonEmptyErrorMessage + "\n" + existingErrorMessagesForNonEmptyTable;
        }
        m_tablesThatMustBeEmpty.put(tableName,"  " + nonEmptyErrorMessage);
      }
    }
  }
  m_sb.append("delete ").append(prevType.getParent().getPath()).append(" ");
  m_sb.append(mapName).append(" ").append(name).append("\n");
  CatalogChangeGroup cgrp=m_changes.get(DiffClass.get(prevType));
  cgrp.processDeletion(prevType,newlyChildlessParent);
}
