{
  Future<?> retval=null;
  if (m_snapshotTableTasks == null || m_availableSnapshotBuffers.isEmpty() || (!ignoreQuietPeriod && inQuietPeriod())) {
    return retval;
  }
  while (!m_snapshotTableTasks.isEmpty()) {
    final SnapshotTableTask currentTask=m_snapshotTableTasks.peek();
    assert(currentTask != null);
    final int headerSize=currentTask.m_target.getHeaderSize();
    final BBContainer snapshotBuffer=m_availableSnapshotBuffers.poll();
    assert(snapshotBuffer != null);
    snapshotBuffer.b.clear();
    snapshotBuffer.b.position(headerSize);
    final int serialized=ee.tableStreamSerializeMore(snapshotBuffer,currentTask.m_tableId,TableStreamType.SNAPSHOT);
    if (serialized < 0) {
      VoltDB.crashLocalVoltDB("Failure while serialize data from a table for COW snapshot",false,null);
    }
    if (serialized == 0) {
      final SnapshotTableTask t=m_snapshotTableTasks.poll();
      if (t.m_isReplicated && t.m_target.getFormat().isTableBased()) {
        final Thread terminatorThread=new Thread("Replicated SnapshotDataTarget terminator "){
          @Override public void run(){
            try {
              t.m_target.close();
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
catch (            InterruptedException e) {
              throw new RuntimeException(e);
            }
          }
        }
;
        m_snapshotTargetTerminators.add(terminatorThread);
        terminatorThread.start();
      }
      m_availableSnapshotBuffers.offer(snapshotBuffer);
      continue;
    }
    snapshotBuffer.b.limit(headerSize + serialized);
    snapshotBuffer.b.position(0);
    Callable<BBContainer> valueForTarget=Callables.returning(snapshotBuffer);
    for (    SnapshotDataFilter filter : currentTask.m_filters) {
      valueForTarget=filter.filter(valueForTarget);
    }
    retval=currentTask.m_target.write(valueForTarget,currentTask);
    if (retval != null) {
      m_writeFutures.add(retval);
    }
    if (!ignoreQuietPeriod && m_snapshotPriority > 0) {
      m_quietUntil=System.currentTimeMillis() + (5 * m_snapshotPriority) + ((long)(Math.random() * 15));
    }
    break;
  }
  if (m_snapshotTableTasks.isEmpty()) {
    final ArrayList<SnapshotDataTarget> snapshotTargets=m_snapshotTargets;
    m_snapshotTargets=null;
    m_snapshotTableTasks=null;
    final int result=ExecutionSitesCurrentlySnapshotting.decrementAndGet();
    if (result == 0) {
      final long txnId=m_lastSnapshotTxnId;
      final int numHosts=m_lastSnapshotNumHosts;
      final Thread terminatorThread=new Thread("Snapshot terminator"){
        @Override public void run(){
          try {
            for (            Thread t : m_snapshotTargetTerminators) {
              if (t == this) {
                continue;
              }
              try {
                t.join();
              }
 catch (              InterruptedException e) {
                return;
              }
            }
            for (            final SnapshotDataTarget t : snapshotTargets) {
              try {
                t.close();
              }
 catch (              IOException e) {
                m_lastSnapshotSucceded=false;
                throw new RuntimeException(e);
              }
catch (              InterruptedException e) {
                m_lastSnapshotSucceded=false;
                throw new RuntimeException(e);
              }
            }
            Runnable r=null;
            while ((r=m_tasksOnSnapshotCompletion.poll()) != null) {
              try {
                r.run();
              }
 catch (              Exception e) {
                hostLog.error("Error running snapshot completion task",e);
              }
            }
            for (            Future<?> retval : m_writeFutures) {
              try {
                retval.get();
              }
 catch (              Exception e) {
                m_lastSnapshotSucceded=false;
              }
            }
          }
  finally {
            m_writeFutures=Collections.synchronizedList(new ArrayList<Future<?>>());
            try {
              logSnapshotCompleteToZK(txnId,numHosts,m_lastSnapshotSucceded);
            }
  finally {
              ExecutionSitesCurrentlySnapshotting.decrementAndGet();
            }
          }
        }
      }
;
      m_snapshotTargetTerminators.add(terminatorThread);
      terminatorThread.start();
    }
  }
  return retval;
}
