{
  final File f=new VoltFile(path,constructDigestFilenameForNonce(nonce,hostId));
  if (f.exists()) {
    if (!f.delete()) {
      throw new IOException("Unable to write table list file " + f);
    }
  }
  final FileOutputStream fos=new FileOutputStream(f);
  StringWriter sw=new StringWriter();
  JSONStringer stringer=new JSONStringer();
  try {
    stringer.object();
    stringer.key("version").value(1);
    stringer.key("txnId").value(txnId);
    stringer.key("tables").array();
    for (int ii=0; ii < tables.size(); ii++) {
      stringer.value(tables.get(ii).getTypeName());
    }
    stringer.endArray();
    stringer.key("exportSequenceNumbers").array();
    for (    Map.Entry<String,List<Pair<Integer,Long>>> entry : exportSequenceNumbers.entrySet()) {
      stringer.object();
      stringer.key("exportTableName").value(entry.getKey());
      stringer.key("sequenceNumberPerPartition").array();
      for (      Pair<Integer,Long> sequenceNumber : entry.getValue()) {
        stringer.object();
        stringer.key("partition").value(sequenceNumber.getFirst());
        stringer.key("exportSequenceNumber").value(sequenceNumber.getSecond());
        stringer.endObject();
      }
      stringer.endArray();
      stringer.endObject();
    }
    stringer.endArray();
    stringer.key("catalogCRC").value(catalogCRC);
    stringer.endObject();
  }
 catch (  JSONException e) {
    throw new IOException(e);
  }
  sw.append(stringer.toString());
  final byte tableListBytes[]=sw.getBuffer().toString().getBytes("UTF-8");
  final CRC32 crc=new CRC32();
  crc.update(tableListBytes);
  ByteBuffer fileBuffer=ByteBuffer.allocate(tableListBytes.length + 4);
  fileBuffer.putInt((int)crc.getValue());
  fileBuffer.put(tableListBytes);
  fileBuffer.flip();
  fos.getChannel().write(fileBuffer);
  return new Runnable(){
    @Override public void run(){
      try {
        fos.getChannel().force(true);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
 finally {
        try {
          fos.close();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
  }
;
}
