{
  if (recursion == 32) {
    return;
  }
  if (!directory.exists()) {
    System.err.println("Error: Directory " + directory.getPath() + " doesn't exist");
    return;
  }
  if (!directory.canRead()) {
    System.err.println("Error: Directory " + directory.getPath() + " is not readable");
    return;
  }
  if (!directory.canExecute()) {
    System.err.println("Error: Directory " + directory.getPath() + " is not executable");
    return;
  }
  for (  File f : directory.listFiles(filter)) {
    if (f.isDirectory()) {
      if (!f.canRead() || !f.canExecute()) {
        System.err.println("Warning: Skipping directory " + f.getPath() + " due to lack of read permission");
      }
 else {
        retrieveSnapshotFiles(f,snapshots,filter,recursion++,validate);
      }
      continue;
    }
    if (!f.canRead()) {
      System.err.println("Warning: " + f.getPath() + " is not readable");
      continue;
    }
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(f);
    }
 catch (    FileNotFoundException e1) {
      System.err.println(e1.getMessage());
      continue;
    }
    try {
      if (f.getName().endsWith(".digest")) {
        Pair<Long,List<String>> result=null;
        try {
          result=retrieveRelevantTableNamesAndTime(f);
        }
 catch (        Exception e) {
          System.err.println(e.getMessage());
          System.err.println("Error: Unable to process digest " + f.getPath());
          continue;
        }
        Long snapshotTime=result.getFirst();
        Snapshot s=snapshots.get(snapshotTime);
        if (s == null) {
          s=new Snapshot();
          snapshots.put(snapshotTime,s);
        }
        TreeSet<String> tableSet=new TreeSet<String>();
        tableSet.addAll(result.getSecond());
        s.m_digestTables.add(tableSet);
        s.m_digests.add(f);
      }
 else {
        HashSet<Integer> partitionIds=new HashSet<Integer>();
        TableSaveFile saveFile=new TableSaveFile(fis.getChannel(),1,null,true);
        try {
          for (          Integer partitionId : saveFile.getPartitionIds()) {
            partitionIds.add(partitionId);
          }
          if (validate && saveFile.getCompleted()) {
            while (saveFile.hasMoreChunks()) {
              BBContainer cont=saveFile.getNextChunk();
              if (cont != null) {
                cont.discard();
              }
            }
          }
          partitionIds.removeAll(saveFile.getCorruptedPartitionIds());
          Snapshot s=snapshots.get(saveFile.getCreateTime());
          if (s == null) {
            s=new Snapshot();
            snapshots.put(saveFile.getCreateTime(),s);
          }
          TableFiles tableFiles=s.m_tableFiles.get(saveFile.getTableName());
          if (tableFiles == null) {
            tableFiles=new TableFiles(saveFile.isReplicated());
            s.m_tableFiles.put(saveFile.getTableName(),tableFiles);
          }
          tableFiles.m_files.add(f);
          tableFiles.m_completed.add(saveFile.getCompleted());
          tableFiles.m_validPartitionIds.add(partitionIds);
          tableFiles.m_corruptParititionIds.add(saveFile.getCorruptedPartitionIds());
          tableFiles.m_totalPartitionCounts.add(saveFile.getTotalPartitions());
        }
  finally {
          saveFile.close();
        }
      }
    }
 catch (    IOException e) {
      System.err.println(e.getMessage());
      System.err.println("Error: Unable to process " + f.getPath());
    }
 finally {
      try {
        if (fis != null) {
          fis.close();
        }
      }
 catch (      IOException e) {
      }
    }
  }
}
