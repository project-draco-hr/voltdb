{
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  boolean snapshotConsistent=true;
  String indentString="";
  pw.println(indentString + "Date: " + new Date(snapshotTime));
  pw.println(indentString + "Digests:");
  indentString="\t";
  TreeSet<String> digestTablesSeen=new TreeSet<String>();
  if (snapshot.m_digests.isEmpty()) {
    pw.println(indentString + "No digests found.");
    snapshotConsistent=false;
  }
 else {
    boolean inconsistent=false;
    Map<Integer,List<Integer>> inconsistentDigests=new HashMap<Integer,List<Integer>>();
    for (int ii=0; ii < snapshot.m_digests.size(); ii++) {
      inconsistentDigests.put(ii,new ArrayList<Integer>());
      Set<String> tables=snapshot.m_digestTables.get(ii);
      for (int zz=0; zz < snapshot.m_digests.size(); zz++) {
        if (zz == ii) {
          continue;
        }
        if (!tables.equals(snapshot.m_digestTables.get(zz))) {
          snapshotConsistent=false;
          inconsistent=true;
          inconsistentDigests.get(ii).add(zz);
        }
      }
    }
    if (!inconsistent) {
      for (int ii=0; ii < snapshot.m_digests.size(); ii++) {
        pw.println(indentString + snapshot.m_digests.get(ii).getPath());
      }
    }
 else {
      pw.println(indentString + "Not all digests are consistent");
      indentString=indentString + "\t";
      for (      Map.Entry<Integer,List<Integer>> entry : inconsistentDigests.entrySet()) {
        File left=snapshot.m_digests.get(entry.getKey());
        pw.println(indentString + left.getPath() + " is inconsistent with:");
        indentString=indentString + "\t";
        for (        Integer id : entry.getValue()) {
          File right=snapshot.m_digests.get(id);
          pw.println(indentString + right.getPath());
        }
        indentString=indentString.substring(1);
      }
    }
    indentString=indentString.substring(1);
    pw.print(indentString + "Tables: ");
    int ii=0;
    for (int jj=0; jj < snapshot.m_digestTables.size(); jj++) {
      for (      String table : snapshot.m_digestTables.get(jj)) {
        digestTablesSeen.add(table);
      }
    }
    for (    String table : digestTablesSeen) {
      if (ii != 0) {
        pw.print(", ");
      }
      ii++;
      pw.print(table);
    }
    pw.print("\n");
  }
  Integer totalPartitionCount=null;
  indentString=indentString + "\t";
  for (  Map.Entry<String,TableFiles> entry : snapshot.m_tableFiles.entrySet()) {
    if (entry.getValue().m_isReplicated) {
      continue;
    }
    for (    Integer partitionCount : entry.getValue().m_totalPartitionCounts) {
      if (totalPartitionCount == null) {
        totalPartitionCount=partitionCount;
      }
 else       if (totalPartitionCount != partitionCount) {
        snapshotConsistent=false;
        pw.println(indentString + "Partition count is not consistent throughout snapshot files for " + entry.getKey()+ ". Saw "+ partitionCount+ " and "+ totalPartitionCount);
      }
    }
  }
  TreeSet<String> consistentTablesSeen=new TreeSet<String>();
  for (  Map.Entry<String,TableFiles> entry : snapshot.m_tableFiles.entrySet()) {
    TableFiles tableFiles=entry.getValue();
    TreeSet<Integer> partitionsAvailable=new TreeSet<Integer>();
    for (    Set<Integer> validPartitionIds : tableFiles.m_validPartitionIds) {
      partitionsAvailable.addAll(validPartitionIds);
    }
    boolean partitionsPresent=false;
    if ((partitionsAvailable.size() == totalPartitionCount) && (partitionsAvailable.first() == 0) && (partitionsAvailable.last() == totalPartitionCount - 1)) {
      partitionsPresent=true;
    }
 else     if (!tableFiles.m_isReplicated) {
      snapshotConsistent=false;
    }
    boolean hasCorruptPartitions=false;
    for (    Set<Integer> corruptIds : tableFiles.m_corruptParititionIds) {
      if (!corruptIds.isEmpty()) {
        hasCorruptPartitions=true;
        snapshotConsistent=false;
      }
    }
    pw.println(indentString + "Table name: " + entry.getKey());
    indentString=indentString + "\t";
    pw.println(indentString + "Replicated: " + entry.getValue().m_isReplicated);
    pw.println(indentString + "Valid partition set available: " + partitionsPresent);
    if (hasCorruptPartitions) {
      pw.println("Corrupt partitions may prevent a restore even if the data " + "is intact and still available in some replica file. This is being work on.");
    }
    pw.println(indentString + "Corrupt partitions present: " + hasCorruptPartitions);
    pw.println(indentString + "Files: ");
    indentString=indentString + "\t";
    for (int ii=0; ii < tableFiles.m_files.size(); ii++) {
      String corruptPartitionIdString="";
      int zz=0;
      for (      Integer partitionId : tableFiles.m_corruptParititionIds.get(ii)) {
        if (zz != 0) {
          corruptPartitionIdString=corruptPartitionIdString + ", ";
        }
        zz++;
        corruptPartitionIdString=corruptPartitionIdString + partitionId;
      }
      String validPartitionIdString="";
      zz=0;
      for (      Integer partitionId : tableFiles.m_validPartitionIds.get(ii)) {
        if (zz != 0) {
          validPartitionIdString=validPartitionIdString + ", ";
        }
        zz++;
        validPartitionIdString=validPartitionIdString + partitionId;
      }
      if (corruptPartitionIdString.isEmpty()) {
        consistentTablesSeen.add(entry.getKey());
        pw.println(indentString + tableFiles.m_files.get(ii).getPath() + " Partitions: "+ validPartitionIdString);
      }
 else {
        pw.println(indentString + tableFiles.m_files.get(ii).getPath() + " Valid Partitions: "+ validPartitionIdString+ " Corrupt Partitions: "+ corruptPartitionIdString);
      }
    }
    indentString=indentString.substring(2);
  }
  indentString=indentString.substring(1);
  if (snapshotConsistent) {
    return Pair.of(true,"Snapshot valid\n" + sw.toString());
  }
 else {
    return Pair.of(false,"Snapshot corrupted\n" + sw.toString());
  }
}
