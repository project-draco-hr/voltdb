{
  Set<? extends Class<?>> supers=TypeToken.of(clazz).getTypes().rawTypes();
  Map<MethodIdentifier,Method> identifiers=Maps.newHashMap();
  for (  Class<?> superClazz : supers) {
    for (    Method superClazzMethod : superClazz.getMethods()) {
      if (superClazzMethod.isAnnotationPresent(Subscribe.class)) {
        Class<?>[] parameterTypes=superClazzMethod.getParameterTypes();
        if (parameterTypes.length != 1) {
          throw new IllegalArgumentException("Method " + superClazzMethod + " has @Subscribe annotation, but requires "+ parameterTypes.length+ " arguments.  Event subscriber methods must require a single argument.");
        }
        MethodIdentifier ident=new MethodIdentifier(superClazzMethod);
        if (!identifiers.containsKey(ident)) {
          identifiers.put(ident,superClazzMethod);
        }
      }
    }
  }
  return ImmutableList.copyOf(identifiers.values());
}
