{
  SiteTracker tracker=m_catalogContext.siteTracker;
  if (!m_partitionDetectionEnabled) {
    return newFaults;
  }
  if (newFaults.get(FaultType.NODE_FAILURE) == null) {
    return newFaults;
  }
  if (m_triggeredPartitionDetection) {
    return null;
  }
  HashSet<VoltFault> knownnfs=m_knownFaults.get(FaultType.NODE_FAILURE);
  final int prevSurvivorCnt=tracker.getAllLiveHosts().size();
  final int ttlNodeFaults=knownnfs.size();
  boolean blessedSet=true;
  if (ttlNodeFaults * 2 == prevSurvivorCnt) {
    Integer blessedHost=tracker.getHostForSite(tracker.getLowestLiveNonExecSiteId());
    for (    VoltFault fault : knownnfs) {
      if (fault instanceof NodeFailureFault) {
        NodeFailureFault nf=(NodeFailureFault)fault;
        if (nf.getHostId() == blessedHost) {
          blessedSet=false;
          break;
        }
      }
    }
  }
  if (!blessedSet || (ttlNodeFaults * 2 > prevSurvivorCnt)) {
    HashSet<VoltFault> ppdFaults=new HashSet<VoltFault>();
    HashSet<VoltFault> newnfs=newFaults.get(FaultType.NODE_FAILURE);
    for (    VoltFault nf : newnfs) {
      VoltFault ppd=new ClusterPartitionFault((NodeFailureFault)nf);
      ppdFaults.add(ppd);
    }
    newFaults.put(FaultType.CLUSTER_PARTITION,ppdFaults);
    newFaults.remove(FaultType.NODE_FAILURE);
    m_triggeredPartitionDetection=true;
  }
  return newFaults;
}
