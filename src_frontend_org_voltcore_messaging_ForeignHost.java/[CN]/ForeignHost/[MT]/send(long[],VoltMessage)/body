{
  if (destinations.length == 0) {
    return;
  }
  StackTraceElement[] stack=Thread.currentThread().getStackTrace();
  String stackTrace="Calling ForeignHost.send()\n";
  for (  StackTraceElement ste : stack) {
    stackTrace+="    at " + ste.toString() + "\n";
  }
  final String trace=stackTrace.intern();
  m_connection.writeStream().enqueue(new DeferredSerialization(){
    @Override public final ByteBuffer[] serialize() throws IOException {
      try {
        int len=4 + 8 + 4+ 8 * destinations.length + message.getSerializedSize();
        ByteBuffer buf=ByteBuffer.allocate(len);
        buf.putInt(len - 4);
        buf.putLong(message.m_sourceHSId);
        buf.putInt(destinations.length);
        for (int ii=0; ii < destinations.length; ii++) {
          buf.putLong(destinations[ii]);
        }
        message.flattenToBuffer(buf);
        buf.flip();
        return new ByteBuffer[]{buf};
      }
 catch (      RuntimeException rt) {
        hostLog.warn(trace);
        throw rt;
      }
    }
    @Override public final void cancel(){
    }
  }
);
  long current_time=EstTime.currentTimeMillis();
  long current_delta=current_time - m_lastMessageMillis.get();
  if (current_delta > 10 * 1000) {
    rateLimitedLogger.log("Have not received a message from host " + hostname() + " for "+ (current_delta / 1000.0)+ " seconds",current_time);
  }
  if ((!m_closing && m_isUp) && (current_delta > m_deadHostTimeout)) {
    hostLog.error("DEAD HOST DETECTED, hostname: " + hostname());
    hostLog.info("\tcurrent time: " + current_time);
    hostLog.info("\tlast message: " + m_lastMessageMillis);
    hostLog.info("\tdelta (millis): " + current_delta);
    hostLog.info("\ttimeout value (millis): " + m_deadHostTimeout);
    VoltDB.dropStackTrace("Timed out foreign host " + hostname() + " with delta "+ current_delta);
    m_hostMessenger.reportForeignHostFailed(m_hostId);
  }
}
