{
  int[] pkeyIndexes=table.getPkeyColumnIndexes();
  Set<Tuple> pkeyValues=new HashSet<Tuple>();
  Map<Integer,Set<Object>> uniqueValues=new TreeMap<Integer,Set<Object>>();
  for (int col=0; col < table.getColumnCount(); col++) {
    if (table.getColumnUniqueness(col)) {
      uniqueValues.put(col,new HashSet<Object>());
    }
  }
  for (int i=0; i < rowCount; i++) {
    Object[] row=new Object[table.getColumnCount()];
    Tuple pkey=new Tuple(pkeyIndexes.length);
    boolean success=false;
    trynewrow:     while (!success) {
      for (int col=0; col < table.getColumnCount(); col++) {
        boolean allowNulls=table.getColumnNullable(col);
        int size=table.getColumnMaxSize(col);
        if (size > maxStringSize)         size=maxStringSize;
        double nullFraction=allowNulls ? 0.05 : 0.0;
        row[col]=VoltTypeUtil.getRandomValue(table.getColumnType(col),size,nullFraction,rand);
        int pkeyIndex=ArrayUtils.indexOf(pkeyIndexes,col);
        if (pkeyIndex != -1) {
          pkey.values[pkeyIndex]=row[col];
        }
      }
      if (pkeyIndexes.length > 0) {
        if (pkeyValues.contains(pkey)) {
          System.err.println("randomFill: skipping tuple because of pkey violation");
          continue trynewrow;
        }
      }
      for (int col=0; col < table.getColumnCount(); col++) {
        Set<Object> uniqueColValues=uniqueValues.get(col);
        if (uniqueColValues != null) {
          if (uniqueColValues.contains(row[col])) {
            System.err.println("randomFill: skipping tuple because of uniqe col violation");
            continue trynewrow;
          }
        }
      }
      if (pkeyIndexes.length > 0) {
        pkeyValues.add(pkey);
      }
      for (int col=0; col < table.getColumnCount(); col++) {
        Set<Object> uniqueColValues=uniqueValues.get(col);
        if (uniqueColValues != null) {
          uniqueColValues.add(row[col]);
        }
      }
      table.addRow(row);
      success=true;
    }
  }
}
