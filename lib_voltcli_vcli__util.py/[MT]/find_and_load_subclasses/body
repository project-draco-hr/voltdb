def find_and_load_subclasses(base_class, base_dirs, sub_dir, **kwargs):
    '\n    Look for python modules in a named subdirectory of a set of base\n    directories. Load any modules found and find all classes derived from the\n    specified base class. Return the classes found. Classes should implement\n    a __cmp__() method to properly support duplicate detection.\n    '
    found = []
    processed_dirs = set()
    for base_dir in base_dirs:
        scan_dir = os.path.realpath(os.path.join(base_dir, sub_dir))
        if (scan_dir not in processed_dirs):
            processed_dirs.add(scan_dir)
            if os.path.exists(scan_dir):
                for modpath in glob.glob(os.path.join(scan_dir, '*.py')):
                    filename = os.path.basename(modpath)
                    name = os.path.splitext(filename)[0]
                    syms = copy.copy(kwargs)
                    before = set(syms.keys())
                    execfile(modpath, syms)
                    after = set(syms)
                    for name in after.difference(before):
                        if (not name.startswith('_')):
                            o = syms[name]
                            if (inspect.isclass(o) and issubclass(o, base_class)):
                                subclass = o()
                                for (subclass2, modpath2) in found:
                                    if (subclass2 == subclass):
                                        warning(('Ignoring class "%s" in "%s"' % (o.__name__, modpath)), [('It conflicts with "%s" in "%s".' % (subclass2.__class__.__name__, modpath2)), 'Check metadata for conflicting identifier.'])
                                        break
                                else:
                                    found.append((subclass, modpath))
    return [subclass for (subclass, modpath) in found]
