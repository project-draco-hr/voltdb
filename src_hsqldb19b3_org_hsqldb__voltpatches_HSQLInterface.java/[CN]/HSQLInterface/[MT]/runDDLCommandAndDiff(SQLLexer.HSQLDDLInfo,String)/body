{
  Set<String> existingTableNames=null;
  if (stmtInfo.cascade) {
    existingTableNames=getTableNames();
  }
  String expectedTableAffected=null;
  if (stmtInfo.noun == HSQLDDLNoun.INDEX) {
    if (stmtInfo.verb == HSQLDDLVerb.CREATE) {
      expectedTableAffected=stmtInfo.secondName;
    }
 else {
      expectedTableAffected=tableNameForIndexName(stmtInfo.name);
      if ((expectedTableAffected == null) && (stmtInfo.verb == HSQLDDLVerb.DROP)) {
        return null;
      }
    }
    assert(expectedTableAffected != null);
  }
 else {
    expectedTableAffected=stmtInfo.name;
  }
  runDDLCommand(ddl);
  VoltXMLElement tableXMLNew=getXMLForTable(expectedTableAffected);
  VoltXMLElement tableXMLOld=lastSchema.get(expectedTableAffected);
  if (tableXMLNew == null) {
    tableXMLNew=emptySchema;
  }
  if (tableXMLOld == null) {
    tableXMLOld=emptySchema;
  }
  VoltXMLDiff diff=VoltXMLElement.computeDiff(tableXMLOld,tableXMLNew);
  if (stmtInfo.cascade) {
    Set<String> finalTableNames=getTableNames();
    for (    String tableName : existingTableNames) {
      if (!finalTableNames.contains(tableName)) {
        tableName=tableName.toLowerCase();
        tableXMLOld=lastSchema.get(tableName).children.get(0);
        lastSchema.remove(tableName);
        if (tableName.equals(expectedTableAffected)) {
          continue;
        }
        diff.m_removedElements.add(tableXMLOld);
      }
    }
  }
  diff.m_elementOrder.clear();
  lastSchema.put(expectedTableAffected,tableXMLNew.duplicate());
  return diff;
}
