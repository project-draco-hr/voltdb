{
  try {
    apph.add("displayinterval","display_interval_in_seconds","Interval for performance feedback, in seconds.",10).add("duration","run_duration_in_seconds","Benchmark duration, in seconds.",120).add("servers","comma_separated_server_list","List of VoltDB servers to connect to.","localhost").add("port","port_number","Client port to connect to on cluster nodes.",21212).add("poolsize","pool_size","Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).",100000).add("preload","preload","Whether the data store should be initialized with default values before the benchmark is run (true|false).",true).add("getputratio","get_put_ratio","Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1",0.95).add("keysize","key_size","Size of the keys in number of characters. Max: 250",50).add("minvaluesize","min_value_size","Minimum size for the value blob (in bytes, uncompressed). Max: 1048576",1000).add("maxvaluesize","max_value_size","Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576",1000).add("entropy","entropy","How compressible the payload should be, lower is more compressible",127).add("usecompression","use_compression","Whether value blobs should be compressed (GZip) for storage in the database (true|false).",false).add("ratelimit","rate_limit","Rate limit to start from (number of transactions per second).",100000).add("autotune","auto_tune","Flag indicating whether the benchmark should self-tune the transaction rate for a target execution latency (true|false).","true").add("latencytarget","latency_target","Execution latency to target to tune transaction rate (in milliseconds).",10.0d).setArguments(args);
    long displayInterval=apph.longValue("displayinterval");
    long duration=apph.longValue("duration");
    String servers=apph.stringValue("servers");
    int port=apph.intValue("port");
    double getPutRatio=apph.doubleValue("getputratio");
    int poolSize=apph.intValue("poolsize");
    boolean preload=apph.booleanValue("preload");
    int keySize=apph.intValue("keysize");
    int minValueSize=apph.intValue("minvaluesize");
    int maxValueSize=apph.intValue("maxvaluesize");
    boolean useCompression=apph.booleanValue("usecompression");
    long rateLimit=apph.longValue("ratelimit");
    boolean autoTune=apph.booleanValue("autotune");
    double latencyTarget=apph.doubleValue("latencytarget");
    final String csv=apph.stringValue("statsfile");
    final int entropy=apph.intValue("entropy");
    apph.validate("duration",(duration > 0)).validate("displayinterval",(displayInterval > 0)).validate("poolsize",(poolSize > 0)).validate("getputratio",(getPutRatio >= 0) && (getPutRatio <= 1)).validate("keysize",(keySize > 0) && (keySize < 251)).validate("minvaluesize",(minValueSize > 0) && (minValueSize < 1048576)).validate("maxvaluesize",(maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize)).validate("ratelimit",(rateLimit > 0)).validate("latencytarget",(latencyTarget > 0));
    apph.printActualUsage();
    Con=ClientConnectionPool.getWithRetry(servers,port);
    final PayloadProcessor processor=new PayloadProcessor(keySize,minValueSize,maxValueSize,entropy,poolSize,useCompression);
    if (preload) {
      System.out.print("Initializing data store... ");
      for (int i=0; i < poolSize; i++) {
        Con.executeAsync(new NullCallback(),"Put",String.format(processor.KeyFormat,i),processor.generateForStore().getStoreValue());
      }
      Con.drain();
      System.out.println(" Done");
    }
    timer=new Timer();
    timer.scheduleAtFixedRate(new TimerTask(){
      @Override public void run(){
        System.out.print(Con.getStatistics("Get","Put"));
      }
    }
,displayInterval * 1000l,displayInterval * 1000l);
    IRateLimiter limiter=null;
    if (autoTune)     limiter=new LatencyLimiter(Con,"Get",latencyTarget,rateLimit);
 else     limiter=new RateLimiter(rateLimit);
    long endTime=System.currentTimeMillis() + (1000l * duration);
    Random rand=new Random();
    while (endTime > System.currentTimeMillis() && !stopTheMadness) {
      if (rand.nextDouble() < getPutRatio) {
        Con.executeAsync(new ProcedureCallback(){
          @Override public void clientCallback(          ClientResponse response) throws Exception {
            if (response.getStatus() == ClientResponse.SUCCESS) {
              final VoltTable pairData=response.getResults()[0];
              if (pairData.getRowCount() == 0)               GetStoreResults.incrementAndGet(1);
 else {
                final PayloadProcessor.Pair pair=processor.retrieveFromStore(pairData.fetchRow(0).getString(0),pairData.fetchRow(0).getVarbinary(1));
                GetStoreResults.incrementAndGet(0);
                GetCompressionResults.addAndGet(0,pair.getStoreValueLength());
                GetCompressionResults.addAndGet(1,pair.getRawValueLength());
              }
            }
 else             GetStoreResults.incrementAndGet(1);
          }
        }
,"Get",processor.generateRandomKeyForRetrieval());
      }
 else {
        final PayloadProcessor.Pair pair=processor.generateForStore();
        Con.executeAsync(new ProcedureCallback(){
          final long StoreValueLength;
          final long RawValueLength;
{
            this.StoreValueLength=pair.getStoreValueLength();
            this.RawValueLength=pair.getRawValueLength();
          }
          @Override public void clientCallback(          ClientResponse response) throws Exception {
            if (response.getStatus() == ClientResponse.CONNECTION_LOST) {
              return;
            }
            if (response.getStatus() == ClientResponse.SUCCESS) {
              PutStoreResults.incrementAndGet(0);
              final VoltTable pairData=response.getResults()[0];
              final VoltTableRow tablerow=pairData.fetchRow(0);
              final long counter=tablerow.getLong(0);
              hm.put(pair.Key,counter);
              PutCompressionResults.addAndGet(0,this.StoreValueLength);
              PutCompressionResults.addAndGet(1,this.RawValueLength);
            }
 else {
              System.err.println("Put failed because " + response.getStatusString());
              PutStoreResults.incrementAndGet(1);
            }
          }
        }
,"Put",pair.Key,pair.getStoreValue());
      }
      limiter.throttle();
    }
    timer.cancel();
    System.out.printf("\n-------------------------------------------------------------------------------------\n" + " Store Results\n" + "-------------------------------------------------------------------------------------\n\n"+ "A total of %,d operations was posted...\n"+ " - GETs: %,9d Operations (%,9d Misses/Failures)\n"+ "         %,9d MB in compressed store data\n"+ "         %,9d MB in uncompressed application data\n"+ "         Network Throughput: %6.3f Gbps*\n\n"+ " - PUTs: %,9d Operations (%,9d Failures)\n"+ "         %,9d MB in compressed store data\n"+ "         %,9d MB in uncompressed application data\n"+ "         Network Throughput: %6.3f Gbps*\n\n"+ " - Total Network Throughput: %6.3f Gbps*\n\n"+ "* Figure includes key & value traffic but not database protocol overhead.\n"+ "\n"+ "-------------------------------------------------------------------------------------\n",GetStoreResults.get(0) + GetStoreResults.get(1) + PutStoreResults.get(0)+ PutStoreResults.get(1),GetStoreResults.get(0),GetStoreResults.get(1),GetCompressionResults.get(0) / 1048576l,GetCompressionResults.get(1) / 1048576l,((double)GetCompressionResults.get(0) + (GetStoreResults.get(0) + GetStoreResults.get(1)) * keySize) / (134217728d * duration),PutStoreResults.get(0),PutStoreResults.get(1),PutCompressionResults.get(0) / 1048576l,PutCompressionResults.get(1) / 1048576l,((double)PutCompressionResults.get(0) + (PutStoreResults.get(0) + PutStoreResults.get(1)) * keySize) / (134217728d * duration),((double)GetCompressionResults.get(0) + (GetStoreResults.get(0) + GetStoreResults.get(1)) * keySize) / (134217728d * duration) + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0) + PutStoreResults.get(1)) * keySize) / (134217728d * duration));
    System.out.println("\n\n-------------------------------------------------------------------------------------\n" + " System Statistics\n" + "-------------------------------------------------------------------------------------\n\n");
    System.out.print(Con.getStatistics("Get","Put").toString(false));
    System.out.println("\n\n-------------------------------------------------------------------------------------\n" + " Detailed Statistics\n" + "-------------------------------------------------------------------------------------\n\n");
    System.out.print(Con.getStatistics().toString(false));
    Con.saveStatistics(csv);
  }
 catch (  org.voltdb.client.NoConnectionsException x) {
    System.out.println("Exception: " + x);
    System.out.println("\n\n-------------------------------------------------------------------------------------\n");
    System.out.print("Lost connection - will try to reconnect ... \n");
    Con.close();
    timer.cancel();
    try {
      Con=ClientConnectionPool.getWithRetry(apph.stringValue("servers"),apph.intValue("port"));
    }
 catch (    Exception e) {
      System.out.println("Another exception, I guess " + e);
    }
  }
catch (  Exception x) {
    System.out.println("Exception: " + x);
    x.printStackTrace();
    System.exit(1);
  }
  try {
    System.out.println("\n\n-------------------------------------------------------------------------------------\n");
    System.out.print("Check Put counts against database... \n");
    PutCountResults.set(0,0l);
    PutCountResults.set(1,0l);
    PutCountResults.set(2,0l);
    Iterator<String> it=hm.keySet().iterator();
    while (it.hasNext()) {
      String key=it.next().toString();
      Con.executeAsync(new ProcedureCallback(){
        @Override public void clientCallback(        ClientResponse response) throws Exception {
          if (response.getStatus() == ClientResponse.SUCCESS) {
            final VoltTable pairData=response.getResults()[0];
            if (pairData.getRowCount() != 0) {
              PutCountResults.incrementAndGet(0);
              final String key=pairData.fetchRow(0).getString(0);
              final long hmCount=hm.get(key);
              final long dbCount=ByteBuffer.wrap(pairData.fetchRow(0).getVarbinary(1)).getLong(0);
              if (dbCount < hmCount) {
                PutCountResults.incrementAndGet(1);
                PutCountResults.addAndGet(2,hmCount - dbCount);
                System.out.printf("ERROR: Key %s: count in db '%d' is less than client expected '%d'\n",key.replaceAll("\\s",""),dbCount,hmCount);
              }
            }
          }
 else {
            System.out.print("ERROR: Bad Client response from Volt");
            System.exit(1);
          }
        }
      }
,"Get",key);
    }
    Con.drain();
    System.out.printf("\n\t%10d\tKV Rows Checked\n",hm.size());
    System.out.printf("\t%10d\tKV Rows Found in database\n",PutCountResults.get(0));
    System.out.printf("\t%10d\tKV Rows Missing in database\n",hm.size() - PutCountResults.get(0));
    System.out.printf("\n\t%10d\tKV Rows are Correct\n",PutCountResults.get(0) - PutCountResults.get(1));
    System.out.printf("\t%10d\tKV Rows are Incorrect (off by %d Puts)\n",PutCountResults.get(1),PutCountResults.get(2));
    if (PutCountResults.get(0) == hm.size() && PutCountResults.get(1) == 0) {
      System.out.println("\n-------------------\nGood News:  Database Put counts match\n");
    }
 else {
      System.exit(1);
    }
  }
 catch (  Exception x) {
    System.out.println("This is not working: " + x);
    x.printStackTrace();
  }
}
