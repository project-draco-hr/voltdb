{
  int num_of_subtrees=5;
  final List<AbstractExpression> combine_exps=new ArrayList<AbstractExpression>();
  final Map<AbstractExpression,AbstractExpression> combine_exps_left=new HashMap<AbstractExpression,AbstractExpression>();
  final Map<AbstractExpression,AbstractExpression> combine_exps_right=new HashMap<AbstractExpression,AbstractExpression>();
  for (int ctr=0; ctr < num_of_subtrees; ctr++) {
    AbstractExpression exps[]={new ComparisonExpression(ExpressionType.COMPARE_EQUAL),new ParameterValueExpression(),new TupleValueExpression()};
    exps[0].setLeft(exps[1]);
    exps[0].setRight(exps[2]);
    combine_exps.add(exps[0]);
    combine_exps_left.put(exps[0],exps[1]);
    combine_exps_right.put(exps[0],exps[2]);
  }
  AbstractExpression combined_exp=null;
  try {
    combined_exp=ExpressionUtil.combine(combine_exps);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  assertNotNull(combined_exp);
  assertEquals(combined_exp.getExpressionType(),ExpressionType.CONJUNCTION_AND);
  new TestExpressionTreeWalker(){
    @Override public void callback(    AbstractExpression exp){
      if (combine_exps.contains(exp)) {
        assertTrue(combine_exps_left.containsKey(exp));
        TestExpressionUtil.compareExpressions(exp.getLeft(),combine_exps_left.get(exp));
        assertTrue(combine_exps_right.containsKey(exp));
        TestExpressionUtil.compareExpressions(exp.getRight(),combine_exps_right.get(exp));
        assertNotNull(this.getParent());
        assertEquals(this.getParent().getExpressionType(),ExpressionType.CONJUNCTION_AND);
      }
 else       if (exp.getExpressionType() == ExpressionType.CONJUNCTION_AND) {
        assertNotNull(exp.getLeft());
        assertNotNull(exp.getRight());
      }
    }
  }
.traverse(combined_exp);
}
