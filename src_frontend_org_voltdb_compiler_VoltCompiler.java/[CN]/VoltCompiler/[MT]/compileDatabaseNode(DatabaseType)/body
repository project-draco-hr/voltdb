{
  final ArrayList<String> programs=new ArrayList<String>();
  final ArrayList<String> schemas=new ArrayList<String>();
  final ArrayList<ProcedureDescriptor> procedures=new ArrayList<ProcedureDescriptor>();
  final ArrayList<Class<?>> classDependencies=new ArrayList<Class<?>>();
  final TablePartitionMap partitionMap=new TablePartitionMap(this);
  final String databaseName=database.getName();
  if (databaseName.equals("database") == false) {
    final String msg="VoltDB currently requires all database elements to be named " + "\"database\" (found: \"" + databaseName + "\")";
    throw new VoltCompilerException(msg);
  }
  m_catalog.execute("add /clusters[cluster] databases " + databaseName);
  Database db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
  for (  SchemasType.Schema schema : database.getSchemas().getSchema()) {
    compilerLog.l7dlog(Level.INFO,LogKeys.compiler_VoltCompiler_CatalogPath.name(),new Object[]{schema.getPath()},null);
    schemas.add(schema.getPath());
  }
  if (database.getGroups() != null) {
    for (    GroupsType.Group group : database.getGroups().getGroup()) {
      org.voltdb.catalog.Group catGroup=db.getGroups().add(group.getName());
      catGroup.setAdhoc(group.isAdhoc());
      catGroup.setSysproc(group.isSysproc());
      catGroup.setDefaultproc(group.isDefaultproc());
    }
  }
  if (database.getProcedures() != null) {
    for (    ProceduresType.Procedure proc : database.getProcedures().getProcedure()) {
      procedures.add(getProcedure(proc));
    }
  }
  if (database.getClassdependencies() != null) {
    for (    Classdependency dep : database.getClassdependencies().getClassdependency()) {
      classDependencies.add(getClassDependency(dep));
    }
  }
  if (database.getPartitions() != null) {
    for (    org.voltdb.compiler.projectfile.PartitionsType.Partition table : database.getPartitions().getPartition()) {
      partitionMap.put(table.getTable(),table.getColumn());
    }
  }
  m_hsql=HSQLInterface.loadHsqldb();
  for (  final String programName : programs) {
    m_catalog.execute("add " + db.getPath() + " programs "+ programName);
  }
  final DDLCompiler ddlcompiler=new DDLCompiler(this,m_hsql,partitionMap);
  for (  final String schemaPath : schemas) {
    File schemaFile=null;
    if (schemaPath.contains(".jar!")) {
      String ddlText=null;
      try {
        ddlText=readFileFromJarfile(schemaPath);
      }
 catch (      final Exception e) {
        throw new VoltCompilerException(e);
      }
      schemaFile=VoltProjectBuilder.writeStringToTempFile(ddlText);
    }
 else {
      schemaFile=new File(schemaPath);
    }
    if (!schemaFile.isAbsolute()) {
      schemaFile=new File(new File(m_projectFileURL).getParent(),schemaPath);
    }
    m_ddlFilePaths.put(schemaFile.getName(),schemaFile.getPath());
    ddlcompiler.loadSchema(schemaFile.getAbsolutePath());
  }
  ddlcompiler.compileToCatalog(m_catalog,db);
  String msg="In database \"" + databaseName + "\", ";
  final CatalogMap<Table> tables=db.getTables();
  for (  String tableName : partitionMap.m_map.keySet()) {
    String colName=partitionMap.m_map.get(tableName);
    if (colName != null) {
      final Table t=tables.getIgnoreCase(tableName);
      if (t == null) {
        msg+="PARTITION has unknown TABLE '" + tableName + "'";
        throw new VoltCompilerException(msg);
      }
      final Column c=t.getColumns().getIgnoreCase(colName);
      if (c == null) {
        msg+="PARTITION has unknown COLUMN '" + colName + "'";
        throw new VoltCompilerException(msg);
      }
      if (c.getNullable() == true) {
        msg+="Partition column '" + tableName + "."+ colName+ "' is nullable. "+ "Partition columns must be constrained \"NOT NULL\".";
        throw new VoltCompilerException(msg);
      }
      VoltType pcolType=VoltType.get((byte)c.getType());
switch (pcolType) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case STRING:
        break;
default :
      msg+="Partition column '" + tableName + "."+ colName+ "' is not a valid type. "+ "Partition columns must be an integer or varchar type.";
    throw new VoltCompilerException(msg);
}
t.setPartitioncolumn(c);
t.setIsreplicated(false);
final CatalogMap<MaterializedViewInfo> views=t.getViews();
for (final MaterializedViewInfo mvi : views) {
  mvi.getDest().setIsreplicated(false);
  setGroupedTablePartitionColumn(mvi,c);
}
}
}
String catData=m_catalog.serialize();
m_catalog=new Catalog();
m_catalog.execute(catData);
db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
addDatabaseEstimatesInfo(m_estimates,db);
if (database.getExport() != null) {
ExportType export=database.getExport();
compileExport(export,db);
}
List<ProcedureDescriptor> autoCrudProcedures=generateCrud(m_catalog);
procedures.addAll(autoCrudProcedures);
for (final ProcedureDescriptor procedureDescriptor : procedures) {
final String procedureName=procedureDescriptor.m_className;
if (procedureDescriptor.m_singleStmt == null) {
m_currentFilename=procedureName.substring(procedureName.lastIndexOf('.') + 1);
m_currentFilename+=".class";
}
 else {
m_currentFilename=procedureName;
}
ProcedureCompiler.compile(this,m_hsql,m_estimates,m_catalog,db,procedureDescriptor);
}
for (final Class<?> classDependency : classDependencies) {
addClassToJar(classDependency,this);
}
}
