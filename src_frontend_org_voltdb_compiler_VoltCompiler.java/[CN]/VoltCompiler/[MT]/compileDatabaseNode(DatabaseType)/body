{
  final ArrayList<String> programs=new ArrayList<String>();
  final ArrayList<String> schemas=new ArrayList<String>();
  final ArrayList<ProcedureDescriptor> procedures=new ArrayList<ProcedureDescriptor>();
  final ArrayList<Class<?>> classDependencies=new ArrayList<Class<?>>();
  final ArrayList<String[]> partitions=new ArrayList<String[]>();
  final String databaseName=database.getName();
  if (databaseName.equals("database") == false) {
    final String msg="VoltDB currently requires all database elements to be named " + "\"database\" (found: \"" + databaseName + "\")";
    throw new VoltCompilerException(msg);
  }
  m_catalog.execute("add /clusters[cluster] databases " + databaseName);
  Database db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
  for (  SchemasType.Schema schema : database.getSchemas().getSchema()) {
    compilerLog.l7dlog(Level.INFO,LogKeys.compiler_VoltCompiler_CatalogPath.name(),new Object[]{schema.getPath()},null);
    schemas.add(schema.getPath());
  }
  if (database.getGroups() != null) {
    for (    GroupsType.Group group : database.getGroups().getGroup()) {
      org.voltdb.catalog.Group catGroup=db.getGroups().add(group.getName());
      catGroup.setAdhoc(group.isAdhoc());
      catGroup.setSysproc(group.isSysproc());
    }
  }
  for (  ProceduresType.Procedure proc : database.getProcedures().getProcedure()) {
    procedures.add(getProcedure(proc));
  }
  if (database.getClassdependencies() != null) {
    for (    Classdependency dep : database.getClassdependencies().getClassdependency()) {
      classDependencies.add(getClassDependency(dep));
    }
  }
  if (database.getPartitions() != null) {
    for (    org.voltdb.compiler.projectfile.PartitionsType.Partition table : database.getPartitions().getPartition()) {
      partitions.add(getPartition(table));
    }
  }
  String msg="Database \"" + databaseName + "\" ";
  if (procedures.size() == 0) {
    msg+="needs at least one \"procedure\" element " + "(currently has " + String.valueOf(procedures.size()) + ")";
    throw new VoltCompilerException(msg);
  }
  if (procedures.size() < 1) {
    msg+="is missing the \"procedures\" element";
    throw new VoltCompilerException(msg);
  }
  m_hsql=HSQLInterface.loadHsqldb();
  for (  final String programName : programs) {
    m_catalog.execute("add " + db.getPath() + " programs "+ programName);
  }
  final DDLCompiler ddlcompiler=new DDLCompiler(this,m_hsql);
  for (  final String schemaPath : schemas) {
    File schemaFile=null;
    if (schemaPath.contains(".jar!")) {
      String ddlText=null;
      try {
        ddlText=readFileFromJarfile(schemaPath);
      }
 catch (      final Exception e) {
        throw new VoltCompilerException(e);
      }
      schemaFile=VoltProjectBuilder.writeStringToTempFile(ddlText);
    }
 else {
      schemaFile=new File(schemaPath);
    }
    if (!schemaFile.isAbsolute()) {
      schemaFile=new File(new File(m_projectFileURL).getParent(),schemaPath);
    }
    m_ddlFilePaths.put(schemaFile.getName(),schemaFile.getPath());
    ddlcompiler.loadSchema(schemaFile.getAbsolutePath());
  }
  ddlcompiler.compileToCatalog(m_catalog,db);
  msg="In database \"" + databaseName + "\", ";
  final CatalogMap<Table> tables=db.getTables();
  for (  final String[] partition : partitions) {
    final String tableName=partition[0];
    final String colName=partition[1];
    final Table t=tables.getIgnoreCase(tableName);
    if (t == null) {
      msg+="\"partition\" element has unknown \"table\" attribute '" + tableName + "'";
      throw new VoltCompilerException(msg);
    }
    final Column c=t.getColumns().getIgnoreCase(colName);
    if (c == null) {
      msg+="\"partition\" element has unknown \"column\" attribute '" + colName + "'";
      throw new VoltCompilerException(msg);
    }
    if (c.getNullable() == true) {
      msg+="Partition column '" + tableName + "."+ colName+ "' is nullable. "+ "Partition columns must be constrained \"NOT NULL\".";
      throw new VoltCompilerException(msg);
    }
    VoltType pcolType=VoltType.get((byte)c.getType());
switch (pcolType) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case STRING:
      break;
default :
    msg+="Partition column '" + tableName + "."+ colName+ "' is not a valid type. "+ "Partition columns must be an integer or varchar type.";
  throw new VoltCompilerException(msg);
}
t.setPartitioncolumn(c);
t.setIsreplicated(false);
final CatalogMap<MaterializedViewInfo> views=t.getViews();
for (final MaterializedViewInfo mvi : views) {
mvi.getDest().setIsreplicated(false);
}
}
String catData=m_catalog.serialize();
m_catalog=new Catalog();
m_catalog.execute(catData);
db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
addDatabaseEstimatesInfo(m_estimates,db);
if (database.getExport() != null) {
ExportType export=database.getExport();
compileExport(export,db);
}
for (final ProcedureDescriptor procedureDescriptor : procedures) {
final String procedureName=procedureDescriptor.m_className;
if (procedureDescriptor.m_singleStmt == null) {
m_currentFilename=procedureName.substring(procedureName.lastIndexOf('.') + 1);
m_currentFilename+=".class";
}
 else {
m_currentFilename=procedureName;
}
ProcedureCompiler.compile(this,m_hsql,m_estimates,m_catalog,db,procedureDescriptor);
}
for (final Class<?> classDependency : classDependencies) {
addClassToJar(classDependency,this);
}
m_hsql.close();
}
