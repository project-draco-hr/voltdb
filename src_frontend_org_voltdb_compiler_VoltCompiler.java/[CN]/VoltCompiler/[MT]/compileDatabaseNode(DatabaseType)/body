{
  final ArrayList<String> programs=new ArrayList<String>();
  final ArrayList<String> schemas=new ArrayList<String>();
  final ArrayList<ProcedureDescriptor> procedures=new ArrayList<ProcedureDescriptor>();
  final ArrayList<Class<?>> classDependencies=new ArrayList<Class<?>>();
  final ArrayList<String[]> partitions=new ArrayList<String[]>();
  final String databaseName=database.getName();
  if (databaseName.equals("database") == false) {
    final String msg="VoltDB currently requires all database elements to be named " + "\"database\" (found: \"" + databaseName + "\")";
    throw new VoltCompilerException(msg);
  }
  m_catalog.execute("add /clusters[cluster] databases " + databaseName);
  Database db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
  SnapshotType snapshotSettings=database.getSnapshot();
  if (snapshotSettings != null) {
    SnapshotSchedule schedule=db.getSnapshotschedule().add("default");
    String frequency=snapshotSettings.getFrequency();
    if (!frequency.endsWith("s") && !frequency.endsWith("m") && !frequency.endsWith("h")) {
      throw new VoltCompilerException("Snapshot frequency " + frequency + " needs to end with time unit specified"+ " that is one of [s, m, h] (seconds, minutes, hours)");
    }
    int frequencyInt=0;
    String frequencySubstring=frequency.substring(0,frequency.length() - 1);
    try {
      frequencyInt=Integer.parseInt(frequencySubstring);
    }
 catch (    Exception e) {
      throw new VoltCompilerException("Frequency " + frequencySubstring + " is not an integer ");
    }
    String prefix=snapshotSettings.getPrefix();
    if (prefix == null || prefix.isEmpty()) {
      throw new VoltCompilerException("Snapshot prefix " + prefix + " is not a valid prefix ");
    }
    if (prefix.contains("-") || prefix.contains(",")) {
      throw new VoltCompilerException("Snapshot prefix " + prefix + " cannot include , or - ");
    }
    String path=snapshotSettings.getPath();
    if (path == null || path.isEmpty()) {
      throw new VoltCompilerException("Snapshot path " + path + " is not a valid path ");
    }
    if (snapshotSettings.getRetain() == null) {
      throw new VoltCompilerException("Snapshot retain value not provided");
    }
    int retain=snapshotSettings.getRetain().intValue();
    if (retain < 1) {
      throw new VoltCompilerException("Snapshot retain value " + retain + " is not a valid value. Must be 1 or greater.");
    }
    schedule.setFrequencyunit(frequency.substring(frequency.length() - 1,frequency.length()));
    schedule.setFrequencyvalue(frequencyInt);
    schedule.setPath(path);
    schedule.setPrefix(prefix);
    schedule.setRetain(retain);
  }
  for (  SchemasType.Schema schema : database.getSchemas().getSchema()) {
    compilerLog.l7dlog(Level.INFO,LogKeys.compiler_VoltCompiler_CatalogPath.name(),new Object[]{schema.getPath()},null);
    schemas.add(schema.getPath());
  }
  if (database.getGroups() != null) {
    for (    GroupsType.Group group : database.getGroups().getGroup()) {
      org.voltdb.catalog.Group catGroup=db.getGroups().add(group.getName());
      catGroup.setAdhoc(group.isAdhoc());
      catGroup.setSysproc(group.isSysproc());
    }
  }
  if (database.getUsers() != null) {
    for (    UsersType.User user : database.getUsers().getUser()) {
      org.voltdb.catalog.User catUser=db.getUsers().add(user.getName());
      catUser.setAdhoc(user.isAdhoc());
      catUser.setSysproc(user.isSysproc());
      byte passwordHash[]=extractPassword(user.getPassword());
      catUser.setShadowpassword(Encoder.hexEncode(passwordHash));
      if (user.getGroups() != null) {
        String grouplist[]=user.getGroups().split(",");
        for (        final String group : grouplist) {
          final GroupRef groupRef=catUser.getGroups().add(group);
          final Group catalogGroup=db.getGroups().get(group);
          if (catalogGroup != null) {
            groupRef.setGroup(catalogGroup);
          }
        }
      }
    }
  }
  for (  ProceduresType.Procedure proc : database.getProcedures().getProcedure()) {
    procedures.add(getProcedure(proc));
  }
  if (database.getClassdependencies() != null) {
    for (    Classdependency dep : database.getClassdependencies().getClassdependency()) {
      classDependencies.add(getClassDependency(dep));
    }
  }
  if (database.getPartitions() != null) {
    for (    org.voltdb.compiler.projectfile.PartitionsType.Partition table : database.getPartitions().getPartition()) {
      partitions.add(getPartition(table));
    }
  }
  String msg="Database \"" + databaseName + "\" ";
  if (procedures.size() == 0) {
    msg+="needs at least one \"procedure\" element " + "(currently has " + String.valueOf(procedures.size()) + ")";
    throw new VoltCompilerException(msg);
  }
  if (procedures.size() < 1) {
    msg+="is missing the \"procedures\" element";
    throw new VoltCompilerException(msg);
  }
  m_hsql=HSQLInterface.loadHsqldb();
  for (  final String programName : programs) {
    m_catalog.execute("add " + db.getPath() + " programs "+ programName);
  }
  final DDLCompiler ddlcompiler=new DDLCompiler(this,m_hsql);
  for (  final String schemaPath : schemas) {
    File schemaFile=null;
    if (schemaPath.contains(".jar!")) {
      String ddlText=null;
      try {
        ddlText=JarReader.readFileFromJarfile(schemaPath);
      }
 catch (      final Exception e) {
        throw new VoltCompilerException(e);
      }
      schemaFile=VoltProjectBuilder.writeStringToTempFile(ddlText);
    }
 else {
      schemaFile=new File(schemaPath);
    }
    if (!schemaFile.isAbsolute()) {
      schemaFile=new File(new File(m_projectFileURL).getParent(),schemaPath);
    }
    m_ddlFilePaths.put(schemaFile.getName(),schemaFile.getPath());
    ddlcompiler.loadSchema(schemaFile.getAbsolutePath());
  }
  ddlcompiler.compileToCatalog(m_catalog,db);
  msg="In database \"" + databaseName + "\", ";
  final CatalogMap<Table> tables=db.getTables();
  for (  final String[] partition : partitions) {
    final String tableName=partition[0];
    final String colName=partition[1];
    final Table t=tables.getIgnoreCase(tableName);
    if (t == null) {
      msg+="\"partition\" element has unknown \"table\" attribute '" + tableName + "'";
      throw new VoltCompilerException(msg);
    }
    final Column c=t.getColumns().getIgnoreCase(colName);
    if (c == null) {
      msg+="\"partition\" element has unknown \"column\" attribute '" + colName + "'";
      throw new VoltCompilerException(msg);
    }
    if (c.getNullable() == true) {
      msg+="Partition column '" + tableName + "."+ colName+ "' is nullable. "+ "Partition columns must be constrained \"NOT NULL\".";
      throw new VoltCompilerException(msg);
    }
    t.setPartitioncolumn(c);
    t.setIsreplicated(false);
    final CatalogMap<MaterializedViewInfo> views=t.getViews();
    for (    final MaterializedViewInfo mvi : views) {
      mvi.getDest().setIsreplicated(false);
    }
  }
  String catData=m_catalog.serialize();
  m_catalog=new Catalog();
  m_catalog.execute(catData);
  db=m_catalog.getClusters().get("cluster").getDatabases().get(databaseName);
  addDatabaseEstimatesInfo(m_estimates,db);
  try {
    addSystemProcsToCatalog(m_catalog,db);
  }
 catch (  final VoltCompilerException ex) {
    throw new RuntimeException(ex);
  }
  for (  final ProcedureDescriptor procedureDescriptor : procedures) {
    final String procedureName=procedureDescriptor.m_className;
    m_currentFilename=procedureName.substring(procedureName.lastIndexOf('.') + 1);
    m_currentFilename+=".class";
    ProcedureCompiler.compile(this,m_hsql,m_estimates,m_catalog,db,procedureDescriptor);
  }
  if (database.getExports() != null) {
    Connector conn=database.getExports().getConnector();
    compileConnector(conn,db);
  }
  for (  final Class<?> classDependency : classDependencies) {
    addClassToJar(classDependency,this);
  }
  m_hsql.close();
}
