{
  for (  Index index : t.getIndexes()) {
    if (!index.getUnique() || index.getAssumeunique()) {
      continue;
    }
    boolean contain=false;
    String jsonExpr=index.getExpressionsjson();
    if (jsonExpr.isEmpty()) {
      for (      ColumnRef cref : index.getColumns()) {
        Column col=cref.getColumn();
        if (col.equals(c)) {
          contain=true;
          break;
        }
      }
    }
 else {
      try {
        List<AbstractExpression> indexExpressions=AbstractExpression.fromJSONArrayString(jsonExpr);
        for (        AbstractExpression expr : indexExpressions) {
          if (expr instanceof TupleValueExpression && ((TupleValueExpression)expr).getColumnName().equals(c.getName())) {
            contain=true;
            break;
          }
        }
      }
 catch (      JSONException e) {
        e.printStackTrace();
        assert(false);
      }
    }
    if (!contain) {
      String indexName=index.getTypeName();
      if (indexName.startsWith("SYS_IDX_PK_") || indexName.startsWith("SYS_IDX_SYS_PK_") || indexName.startsWith("MATVIEW_PK_INDEX")) {
        indexName="PRIMARY KEY index";
      }
 else {
        indexName="unique index " + indexName;
      }
      String tableName=t.getTypeName();
      String exceptionMsg=String.format("A %s on the partitioned table %s does not " + "include the partitioning column %s. This does not guarantee uniqueness across the database " + "and can cause constraint violations when repartitioning the data. "+ "Try appending partitioning column %s to the index %s, or use the USER_UNIQUE keyword instead.",indexName,tableName,c.getName(),c.getName(),indexName);
      throw new VoltCompilerException(exceptionMsg);
    }
  }
  final CatalogMap<MaterializedViewInfo> views=t.getViews();
  for (  final MaterializedViewInfo mvi : views) {
    mvi.getDest().setIsreplicated(false);
    setGroupedTablePartitionColumn(mvi,c);
  }
}
