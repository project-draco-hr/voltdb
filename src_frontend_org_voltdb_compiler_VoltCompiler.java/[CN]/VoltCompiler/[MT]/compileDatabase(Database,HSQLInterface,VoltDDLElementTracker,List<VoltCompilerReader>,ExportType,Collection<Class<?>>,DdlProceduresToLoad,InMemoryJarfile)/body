{
  final DDLCompiler ddlcompiler=new DDLCompiler(this,hsql,voltDdlTracker,m_classLoader);
  for (  final VoltCompilerReader schemaReader : schemaReaders) {
    m_ddlFilePaths.put(schemaReader.getName(),schemaReader.getPath());
    ddlcompiler.loadSchema(schemaReader,db,whichProcs);
  }
  ddlcompiler.compileToCatalog(db);
  String msg="In database, ";
  final CatalogMap<Table> tables=db.getTables();
  for (  Table table : tables) {
    String tableName=table.getTypeName();
    if (voltDdlTracker.m_partitionMap.containsKey(tableName.toLowerCase())) {
      String colName=voltDdlTracker.m_partitionMap.get(tableName.toLowerCase());
      if (colName != null) {
        assert(tables.getIgnoreCase(tableName) != null);
        final Column partitionCol=table.getColumns().getIgnoreCase(colName);
        if (partitionCol == null) {
          msg+="PARTITION has unknown COLUMN '" + colName + "'";
          throw new VoltCompilerException(msg);
        }
        if (partitionCol.getNullable() == true) {
          msg+="Partition column '" + tableName + "."+ colName+ "' is nullable. "+ "Partition columns must be constrained \"NOT NULL\".";
          throw new VoltCompilerException(msg);
        }
        VoltType pcolType=VoltType.get((byte)partitionCol.getType());
switch (pcolType) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case STRING:
case VARBINARY:
          break;
default :
        msg+="Partition column '" + tableName + "."+ colName+ "' is not a valid type. "+ "Partition columns must be an integer or varchar type.";
      throw new VoltCompilerException(msg);
  }
  table.setPartitioncolumn(partitionCol);
  table.setIsreplicated(false);
  for (  Index index : table.getIndexes()) {
    checkValidPartitionTableIndex(index,partitionCol,tableName);
  }
  final CatalogMap<MaterializedViewInfo> views=table.getViews();
  for (  final MaterializedViewInfo mvi : views) {
    mvi.getDest().setIsreplicated(false);
    setGroupedTablePartitionColumn(mvi,partitionCol);
  }
}
}
 else {
for (Index index : table.getIndexes()) {
  if (index.getAssumeunique()) {
    String exceptionMsg=String.format("ASSUMEUNIQUE is not valid for replicated tables. Please use UNIQUE instead");
    throw new VoltCompilerException(exceptionMsg);
  }
}
}
}
addDatabaseEstimatesInfo(m_estimates,db);
for (String exportedTableName : voltDdlTracker.getExportedTables()) {
addExportTableToConnector(exportedTableName,db);
}
if (export != null) {
compileExport(export,db);
}
for (Entry<String,String> drNode : voltDdlTracker.getDRedTables().entrySet()) {
compileDRTable(drNode,db);
}
if (whichProcs != DdlProceduresToLoad.NO_DDL_PROCEDURES) {
Collection<ProcedureDescriptor> allProcs=voltDdlTracker.getProcedureDescriptors();
compileProcedures(db,hsql,allProcs,classDependencies,whichProcs,jarOutput);
}
m_addedClasses=voltDdlTracker.m_extraClassses.toArray(new String[0]);
m_importLines=voltDdlTracker.m_importLines.toArray(new String[0]);
addExtraClasses(jarOutput);
}
