{
  final DDLCompiler ddlcompiler=new DDLCompiler(this,hsql,voltDdlTracker);
  for (  final String schemaPath : schemas) {
    File schemaFile=null;
    if (schemaPath.contains(".jar!")) {
      String ddlText=null;
      try {
        ddlText=readFileFromJarfile(schemaPath);
      }
 catch (      final Exception e) {
        throw new VoltCompilerException(e);
      }
      schemaFile=VoltProjectBuilder.writeStringToTempFile(ddlText);
    }
 else {
      schemaFile=new File(schemaPath);
    }
    if (!schemaFile.isAbsolute()) {
      if (m_projectFileURL != null) {
        schemaFile=new File(new File(m_projectFileURL).getParent(),schemaPath);
      }
 else {
        schemaFile=new File(schemaPath);
      }
    }
    m_ddlFilePaths.put(schemaFile.getName(),schemaFile.getPath());
    ddlcompiler.loadSchema(schemaFile.getAbsolutePath(),db);
  }
  ddlcompiler.compileToCatalog(db);
  String msg="In database, ";
  final CatalogMap<Table> tables=db.getTables();
  for (  String tableName : voltDdlTracker.m_partitionMap.keySet()) {
    String colName=voltDdlTracker.m_partitionMap.get(tableName);
    if (colName != null) {
      final Table t=tables.getIgnoreCase(tableName);
      if (t == null) {
        msg+="PARTITION has unknown TABLE '" + tableName + "'";
        throw new VoltCompilerException(msg);
      }
      final Column c=t.getColumns().getIgnoreCase(colName);
      if (c == null) {
        msg+="PARTITION has unknown COLUMN '" + colName + "'";
        throw new VoltCompilerException(msg);
      }
      if (c.getNullable() == true) {
        msg+="Partition column '" + tableName + "."+ colName+ "' is nullable. "+ "Partition columns must be constrained \"NOT NULL\".";
        throw new VoltCompilerException(msg);
      }
      VoltType pcolType=VoltType.get((byte)c.getType());
switch (pcolType) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case STRING:
case VARBINARY:
        break;
default :
      msg+="Partition column '" + tableName + "."+ colName+ "' is not a valid type. "+ "Partition columns must be an integer or varchar type.";
    throw new VoltCompilerException(msg);
}
t.setPartitioncolumn(c);
t.setIsreplicated(false);
for (Index index : t.getIndexes()) {
  if (!index.getUnique()) {
    continue;
  }
  boolean contain=false;
  String jsonExpr=index.getExpressionsjson();
  if (jsonExpr.isEmpty()) {
    for (    ColumnRef cref : index.getColumns()) {
      Column col=cref.getColumn();
      if (col.equals(c)) {
        contain=true;
        break;
      }
    }
  }
 else {
    try {
      List<AbstractExpression> indexExpressions=AbstractExpression.fromJSONArrayString(jsonExpr);
      for (      AbstractExpression expr : indexExpressions) {
        if (expr instanceof TupleValueExpression && ((TupleValueExpression)expr).getColumnName().equals(c.getName())) {
          contain=true;
          break;
        }
      }
    }
 catch (    JSONException e) {
      e.printStackTrace();
      assert(false);
    }
  }
  if (!contain) {
    String indexName=index.getTypeName();
    if (indexName.startsWith("SYS_IDX_PK_") || indexName.startsWith("SYS_IDX_SYS_PK_") || indexName.startsWith("MATVIEW_PK_INDEX")) {
      indexName="PRIMARY KEY index";
    }
 else {
      indexName="unique index " + indexName;
    }
    String warnMsg=String.format("A %s on the partitioned table %s does not include the partitioning column %s. " + "This does not guarantee uniqueness across the database and can cause constraint violations when repartitioning the data.",indexName,tableName,c.getName());
    addWarn(warnMsg);
  }
}
final CatalogMap<MaterializedViewInfo> views=t.getViews();
for (final MaterializedViewInfo mvi : views) {
  mvi.getDest().setIsreplicated(false);
  setGroupedTablePartitionColumn(mvi,c);
}
}
}
addDatabaseEstimatesInfo(m_estimates,db);
for (String exportedTableName : voltDdlTracker.getExportedTables()) {
addExportTableToConnector(exportedTableName,db);
}
if (export != null) {
compileExport(export,db);
}
if (whichProcs != DdlProceduresToLoad.NO_DDL_PROCEDURES) {
Collection<ProcedureDescriptor> allProcs=voltDdlTracker.getProcedureDescriptors();
compileProcedures(db,hsql,allProcs,classDependencies,whichProcs);
}
m_addedClasses=voltDdlTracker.m_extraClassses;
addExtraClasses();
}
