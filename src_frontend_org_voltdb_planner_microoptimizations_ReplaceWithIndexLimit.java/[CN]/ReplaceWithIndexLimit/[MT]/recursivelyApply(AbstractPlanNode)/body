{
  assert(plan != null);
  ArrayList<AbstractPlanNode> children=new ArrayList<AbstractPlanNode>();
  for (int i=0; i < plan.getChildCount(); i++)   children.add(plan.getChild(i));
  for (  AbstractPlanNode child : children) {
    AbstractPlanNode newChild=recursivelyApply(child);
    if (newChild == child) {
      continue;
    }
    child.removeFromGraph();
    plan.addAndLinkChild(newChild);
  }
  if ((plan instanceof AggregatePlanNode) == false)   return plan;
  assert(plan.getChildCount() == 1);
  AggregatePlanNode aggplan=(AggregatePlanNode)plan;
  SortDirectionType sortDirection=SortDirectionType.INVALID;
  if (aggplan.isTableMin()) {
    sortDirection=SortDirectionType.ASC;
  }
 else   if (aggplan.isTableMax()) {
    sortDirection=SortDirectionType.DESC;
  }
 else {
    return plan;
  }
  AbstractPlanNode child=plan.getChild(0);
  AbstractExpression aggExpr=aggplan.getFirstAggregateExpression();
  if (child instanceof SeqScanPlanNode) {
    if (((SeqScanPlanNode)child).getPredicate() != null) {
      return plan;
    }
    CatalogMap<Index> allIndexes=db.getTables().get(((SeqScanPlanNode)child).getTargetTableName()).getIndexes();
    Index ret=findQualifiedIndex(allIndexes,aggExpr);
    if (ret == null) {
      return plan;
    }
 else {
      IndexScanPlanNode ispn=new IndexScanPlanNode((SeqScanPlanNode)child,aggplan,ret,sortDirection);
      LimitPlanNode lpn=new LimitPlanNode();
      lpn.setLimit(1);
      lpn.setOffset(0);
      ispn.addInlinePlanNode(lpn);
      ispn.generateOutputSchema(db);
      plan.clearChildren();
      plan.addAndLinkChild(ispn);
      return plan;
    }
  }
  if ((child instanceof IndexScanPlanNode) == false) {
    return plan;
  }
  if (((IndexScanPlanNode)child).getPredicate() != null) {
    return plan;
  }
  IndexScanPlanNode ispn=(IndexScanPlanNode)child;
  if (ispn.getLookupType() != IndexLookupType.EQ && ispn.getSearchKeyExpressions().size() != ExpressionUtil.uncombine(ispn.getEndExpression()).size()) {
    return plan;
  }
  if (sortDirection == SortDirectionType.DESC && ispn.getSortDirection() == SortDirectionType.INVALID) {
    return plan;
  }
  Index origIndex=ispn.getCatalogIndex();
  List<AbstractExpression> exprs=ExpressionUtil.uncombine(ispn.getEndExpression());
  if (!checkIndex(origIndex,aggExpr,exprs)) {
    return plan;
  }
 else {
    ispn.setSortDirection(sortDirection);
    LimitPlanNode lpn=new LimitPlanNode();
    lpn.setLimit(1);
    lpn.setOffset(0);
    ispn.addInlinePlanNode(lpn);
    plan.generateOutputSchema(db);
    return plan;
  }
}
