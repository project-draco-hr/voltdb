{
  int chunksRead=0;
  while (m_hasMoreChunks) {
    try {
      m_chunkReads.acquire();
    }
 catch (    InterruptedException e) {
      return;
    }
    try {
      ByteBuffer chunkLengthB=ByteBuffer.allocate(12);
      while (chunkLengthB.hasRemaining()) {
        final int read=m_saveFile.read(chunkLengthB);
        if (read == -1) {
          throw new EOFException();
        }
      }
      chunkLengthB.flip();
      final int nextChunkLength=chunkLengthB.getInt();
      final int nextChunkCRC=chunkLengthB.getInt();
      final int nextChunkPartitionId=chunkLengthB.getInt();
      if (nextChunkLength < 0) {
        throw new IOException("Corrupted TableSaveFile chunk has negative chunk length");
      }
      if (nextChunkLength > 2097152) {
        throw new IOException("Corrupted TableSaveFile chunk has unreasonable header length > 2 megs");
      }
      Container c=m_buffers.poll();
      if (c == null) {
        final BBContainer originContainer=DBBPool.allocateDirect(DEFAULT_CHUNKSIZE);
        final ByteBuffer b=originContainer.b;
        final long pointer=org.voltdb.utils.DBBPool.getBufferAddress(b);
        c=new Container(b,pointer,originContainer);
      }
      c.b.clear();
      c.b.limit((nextChunkLength - 4) + m_tableHeader.capacity());
      m_tableHeader.position(0);
      c.b.put(m_tableHeader);
      final int checksumStartPosition=c.b.position();
      c.b.position(c.b.position() + 4);
      while (c.b.hasRemaining()) {
        final int read=m_saveFile.read(c.b);
        if (read == -1) {
          throw new EOFException();
        }
      }
      c.b.position(c.b.position() - 4);
      final int rowCount=c.b.getInt();
      c.b.position(checksumStartPosition);
      c.b.putInt(nextChunkPartitionId);
      c.b.position(c.b.position() - 4);
      final int calculatedCRC=DBBPool.getBufferCRC32(c.b,c.b.position(),c.b.remaining());
      if (calculatedCRC != nextChunkCRC) {
        throw new IOException("CRC mismatch in saved table chunk");
      }
      if (m_relevantPartitionIds != null) {
        if (!m_relevantPartitionIds.contains(nextChunkPartitionId)) {
          c.discard();
          m_chunkReads.release();
          continue;
        }
      }
      c.b.limit(c.b.limit() - 4);
      c.b.position(checksumStartPosition);
      c.b.putInt(rowCount);
      c.b.position(0);
      ++chunksRead;
synchronized (TableSaveFile.this) {
        m_availableChunks.offer(c);
        TableSaveFile.this.notifyAll();
      }
    }
 catch (    EOFException eof) {
synchronized (TableSaveFile.this) {
        m_hasMoreChunks=false;
        TableSaveFile.this.notifyAll();
      }
    }
catch (    IOException e) {
synchronized (TableSaveFile.this) {
        m_hasMoreChunks=false;
        m_chunkReaderException=e;
        TableSaveFile.this.notifyAll();
      }
    }
  }
}
