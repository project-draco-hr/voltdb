{
  try {
    EELibraryLoader.loadExecutionEngineLibrary(true);
    if (relevantPartitionIds == null) {
      m_relevantPartitionIds=null;
    }
 else {
      m_relevantPartitionIds=new HashSet<Integer>();
      for (      Integer i : relevantPartitionIds) {
        m_relevantPartitionIds.add(i);
      }
    }
    m_chunkReads=new Semaphore(readAheadChunks);
    m_saveFile=dataIn;
    m_continueOnCorruptedChunk=continueOnCorruptedChunk;
    final CRC32 crc=new CRC32();
    final ByteBuffer lengthBuffer=ByteBuffer.allocate(8);
    while (lengthBuffer.hasRemaining()) {
      final int read=m_saveFile.read(lengthBuffer);
      if (read == -1) {
        throw new EOFException();
      }
    }
    lengthBuffer.flip();
    final int originalCRC=lengthBuffer.getInt();
    int length=lengthBuffer.getInt();
    crc.update(lengthBuffer.array(),4,4);
    if (length < 0) {
      throw new IOException("Corrupted save file has negative header length");
    }
    if (length > 2097152) {
      throw new IOException("Corrupted save file has unreasonable header length > 2 megs");
    }
    final ByteBuffer saveRestoreHeader=ByteBuffer.allocate(length);
    while (saveRestoreHeader.hasRemaining()) {
      final int read=m_saveFile.read(saveRestoreHeader);
      if (read == -1 || read < length) {
        throw new EOFException();
      }
    }
    saveRestoreHeader.flip();
    crc.update(saveRestoreHeader.array());
    lengthBuffer.clear();
    lengthBuffer.limit(4);
{
      final int read=m_saveFile.read(lengthBuffer);
      if (read == -1) {
        throw new EOFException();
      }
    }
    crc.update(lengthBuffer.array(),0,4);
    lengthBuffer.flip();
    length=lengthBuffer.getInt();
    if (length < 4) {
      throw new IOException("Corrupted save file has negative length or too small length for VoltTable header");
    }
    if (length > 2097152) {
      throw new IOException("Corrupted save file has unreasonable VoltTable header length > 2 megs");
    }
    m_tableHeader=ByteBuffer.allocate(length + 4);
    m_tableHeader.putInt(length);
    while (m_tableHeader.hasRemaining()) {
      final int read=m_saveFile.read(m_tableHeader);
      if (read == -1) {
        throw new EOFException();
      }
    }
    crc.update(m_tableHeader.array(),4,length);
    final int actualCRC=(int)crc.getValue();
    if (originalCRC != actualCRC) {
      throw new IOException("Checksum mismatch");
    }
    FastDeserializer fd=new FastDeserializer(saveRestoreHeader);
    m_completed=fd.readByte() == 1 ? true : false;
    for (int ii=0; ii < 4; ii++) {
      m_versionNum[ii]=fd.readInt();
    }
    m_createTime=fd.readLong();
    m_hostId=fd.readInt();
    m_hostname=fd.readString();
    m_clusterName=fd.readString();
    m_databaseName=fd.readString();
    m_tableName=fd.readString();
    m_isReplicated=fd.readBoolean();
    if (!m_isReplicated) {
      m_partitionIds=(int[])fd.readArray(int.class);
      m_totalPartitions=fd.readInt();
    }
 else {
      m_partitionIds=new int[]{0};
      m_totalPartitions=1;
    }
  }
 catch (  BufferUnderflowException e) {
    throw new IOException(e);
  }
catch (  BufferOverflowException e) {
    throw new IOException(e);
  }
catch (  IndexOutOfBoundsException e) {
    throw new IOException(e);
  }
}
