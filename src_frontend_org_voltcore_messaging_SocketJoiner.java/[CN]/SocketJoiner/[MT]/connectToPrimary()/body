{
  SocketChannel socket=null;
  try {
    LOG.debug("Non-Primary Starting");
    LOG.debug("Non-Primary Connecting to Primary");
    while (socket == null) {
      try {
        socket=SocketChannel.open(m_coordIp);
      }
 catch (      java.net.ConnectException e) {
        LOG.warn("Joining primary failed: " + e.getMessage() + " retrying..");
        try {
          Thread.sleep(250);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
    socket.socket().setTcpNoDelay(true);
    socket.socket().setPerformancePreferences(0,2,1);
    ByteBuffer currentTime=ByteBuffer.allocate(8);
    while (currentTime.hasRemaining()) {
      socket.read(currentTime);
    }
    currentTime.flip();
    long skew=System.currentTimeMillis() - currentTime.getLong();
    List<Long> skews=new ArrayList<Long>();
    skews.add(skew);
    JSONObject jsObj=new JSONObject();
    jsObj.put("type","REQUEST_HOSTID");
    jsObj.put("port",m_internalPort);
    if (!m_internalInterface.isEmpty()) {
      jsObj.put("address",m_internalInterface);
    }
    byte jsBytes[]=jsObj.toString(4).getBytes("UTF-8");
    ByteBuffer requestHostIdBuffer=ByteBuffer.allocate(4 + jsBytes.length);
    requestHostIdBuffer.putInt(jsBytes.length);
    requestHostIdBuffer.put(jsBytes).flip();
    while (requestHostIdBuffer.hasRemaining()) {
      socket.write(requestHostIdBuffer);
    }
    LOG.debug("Non-Primary requesting its Host ID");
    ByteBuffer lengthBuffer=ByteBuffer.allocate(4);
    while (lengthBuffer.hasRemaining()) {
      int read=socket.read(lengthBuffer);
      if (read == -1) {
        throw new EOFException();
      }
    }
    lengthBuffer.flip();
    ByteBuffer responseBuffer=ByteBuffer.allocate(lengthBuffer.getInt());
    while (responseBuffer.hasRemaining()) {
      int read=socket.read(responseBuffer);
      if (read == -1) {
        throw new EOFException();
      }
    }
    String jsonString=new String(responseBuffer.array(),"UTF-8");
    JSONObject jsonObj=new JSONObject(jsonString);
    m_localHostId=jsonObj.getInt("newHostId");
    m_reportedInternalInterface=jsonObj.getString("reportedAddress");
    JSONArray otherHosts=jsonObj.getJSONArray("hosts");
    int hostIds[]=new int[otherHosts.length()];
    SocketChannel hostSockets[]=new SocketChannel[hostIds.length];
    InetSocketAddress listeningAddresses[]=new InetSocketAddress[hostIds.length];
    for (int ii=0; ii < otherHosts.length(); ii++) {
      JSONObject host=otherHosts.getJSONObject(ii);
      String address=host.getString("address");
      int port=host.getInt("port");
      final int hostId=host.getInt("hostId");
      hostLog.info("Leader provided address " + address);
      InetSocketAddress hostAddr=new InetSocketAddress(address,port);
      if (ii == 0) {
        hostIds[ii]=hostId;
        listeningAddresses[ii]=hostAddr;
        hostSockets[ii]=socket;
        continue;
      }
      SocketChannel hostSocket=null;
      while (hostSocket == null) {
        try {
          hostSocket=SocketChannel.open(hostAddr);
        }
 catch (        java.net.ConnectException e) {
          LOG.warn("Joining primary failed: " + e.getMessage() + " retrying..");
          try {
            Thread.sleep(250);
          }
 catch (          InterruptedException ex) {
          }
        }
      }
      currentTime.clear();
      while (currentTime.hasRemaining()) {
        hostSocket.read(currentTime);
      }
      currentTime.flip();
      skew=System.currentTimeMillis() - currentTime.getLong();
      skews.add(skew);
      jsObj=new JSONObject();
      jsObj.put("type","PUBLISH_HOSTID");
      jsObj.put("hostId",m_localHostId);
      jsObj.put("port",m_internalPort);
      jsObj.put("address",m_internalInterface.isEmpty() ? m_reportedInternalInterface : m_internalInterface);
      jsBytes=jsObj.toString(4).getBytes("UTF-8");
      ByteBuffer pushHostId=ByteBuffer.allocate(4 + jsBytes.length);
      pushHostId.putInt(jsBytes.length);
      pushHostId.put(jsBytes).flip();
      while (pushHostId.hasRemaining()) {
        hostSocket.write(pushHostId);
      }
      hostIds[ii]=hostId;
      hostSockets[ii]=hostSocket;
      listeningAddresses[ii]=hostAddr;
    }
    long maxSkew=Collections.max(skews);
    long minSkew=Collections.min(skews);
    long overallSkew=maxSkew - minSkew;
    if (maxSkew > 0 && minSkew > 0) {
      overallSkew=maxSkew;
    }
 else     if (maxSkew < 0 && minSkew < 0) {
      overallSkew=Math.abs(minSkew);
    }
    if (overallSkew > 100) {
      VoltDB.crashLocalVoltDB("Clock skew is " + overallSkew + " which is > than the 100 millisecond limit. Make sure NTP is running.",false,null);
    }
 else     if (overallSkew > 10) {
      final String msg="Clock skew is " + overallSkew + " which is high. Ideally it should be sub-millisecond. Make sure NTP is running.";
      hostLog.warn(msg);
      consoleLog.warn(msg);
    }
 else {
      hostLog.info("Clock skew to across all nodes in the cluster is " + overallSkew);
    }
    ByteBuffer joinCompleteBuffer=ByteBuffer.allocate(1);
    while (joinCompleteBuffer.hasRemaining()) {
      hostSockets[0].write(joinCompleteBuffer);
    }
    m_joinHandler.notifyOfHosts(m_localHostId,hostIds,hostSockets,listeningAddresses);
  }
 catch (  ClosedByInterruptException e) {
  }
catch (  Exception e) {
    hostLog.error("Failed to establish socket mesh.",e);
    throw new RuntimeException(e);
  }
}
