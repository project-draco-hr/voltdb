{
  if (m.isError()) {
    protocolError(m,"Internal error message. May indicate that an invalid ack offset was requested.");
    return;
  }
 else   if (m.isOpenResponse()) {
    protocolError(m,"Server must not receive open response message.");
    return;
  }
 else   if (VoltDB.instance().getMode() == OperationMode.PAUSED && !m_isAdmin) {
    protocolError(m,"Server currently unavailable for export connections on this port");
    return;
  }
 else   if (VoltDB.instance().getMode() == OperationMode.INITIALIZING) {
    protocolError(m,"Server has not finished initialization");
    return;
  }
 else   if (m.isOpen()) {
    if (m_state != RawProcessor.CLOSED) {
      protocolError(m,"Client must not open an already opened connection.");
      return;
    }
    if (m.isClose() || m.isPoll() || m.isAck()) {
      protocolError(m,"Invalid combination of open with close, poll or ack.");
      return;
    }
    m_state=RawProcessor.CONNECTED;
    try {
      VoltZK.updateClusterMetadata(m_clusterMetadata);
    }
 catch (    Exception e) {
      protocolError(m,org.voltcore.utils.CoreUtils.throwableToString(e));
    }
    byte jsonBytes[]=null;
    try {
      JSONStringer stringer=new JSONStringer();
      stringer.object();
      stringer.key("sources").array();
      for (      ExportDataSource src : m_sourcesArray) {
        stringer.object();
        src.writeAdvertisementTo(stringer);
        stringer.endObject();
      }
      stringer.endArray();
      stringer.key("clusterMetadata").array();
      for (      String metadata : m_clusterMetadata.values()) {
        stringer.value(metadata);
      }
      stringer.endArray();
      stringer.endObject();
      jsonBytes=new JSONObject(stringer.toString()).toString(4).getBytes(Charsets.UTF_8);
    }
 catch (    JSONException e) {
      protocolError(m,"Error producing open response advertisement.");
      return;
    }
    final ExportProtoMessage r=new ExportProtoMessage(-1,-1,"");
    r.openResponse(ByteBuffer.wrap(jsonBytes));
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public ByteBuffer[] serialize() throws IOException {
        return new ByteBuffer[]{r.toBuffer()};
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
 else   if (m.isPoll() || m.isAck()) {
    if (m_state != RawProcessor.CONNECTED) {
      protocolError(m,"Must not poll or ack a closed connection");
      return;
    }
    ExportDataSource source=RawProcessor.this.getDataSourceFor(m.getPartitionId(),m.getSignature());
    if (source == null) {
      protocolError(m,"No Export data source exists for partition(" + m.getPartitionId() + ") and table("+ m.getSignature()+ ") pair.");
      return;
    }
    source.exportAction(new ExportInternalMessage(this,m));
    return;
  }
 else   if (m.isClose()) {
    closeConnection();
    return;
  }
 else   if (m.isPollResponse()) {
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public ByteBuffer[] serialize() throws IOException {
        return new ByteBuffer[]{m.toBuffer()};
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
}
