{
  if (m.isError()) {
    protocolError(m,"Internal error message. May indicate that an invalid ack offset was requested.");
    return;
  }
 else   if (m.isOpenResponse()) {
    protocolError(m,"Server must not receive open response message.");
    return;
  }
 else   if (VoltDB.instance().getMode() == OperationMode.PAUSED && !m_isAdmin) {
    protocolError(m,"Server currently unavailable for export connections on this port");
    return;
  }
 else   if (VoltDB.instance().getMode() == OperationMode.INITIALIZING) {
    protocolError(m,"Server has not finished initialization");
    return;
  }
 else   if (m.isOpen()) {
    if (m_state != RawProcessor.CLOSED) {
      protocolError(m,"Client must not open an already opened connection.");
      return;
    }
    if (m.isClose() || m.isPoll() || m.isAck()) {
      protocolError(m,"Invalid combination of open with close, poll or ack.");
      return;
    }
    m_state=RawProcessor.CONNECTED;
    try {
      VoltZK.updateClusterMetadata(m_clusterMetadata);
    }
 catch (    Exception e) {
      protocolError(m,org.voltcore.utils.MiscUtils.throwableToString(e));
    }
    FastSerializer fs=new FastSerializer();
    try {
      fs.writeInt(m_sourcesArray.size());
      for (      ExportDataSource src : m_sourcesArray) {
        src.writeAdvertisementTo(fs);
      }
      fs.writeInt(m_clusterMetadata.size());
      for (      String metadata : m_clusterMetadata.values()) {
        fs.writeString(metadata);
      }
    }
 catch (    IOException e) {
      protocolError(m,"Error producing open response advertisement.");
      return;
    }
    final ExportProtoMessage r=new ExportProtoMessage(-1,-1,"");
    r.openResponse(fs.getBuffer());
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public ByteBuffer[] serialize() throws IOException {
        return new ByteBuffer[]{r.toBuffer()};
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
 else   if (m.isPoll() || m.isAck()) {
    if (m_state != RawProcessor.CONNECTED) {
      protocolError(m,"Must not poll or ack a closed connection");
      return;
    }
    ExportDataSource source=RawProcessor.this.getDataSourceFor(m.getPartitionId(),m.getSignature());
    if (source == null) {
      protocolError(m,"No Export data source exists for partition(" + m.getPartitionId() + ") and table("+ m.getSignature()+ ") pair.");
      return;
    }
    try {
      source.exportAction(new ExportInternalMessage(this,m));
      return;
    }
 catch (    MessagingException e) {
      protocolError(m,e.getMessage());
      return;
    }
  }
 else   if (m.isClose()) {
    closeConnection();
    return;
  }
 else   if (m.isPollResponse()) {
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public ByteBuffer[] serialize() throws IOException {
        return new ByteBuffer[]{m.toBuffer()};
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
}
