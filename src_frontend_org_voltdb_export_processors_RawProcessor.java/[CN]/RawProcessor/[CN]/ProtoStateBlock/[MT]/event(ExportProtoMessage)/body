{
  if (m.isError()) {
    protocolError(m,"Internal error message. May indicate that an invalid ack offset was requested.");
    return;
  }
 else   if (m.isOpenResponse()) {
    protocolError(m,"Server must not receive open response message.");
    return;
  }
 else   if (VoltDB.instance().inAdminMode() && !m_isAdmin) {
    protocolError(m,"Server currently unavailable for export connections on this port");
    return;
  }
 else   if (m.isOpen()) {
    if (m_state != RawProcessor.CLOSED) {
      protocolError(m,"Client must not open an already opened connection.");
      return;
    }
    if (m.isClose() || m.isPoll() || m.isAck()) {
      protocolError(m,"Invalid combination of open with close, poll or ack.");
      return;
    }
    m_state=RawProcessor.CONNECTED;
    FastSerializer fs=new FastSerializer();
    try {
      fs.writeInt(m_sourcesArray.size());
      for (      ExportDataSource src : m_sourcesArray) {
        src.writeAdvertisementTo(fs);
      }
      CatalogContext cx=VoltDB.instance().getCatalogContext();
      HostMessenger hm=VoltDB.instance().getHostMessenger();
      int myHostId=-1;
      if (hm != null)       myHostId=hm.getHostId();
      if (cx != null) {
        Set<Integer> liveHosts=cx.siteTracker.getAllLiveHosts();
        fs.writeInt(liveHosts.size() - 1);
        for (        int hostId : liveHosts) {
          if (hostId == myHostId)           continue;
          String metadata=VoltDB.instance().getClusterMetadataMap().get(hostId);
          System.out.printf("hostid %d, metadata: %s",hostId,metadata);
          assert(metadata.contains(":"));
          fs.writeString(metadata);
        }
      }
 else {
        fs.writeInt(0);
      }
    }
 catch (    IOException e) {
      protocolError(m,"Error producing open response advertisement.");
      return;
    }
    final ExportProtoMessage r=new ExportProtoMessage(-1,-1);
    r.openResponse(fs.getBuffer());
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public BBContainer serialize(      DBBPool p) throws IOException {
        FastSerializer fs=new FastSerializer(p,r.serializableBytes() + 4);
        r.writeToFastSerializer(fs);
        return fs.getBBContainer();
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
 else   if (m.isPoll() || m.isAck()) {
    if (m_state != RawProcessor.CONNECTED) {
      protocolError(m,"Must not poll or ack a closed connection");
      return;
    }
    ExportDataSource source=RawProcessor.this.getDataSourceFor(m.getPartitionId(),m.getTableId());
    if (source == null) {
      protocolError(m,"No Export data source exists for partition(" + m.getPartitionId() + ") and table("+ m.getTableId()+ ") pair.");
      return;
    }
    try {
      source.exportAction(new ExportInternalMessage(this,m));
      return;
    }
 catch (    MessagingException e) {
      protocolError(m,e.getMessage());
      return;
    }
  }
 else   if (m.isClose()) {
    closeConnection();
    return;
  }
 else   if (m.isPollResponse()) {
    m_c.writeStream().enqueue(new DeferredSerialization(){
      @Override public BBContainer serialize(      DBBPool p) throws IOException {
        FastSerializer fs=new FastSerializer(p,m.serializableBytes() + 4);
        m.writeToFastSerializer(fs);
        return fs.getBBContainer();
      }
      @Override public void cancel(){
      }
    }
);
    return;
  }
}
