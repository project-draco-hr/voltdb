{
  int size=jArray.length();
  try {
    for (int i=0; i < size; i++) {
      JSONObject jobj;
      jobj=jArray.getJSONObject(i);
      String nodeTypeStr=jobj.getString("PLAN_NODE_TYPE");
      PlanNodeType nodeType=PlanNodeType.get(nodeTypeStr);
      AbstractPlanNode apn=null;
switch (nodeType) {
case AGGREGATE:
        apn=new AggregatePlanNode();
      break;
case DELETE:
    apn=new DeletePlanNode();
  break;
case DISTINCT:
apn=new DistinctPlanNode();
break;
case HASHAGGREGATE:
apn=new HashAggregatePlanNode();
break;
case INDEXSCAN:
apn=new IndexScanPlanNode();
break;
case SEQSCAN:
apn=new SeqScanPlanNode();
break;
case INSERT:
apn=new InsertPlanNode();
break;
case LIMIT:
apn=new LimitPlanNode();
break;
case MATERIALIZE:
apn=new MaterializePlanNode();
break;
case NESTLOOP:
apn=new NestLoopPlanNode();
break;
case NESTLOOPINDEX:
apn=new NestLoopIndexPlanNode();
break;
case ORDERBY:
apn=new OrderByPlanNode();
break;
case PROJECTION:
apn=new ProjectionPlanNode();
break;
case RECEIVE:
apn=new ReceivePlanNode();
break;
case SEND:
apn=new SendPlanNode();
break;
case UNION:
apn=new UnionPlanNode();
break;
case UPDATE:
apn=new UpdatePlanNode();
break;
default :
System.err.println("plan node type not support: " + nodeType);
}
apn.loadFromJSONObject(jobj,db);
m_planNodes.add(apn);
}
for (int i=0; i < size; i++) {
JSONObject jobj;
jobj=jArray.getJSONObject(i);
JSONArray children=jobj.getJSONArray("CHILDREN_IDS");
for (int j=0; j < children.length(); j++) {
m_planNodes.get(i).addAndLinkChild(getNodeofId(children.getInt(j)));
}
}
}
 catch (JSONException e) {
e.printStackTrace();
}
}
