{
  E e=null;
  long nanos=unit.toNanos(time);
  _headLock.lockInterruptibly();
  try {
    try {
      while (_size.get() == 0) {
        if (nanos <= 0)         return null;
        nanos=_notEmpty.awaitNanos(nanos);
      }
    }
 catch (    InterruptedException ie) {
      _notEmpty.signal();
      throw ie;
    }
    e=(E)_elements[_head];
    _elements[_head]=null;
    _head=(_head + 1) % _capacity;
    if (_size.decrementAndGet() > 0)     _notEmpty.signal();
  }
  finally {
    _headLock.unlock();
  }
  return e;
}
