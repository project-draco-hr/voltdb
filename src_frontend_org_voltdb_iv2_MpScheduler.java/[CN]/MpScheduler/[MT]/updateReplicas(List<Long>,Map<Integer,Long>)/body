{
  m_iv2Masters.clear();
  m_iv2Masters.addAll(replicas);
  m_partitionMasters.clear();
  m_partitionMasters.putAll(partitionMasters);
  if (!m_isLeader) {
    return;
  }
  List<Long> doneCounters=new LinkedList<Long>();
  for (  Entry<Long,DuplicateCounter> entry : m_duplicateCounters.entrySet()) {
    DuplicateCounter counter=entry.getValue();
    int result=counter.updateReplicas(m_iv2Masters);
    if (result == DuplicateCounter.DONE) {
      doneCounters.add(entry.getKey());
    }
  }
  Collections.sort(doneCounters);
  for (  Long key : doneCounters) {
    DuplicateCounter counter=m_duplicateCounters.remove(key);
    VoltMessage resp=counter.getLastResponse();
    if (resp != null && resp instanceof InitiateResponseMessage) {
      InitiateResponseMessage msg=(InitiateResponseMessage)resp;
      if (msg.shouldCommit()) {
        m_repairLogTruncationHandle=m_repairLogAwaitingCommit;
        m_repairLogAwaitingCommit=msg.getTxnId();
      }
      m_outstandingTxns.remove(msg.getTxnId());
      m_mailbox.send(counter.m_destinationId,resp);
    }
 else {
      hostLog.warn("TXN " + counter.getTxnId() + " lost all replicas and "+ "had no responses.  This should be impossible?");
    }
  }
  final List<Long> replicaCopy=new ArrayList<Long>(replicas);
  SiteTasker repairTask=new SiteTasker(){
    @Override public void run(    SiteProcedureConnection connection){
      try {
        String whoami="MP leader repair " + CoreUtils.hsIdToString(m_mailbox.getHSId()) + " ";
        InitiatorMailbox initiatorMailbox=(InitiatorMailbox)m_mailbox;
        RepairAlgo algo=new MpPromoteAlgo(replicas,initiatorMailbox,whoami);
        initiatorMailbox.setRepairAlgo(algo);
        Pair<Boolean,Long> result=algo.start().get();
        boolean success=result.getFirst();
        if (success) {
          tmLog.info(whoami + "finished repair.");
        }
 else {
          tmLog.info(whoami + "interrupted during repair.  Retrying.");
        }
      }
 catch (      InterruptedException ie) {
      }
catch (      Exception e) {
        VoltDB.crashLocalVoltDB("Terminally failed MPI repair.",true,e);
      }
    }
    @Override public void runForRejoin(    SiteProcedureConnection siteConnection,    TaskLog taskLog) throws IOException {
      throw new RuntimeException("Rejoin while repairing the MPI should be impossible.");
    }
  }
;
  m_pendingTasks.repair(repairTask,replicaCopy,partitionMasters);
}
