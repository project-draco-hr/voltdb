{
  final HashSet<ProcedureInfo> newProcs=new HashSet<ProcedureInfo>();
  for (  final ProcedureInfo procedure : procedures) {
    assert(newProcs.contains(procedure) == false);
    assert(m_procedures.contains(procedure) == false);
    newProcs.add(procedure);
  }
  StringBuffer sb=new StringBuffer();
  for (  final ProcedureInfo procedure : procedures) {
    m_procedures.add(procedure);
    StringBuffer roleInfo=new StringBuffer();
    if (procedure.groups.length != 0) {
      roleInfo.append(" ALLOW ");
      for (int i=0; i < procedure.groups.length; i++) {
        roleInfo.append(procedure.groups[i] + ",");
      }
      int length=roleInfo.length();
      roleInfo.replace(length - 1,length," ");
    }
    if (procedure.cls != null) {
      sb.append("CREATE PROCEDURE " + roleInfo.toString() + " FROM CLASS "+ procedure.cls.getName()+ ";");
    }
 else     if (procedure.sql != null) {
      sb.append("CREATE PROCEDURE " + procedure.name + roleInfo.toString()+ " AS "+ procedure.sql);
    }
    if (procedure.partitionInfo != null) {
      String[] token=procedure.partitionInfo.split(":")[0].split("\\.");
      sb.append("PARTITION PROCEDURE " + procedure.name + " ON TABLE "+ token[0]+ " COLUMN "+ token[1]+ ";");
    }
  }
  try {
    System.out.println(sb.toString());
    addLiteralSchema(sb.toString());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}
