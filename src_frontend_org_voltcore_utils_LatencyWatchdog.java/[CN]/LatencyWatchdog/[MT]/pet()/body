{
  if (!m_enable)   return;
  final Thread t=Thread.currentThread();
  if (m_latencyMap.containsKey(t)) {
    m_latencyMap.put(t,System.currentTimeMillis());
  }
 else {
    m_latencyMap.put(t,System.currentTimeMillis());
    executor.scheduleWithFixedDelay(new Runnable(){
      @Override public synchronized void run(){
        long timestamp=m_latencyMap.get(t);
        long now=System.currentTimeMillis();
        if ((now - timestamp > WATCHDOG_THRESHOLD) && (now - m_lastLogTime.get(t) > MIN_LOG_INTERVAL) && t.getState() != Thread.State.TERMINATED) {
          LOG.info(t.getName() + " has been delay for " + (now - timestamp)+ " milliseconds");
          m_lastLogTime.put(t,now);
          for (          StackTraceElement ste : t.getStackTrace()) {
            LOG.info(ste);
          }
        }
      }
    }
,WATCHDOG_THRESHOLD,WATCHDOG_THRESHOLD,TimeUnit.MILLISECONDS);
  }
}
