{
  Thread.currentThread().setName("Latency Watchdog");
  while (!m_shouldStop) {
    for (Iterator<Pair<Thread,Long>> iter=sLatencyMap.values().iterator(); iter.hasNext(); ) {
      Pair<Thread,Long> pair=iter.next();
      Thread t=pair.getFirst();
      Long timestamp=pair.getSecond();
      long now=System.currentTimeMillis();
      if ((now - timestamp > WATCHDOG_THRESHOLD) && t.getState() != Thread.State.TERMINATED && (sLastLogTime.get(t) == null || (now - sLastLogTime.get(t)) > MIN_LOG_INTERVAL)) {
        LOG.info(t.getName() + " has been delayed for " + (now - timestamp)+ " milliseconds");
        for (        StackTraceElement ste : t.getStackTrace()) {
          LOG.info(ste);
        }
        sLastLogTime.put(t,now);
      }
      if (t.getState() == Thread.State.TERMINATED) {
        iter.remove();
      }
    }
    try {
      Thread.sleep(WAKEUP_INTERVAL);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}
