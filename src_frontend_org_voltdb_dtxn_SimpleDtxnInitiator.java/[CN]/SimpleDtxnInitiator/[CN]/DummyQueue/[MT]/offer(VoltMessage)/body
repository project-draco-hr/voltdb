{
  assert(message instanceof InitiateResponse);
  final InitiateResponse r=(InitiateResponse)message;
  InFlightTxnState state;
  int sites_left=-1;
synchronized (m_initiator) {
    state=m_initiator.m_pendingTxns.getTxn(r.getTxnId(),r.getCoordinatorSiteId());
    sites_left=m_initiator.m_pendingTxns.getTxnIdSize(r.getTxnId());
  }
  assert(state.coordinatorId == r.getCoordinatorSiteId());
  assert(m_initiator.m_siteId == r.getInitiatorSiteId());
  boolean first_response=false;
  VoltTable[] first_results=null;
  if (!m_txnIdResponses.containsKey(r.getTxnId())) {
    ClientResponseImpl curr_response=(ClientResponseImpl)r.getClientResponseData();
    VoltTable[] curr_results=curr_response.getResults();
    VoltTable[] saved_results=new VoltTable[curr_results.length];
    for (int i=0; i < curr_results.length; ++i) {
      saved_results[i]=new VoltTable(curr_results[i].getTableDataReference(),true);
    }
    m_txnIdResponses.put(r.getTxnId(),saved_results);
    first_response=true;
  }
 else {
    first_results=m_txnIdResponses.get(r.getTxnId());
  }
  if (first_response) {
    if (state.isReadOnly) {
      r.setClientHandle(state.invocation.getClientHandle());
      final Connection c=(Connection)state.clientData;
      assert(c != null);
      c.writeStream().enqueue(r.getClientResponseData());
    }
  }
 else {
    assert(first_results != null);
    ClientResponseImpl curr_response=(ClientResponseImpl)r.getClientResponseData();
    VoltTable[] curr_results=curr_response.getResults();
    if (first_results.length != curr_results.length) {
      String msg="Mismatched result count received for transaction: " + r.getTxnId();
      msg+="\n  from execution site: " + r.getCoordinatorSiteId();
      msg+="\n  Expected number of results: " + first_results.length;
      msg+="\n  Mismatched number of results: " + curr_results.length;
      throw new RuntimeException(msg);
    }
    for (int i=0; i < first_results.length; ++i) {
      if (!curr_results[i].hasSameContents(first_results[i])) {
        String msg="Mismatched results received for transaction: " + r.getTxnId();
        msg+="\n  from execution site: " + r.getCoordinatorSiteId();
        msg+="\n  Expected results: " + first_results[i].toString();
        msg+="\n  Mismatched results: " + curr_results[i].toString();
        throw new RuntimeException(msg);
      }
    }
  }
  if (sites_left == 0) {
synchronized (m_initiator) {
      m_initiator.m_pendingTxns.removeTxnId(r.getTxnId());
      m_initiator.m_pendingTxnBytes-=state.messageSize;
      m_initiator.m_pendingTxnCount--;
      if (m_initiator.m_pendingTxnBytes < (MAX_DESIRED_PENDING_BYTES * .8) && m_initiator.m_pendingTxnCount < (MAX_DESIRED_PENDING_TXNS * .8)) {
        if (m_initiator.m_hadBackPressure) {
          transactionLog.trace("DTXN backpressure ended");
          m_initiator.m_hadBackPressure=false;
          m_initiator.m_offBackPressure.run();
        }
      }
    }
    m_txnIdResponses.remove(r.getTxnId());
    if (!state.isReadOnly) {
      r.setClientHandle(state.invocation.getClientHandle());
      final Connection c=(Connection)state.clientData;
      assert(c != null);
      final long now=EstTime.currentTimeMillis();
      final int delta=(int)(now - state.initiateTime);
      final ClientResponseImpl response=r.getClientResponseData();
      response.setClusterRoundtrip(delta);
      m_initiator.m_stats.logTransactionCompleted(state.connectionId,state.invocation,delta);
      c.writeStream().enqueue(response);
    }
  }
  return true;
}
