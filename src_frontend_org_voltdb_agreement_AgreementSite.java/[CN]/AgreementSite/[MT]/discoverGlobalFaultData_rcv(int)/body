{
  int responses=0;
  long safeInitPoint=Long.MIN_VALUE;
  java.util.ArrayList<FailureSiteUpdateMessage> messages=new java.util.ArrayList<FailureSiteUpdateMessage>();
  do {
    VoltMessage m=m_mailbox.recvBlocking(new Subject[]{Subject.FAILURE,Subject.FAILURE_SITE_UPDATE},5);
    if (m == null) {
      continue;
    }
    FailureSiteUpdateMessage fm=null;
    if (m.getSubject() == Subject.FAILURE_SITE_UPDATE.getId()) {
      fm=(FailureSiteUpdateMessage)m;
      messages.add(fm);
    }
 else     if (m.getSubject() == Subject.FAILURE.getId()) {
      Set<NodeFailureFault> faults=((FaultMessage)m).nodeFaults;
      HashSet<Integer> newFailedSiteIds=new HashSet<Integer>();
      for (      NodeFailureFault fault : faults) {
        newFailedSiteIds.addAll(fault.getFailedNonExecSites());
      }
      m_mailbox.deliverFront(m);
      m_recoveryLog.info("Agreement, Detected a concurrent failure from FaultDistributor, new failed sites " + newFailedSiteIds);
      return null;
    }
    try {
      if (!m_knownFailedSites.equals(fm.m_failedSiteIds)) {
        if (!m_knownFailedSites.containsAll(fm.m_failedSiteIds)) {
          m_mailbox.deliver(fm);
          return null;
        }
 else {
          HashSet<Integer> difference=new HashSet<Integer>(m_knownFailedSites);
          difference.removeAll(fm.m_failedSiteIds);
          m_recoveryLog.info("Agreement, Discarding failure message from " + fm.m_sourceSiteId + " because it was missing failed sites "+ difference.toString());
          continue;
        }
      }
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
    ++responses;
    m_recoveryLog.info("Agreement, Received failure message " + responses + " of "+ expectedResponses+ " from "+ fm.m_sourceSiteId+ " for failed sites "+ fm.m_failedSiteIds+ " safe txn id "+ fm.m_safeTxnId);
    safeInitPoint=Math.max(safeInitPoint,fm.m_safeTxnId);
  }
 while (responses < expectedResponses);
  assert(safeInitPoint != Long.MIN_VALUE);
  return safeInitPoint;
}
