{
  int responses=0;
  java.util.ArrayList<FailureSiteUpdateMessage> messages=new java.util.ArrayList<FailureSiteUpdateMessage>();
  HashMap<Integer,Long> initiatorSafeInitPoint=new HashMap<Integer,Long>();
  do {
    VoltMessage m=m_mailbox.recvBlocking(new Subject[]{Subject.FAILURE,Subject.FAILURE_SITE_UPDATE},5);
    if (m == null) {
      continue;
    }
    FailureSiteUpdateMessage fm=null;
    if (m.getSubject() == Subject.FAILURE_SITE_UPDATE.getId()) {
      fm=(FailureSiteUpdateMessage)m;
      messages.add(fm);
    }
 else     if (m.getSubject() == Subject.FAILURE.getId()) {
      Set<NodeFailureFault> faults=((FaultMessage)m).nodeFaults;
      HashSet<Integer> newFailedSiteIds=new HashSet<Integer>();
      for (      NodeFailureFault fault : faults) {
        newFailedSiteIds.addAll(fault.getFailedNonExecSites());
      }
      m_mailbox.deliverFront(m);
      m_recoveryLog.info("Agreement, Detected a concurrent failure from FaultDistributor, new failed sites " + newFailedSiteIds);
      return null;
    }
    if (!m_knownFailedSites.equals(fm.m_failedSiteIds)) {
      if (!m_knownFailedSites.containsAll(fm.m_failedSiteIds)) {
        HashSet<Integer> difference=new HashSet<Integer>(fm.m_failedSiteIds);
        difference.removeAll(m_knownFailedSites);
        Set<Integer> differenceHosts=new HashSet<Integer>();
        for (        Integer siteId : difference) {
          differenceHosts.add(VoltDB.instance().getCatalogContext().siteTracker.getHostForSite(siteId));
        }
        for (        Integer hostId : differenceHosts) {
          String hostname=String.valueOf(hostId);
          if (VoltDB.instance() != null) {
            if (VoltDB.instance().getHostMessenger() != null) {
              String hostnameTemp=VoltDB.instance().getHostMessenger().getHostnameForHostID(hostId);
              if (hostnameTemp != null)               hostname=hostnameTemp;
            }
          }
          VoltDB.instance().getFaultDistributor().reportFault(new NodeFailureFault(hostId,VoltDB.instance().getCatalogContext().siteTracker.getNonExecSitesForHost(hostId),hostname));
        }
        m_recoveryLog.info("Detected a concurrent failure from " + fm.m_sourceSiteId + " with new failed sites "+ difference.toString());
        m_mailbox.deliver(m);
        return null;
      }
 else {
        HashSet<Integer> difference=new HashSet<Integer>(m_knownFailedSites);
        difference.removeAll(fm.m_failedSiteIds);
        m_recoveryLog.info("Agreement, Discarding failure message from " + fm.m_sourceSiteId + " because it was missing failed sites "+ difference.toString());
        continue;
      }
    }
    expectedResponseCount.put(fm.m_sourceSiteId,expectedResponseCount.get(fm.m_sourceSiteId) - 1);
    ++responses;
    m_recoveryLog.info("Agreement, Received failure message " + responses + " of "+ expectedResponses+ " from "+ fm.m_sourceSiteId+ " for failed sites "+ fm.m_failedSiteIds+ " safe txn id "+ fm.m_safeTxnId+ " failed site "+ fm.m_committedTxnId);
    m_recoveryLog.info("Agreement, expecting failures messages " + expectedResponseCount);
    if (!initiatorSafeInitPoint.containsKey(fm.m_initiatorForSafeTxnId)) {
      initiatorSafeInitPoint.put(fm.m_initiatorForSafeTxnId,Long.MIN_VALUE);
    }
    initiatorSafeInitPoint.put(fm.m_initiatorForSafeTxnId,Math.max(initiatorSafeInitPoint.get(fm.m_initiatorForSafeTxnId),fm.m_safeTxnId));
  }
 while (responses < expectedResponses);
  assert(!initiatorSafeInitPoint.containsValue(Long.MIN_VALUE));
  return initiatorSafeInitPoint;
}
