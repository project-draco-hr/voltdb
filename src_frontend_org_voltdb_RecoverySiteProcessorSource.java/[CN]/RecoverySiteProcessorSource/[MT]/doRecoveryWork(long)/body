{
  m_sentSkipPastMultipartMsg=false;
  if (!m_sentInitiateResponse) {
    m_stopBeforeTxnId=Math.max(nextTxnId,m_destinationStoppedBeforeTxnId);
    recoveryLog.info("Sending recovery initiate response from " + CoreUtils.hsIdToString(m_siteId) + " before txnId "+ nextTxnId+ " to site "+ CoreUtils.hsIdToString(m_destinationSiteId)+ " choosing to stop before txnId "+ m_stopBeforeTxnId);
    m_sentInitiateResponse=true;
    StringBuilder sb=new StringBuilder();
    if (m_site != null) {
      for (      Table t : m_site.m_context.database.getTables()) {
        if (!CatalogUtil.isTableExportOnly(m_site.m_context.database,t))         continue;
        String sig=t.getSignature();
        sb.append(sig);
        long[] temp=m_engine.getUSOForExportTable(sig);
        sb.append(",").append(temp[0]).append(",").append(temp[1]).append("\n");
      }
      assert(m_site.ee == m_engine);
    }
    byte[] exportUSOBytes=null;
    try {
      exportUSOBytes=sb.toString().getBytes("UTF-8");
    }
 catch (    UnsupportedEncodingException e) {
    }
    ByteBuffer buf=ByteBuffer.allocate(25 + exportUSOBytes.length);
    BBContainer cont=DBBPool.wrapBB(buf);
    buf.putInt(25 + exportUSOBytes.length);
    buf.putLong(m_siteId);
    buf.put(kSTOP_AT_TXN);
    buf.putLong(m_stopBeforeTxnId);
    buf.putInt(exportUSOBytes.length);
    buf.put(exportUSOBytes);
    buf.flip();
    System.out.println("Offering initiate response");
    m_outgoing.offer(cont);
  }
  if (nextTxnId < m_stopBeforeTxnId) {
    return;
  }
  recoveryLog.info("Starting recovery of " + CoreUtils.hsIdToString(m_destinationSiteId) + " work before txnId "+ nextTxnId);
  while (true) {
    while (m_allowedBuffers.get() > 0 && !m_tablesToStream.isEmpty() && !m_buffers.isEmpty()) {
      m_allowedBuffers.decrementAndGet();
      BBContainer container=m_buffers.poll();
      ByteBuffer buffer=container.b;
      buffer.clear();
      buffer.position(4);
      buffer.putLong(m_siteId);
      buffer.putInt(m_blockIndex++);
      RecoveryTable table=m_tablesToStream.peek();
      long startSerializing=System.currentTimeMillis();
      int serialized=m_engine.tableStreamSerializeMore(container,table.m_tableId,TableStreamType.RECOVERY);
      long endSerializing=System.currentTimeMillis();
      m_timeSpentSerializing.addAndGet(endSerializing - startSerializing);
      recoveryLog.trace("Serialized " + serialized + " for table "+ table.m_name);
      if (serialized <= 0) {
        VoltDB.crashLocalVoltDB("Recovery stream error",false,null);
      }
 else {
        buffer.limit(buffer.position() + serialized);
        buffer.putInt(0,buffer.limit() - 4);
        buffer.position(0);
      }
      m_bytesSent+=buffer.remaining();
      RecoveryMessageType type=RecoveryMessageType.values()[buffer.get(messageTypeOffset)];
      if (type == RecoveryMessageType.Complete) {
        m_tablesToStream.poll();
        RecoveryTable nextTable=m_tablesToStream.peek();
        if (nextTable != null) {
          if (!m_engine.activateTableStream(nextTable.m_tableId,TableStreamType.RECOVERY,new SnapshotPredicates())) {
            VoltDB.crashLocalVoltDB("Attempted to activate recovery stream for table " + nextTable.m_name + " and failed",false,null);
          }
        }
      }
      final int numDestinations=table.m_destinationIds.length;
      m_ackTracker.waitForAcks(buffer.getInt(blockIndexOffset),numDestinations);
      m_outgoing.offer(container);
    }
    if (m_tablesToStream.isEmpty()) {
      if (!m_recoveryComplete) {
synchronized (this) {
          m_recoveryComplete=true;
          BBContainer buffer=null;
          while ((buffer=m_buffers.poll()) != null) {
            m_bufferToOriginMap.remove(buffer).discard();
          }
        }
      }
      final long startWait=System.currentTimeMillis();
      while (m_inThread.isAlive() && System.currentTimeMillis() - startWait < 60000) {
        checkMailbox(false);
      }
synchronized (this) {
        if (m_inThread.isAlive()) {
          recoveryLog.error("Timed out waiting for acks for the last few recovery messages");
          closeIO();
        }
        if (m_onCompletion != null) {
          m_onCompletion.run();
          m_onCompletion=null;
        }
      }
      return;
    }
    checkMailbox(true);
  }
}
