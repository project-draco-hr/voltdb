{
  m_sentSkipPastMultipartMsg=false;
  if (!m_sentInitiateResponse) {
    m_stopBeforeTxnId=Math.max(nextTxnId,m_destinationStoppedBeforeTxnId);
    recoveryLog.info("Sending recovery initiate response from " + m_siteId + " before txnId "+ nextTxnId+ " to site "+ m_destinationSiteId+ " choosing to stop before txnId "+ m_stopBeforeTxnId);
    m_sentInitiateResponse=true;
    StringBuilder sb=new StringBuilder();
    if (m_site != null) {
      for (      Table t : m_site.m_context.database.getTables()) {
        if (!CatalogUtil.isTableExportOnly(m_site.m_context.database,t))         continue;
        String sig=t.getSignature();
        sb.append(sig);
        long[] temp=m_engine.getUSOForExportTable(sig);
        sb.append(",").append(temp[0]).append(",").append(temp[1]).append("\n");
      }
      assert(m_site.ee == m_engine);
    }
    byte[] exportUSOBytes=null;
    try {
      exportUSOBytes=sb.toString().getBytes("UTF-8");
    }
 catch (    UnsupportedEncodingException e) {
    }
    ByteBuffer buf=ByteBuffer.allocate(21 + exportUSOBytes.length);
    BBContainer cont=DBBPool.wrapBB(buf);
    buf.putInt(17 + exportUSOBytes.length);
    buf.putInt(m_siteId);
    buf.put(kSTOP_AT_TXN);
    buf.putLong(m_stopBeforeTxnId);
    buf.putInt(exportUSOBytes.length);
    buf.put(exportUSOBytes);
    buf.flip();
    m_outgoing.offer(cont);
  }
  if (nextTxnId < m_stopBeforeTxnId) {
    return;
  }
  recoveryLog.trace("Starting recovery of " + m_destinationSiteId + " work before txnId "+ nextTxnId);
  while (true) {
    while (m_allowedBuffers.get() > 0 && !m_tablesToStream.isEmpty() && !m_buffers.isEmpty()) {
      m_allowedBuffers.decrementAndGet();
      BBContainer container=m_buffers.poll();
      ByteBuffer buffer=container.b;
      buffer.clear();
      buffer.position(4);
      buffer.putInt(m_siteId);
      buffer.putInt(m_blockIndex++);
      RecoveryTable table=m_tablesToStream.peek();
      long startSerializing=System.currentTimeMillis();
      int serialized=m_engine.tableStreamSerializeMore(container,table.m_tableId,TableStreamType.RECOVERY);
      long endSerializing=System.currentTimeMillis();
      m_timeSpentSerializing.addAndGet(endSerializing - startSerializing);
      recoveryLog.trace("Serialized " + serialized + " for table "+ table.m_name);
      if (serialized <= 0) {
        VoltDB.crashVoltDB();
      }
 else {
        buffer.limit(buffer.position() + serialized);
        buffer.putInt(0,buffer.limit() - 4);
        buffer.position(0);
      }
      m_bytesSent+=buffer.remaining();
      RecoveryMessageType type=RecoveryMessageType.values()[buffer.get(messageTypeOffset)];
      if (type == RecoveryMessageType.Complete) {
        m_tablesToStream.poll();
        RecoveryTable nextTable=m_tablesToStream.peek();
        if (nextTable != null) {
          if (!m_engine.activateTableStream(nextTable.m_tableId,TableStreamType.RECOVERY)) {
            hostLog.error("Attempted to activate recovery stream for table " + nextTable.m_name + " and failed");
            VoltDB.crashVoltDB();
          }
        }
      }
      final int numDestinations=table.m_destinationIds.length;
      m_ackTracker.waitForAcks(buffer.getInt(blockIndexOffset),numDestinations);
      m_outgoing.offer(container);
    }
    if (m_tablesToStream.isEmpty()) {
      if (!m_recoveryComplete) {
synchronized (this) {
          m_recoveryComplete=true;
          BBContainer buffer=null;
          while ((buffer=m_buffers.poll()) != null) {
            m_bufferToOriginMap.remove(buffer).discard();
          }
        }
      }
      if (!m_ackTracker.hasOutstanding()) {
        return;
      }
 else {
        final long startWait=System.currentTimeMillis();
        while (m_inThread.isAlive() && System.currentTimeMillis() - startWait < 5000) {
          checkMailbox(false);
        }
synchronized (this) {
          if (m_inThread.isAlive()) {
            if (m_onCompletion != null) {
              recoveryLog.error("Timed out waiting for acks for the last few recovery messages");
              m_onCompletion.run();
              m_onCompletion=null;
              closeIO();
            }
          }
        }
        return;
      }
    }
    checkMailbox(true);
  }
}
