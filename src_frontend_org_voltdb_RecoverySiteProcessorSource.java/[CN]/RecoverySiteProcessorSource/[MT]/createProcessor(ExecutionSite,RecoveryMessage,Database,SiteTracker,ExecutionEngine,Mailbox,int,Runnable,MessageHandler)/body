{
  final int destinationSiteId=rm.sourceSite();
  boolean isUp=false;
  for (  int up : tracker.getUpExecutionSites()) {
    if (destinationSiteId == up) {
      isUp=true;
    }
  }
  if (!isUp) {
    return null;
  }
  ArrayList<Pair<String,Integer>> tables=new ArrayList<Pair<String,Integer>>();
  Iterator<Table> ti=db.getTables().iterator();
  while (ti.hasNext()) {
    Table t=ti.next();
    if (!CatalogUtil.isTableExportOnly(db,t) && t.getMaterializer() == null) {
      tables.add(Pair.of(t.getTypeName(),t.getRelativeIndex()));
    }
  }
  recoveryLog.info("Found " + tables.size() + " tables to recover");
  HashMap<Pair<String,Integer>,HashSet<Integer>> tableToDestinationSite=new HashMap<Pair<String,Integer>,HashSet<Integer>>();
  for (  Pair<String,Integer> table : tables) {
    recoveryLog.info("Initiating recovery for table " + table.getFirst());
    HashSet<Integer> destinations=tableToDestinationSite.get(table);
    if (destinations == null) {
      destinations=new HashSet<Integer>();
      tableToDestinationSite.put(table,destinations);
    }
    destinations.add(destinationSiteId);
  }
  RecoverySiteProcessorSource source=null;
  try {
    SocketChannel sc=createRecoveryConnection(rm.address(),rm.port());
    final long destinationTxnId=rm.txnId();
    source=new RecoverySiteProcessorSource(site,destinationTxnId,destinationSiteId,tableToDestinationSite,engine,mailbox,siteId,onCompletion,messageHandler,sc);
  }
 catch (  IOException e) {
    recoveryLog.error("Unable to create recovery connection, aborting. " + "The recovery message is: txnId -> " + rm.txnId() + ", address -> "+ rm.address()+ ", port -> "+ rm.port()+ ", source site -> "+ rm.sourceSite(),e);
    return null;
  }
  return source;
}
