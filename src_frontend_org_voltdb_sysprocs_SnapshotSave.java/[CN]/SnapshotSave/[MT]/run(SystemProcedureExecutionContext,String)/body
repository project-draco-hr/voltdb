{
  final long startTime=System.currentTimeMillis();
  JSONObject jsObj=new JSONObject(command);
  final boolean block=jsObj.optBoolean("block",false);
  final String async=!block ? "Asynchronously" : "Synchronously";
  final String path=jsObj.getString("path");
  final String nonce=jsObj.getString("nonce");
  String formatStr=jsObj.optString("format",SnapshotFormat.NATIVE.toString());
  final SnapshotFormat format=SnapshotFormat.getEnumIgnoreCase(formatStr);
  final String data=jsObj.optString("data");
  JSONArray perPartitionTransactionIdsArray=jsObj.optJSONArray("perPartitionTxnIds");
  if (perPartitionTransactionIdsArray == null) {
    HOST_LOG.error("Failed to retrieve per partition transaction ids array from SnapshotDaemon." + "This shouldn't happen and it prevents the snapshot from including transaction ids " + "for partitions that are no longer active in the cluster. Those ids are necessary "+ "to prevent those partitions from generating duplicate unique ids when they are brought back.");
    perPartitionTransactionIdsArray=new JSONArray();
  }
  long perPartitionTxnIds[]=new long[perPartitionTransactionIdsArray.length()];
  for (int ii=0; ii < perPartitionTxnIds.length; ii++) {
    perPartitionTxnIds[ii]=perPartitionTransactionIdsArray.getLong(ii);
  }
  if (format == SnapshotFormat.STREAM) {
    HOST_LOG.info(async + " streaming database, ID: " + nonce+ " at "+ startTime);
  }
 else {
    HOST_LOG.info(async + " saving database to path: " + path+ ", ID: "+ nonce+ " at "+ startTime);
  }
  ColumnInfo[] error_result_columns=new ColumnInfo[2];
  int ii=0;
  error_result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
  error_result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
  if (format.isFileBased() && (path == null || path.equals(""))) {
    VoltTable results[]=new VoltTable[]{new VoltTable(error_result_columns)};
    results[0].addRow("FAILURE","Provided path was null or the empty string");
    return results;
  }
  if (nonce == null || nonce.equals("")) {
    VoltTable results[]=new VoltTable[]{new VoltTable(error_result_columns)};
    results[0].addRow("FAILURE","Provided nonce was null or the empty string");
    return results;
  }
  if (nonce.contains("-") || nonce.contains(",")) {
    VoltTable results[]=new VoltTable[]{new VoltTable(error_result_columns)};
    results[0].addRow("FAILURE","Provided nonce " + nonce + " contains a prohibited character (- or ,)");
    return results;
  }
  VoltTable[] results;
  results=performSaveFeasibilityWork(path,nonce,format,data);
  while (results[0].advanceRow()) {
    if (results[0].getString("RESULT").equals("FAILURE")) {
      results[0].resetRowPosition();
      return results;
    }
  }
  performQuiesce();
  results=performSnapshotCreationWork(path,nonce,ctx.getCurrentTxnId(),perPartitionTxnIds,(byte)(block ? 1 : 0),format,data);
  try {
    JSONStringer stringer=new JSONStringer();
    stringer.object();
    stringer.key("txnId").value(ctx.getCurrentTxnId());
    stringer.endObject();
    setAppStatusString(stringer.toString());
  }
 catch (  Exception e) {
    HOST_LOG.warn(e);
  }
  final long finishTime=System.currentTimeMillis();
  final long duration=finishTime - startTime;
  HOST_LOG.info("Snapshot initiation took " + duration + " milliseconds");
  return results;
}
