{
  if (m_snapshotCreateBarrier == null) {
    m_snapshotCreateBarrier=new CyclicBarrier(VoltDB.instance().getLocalSites().size());
  }
  if (fragmentId == SysProcFragmentId.PF_saveTest) {
    m_snapshotCreateBarrier.reset();
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    String file_path=(String)params.toArray()[0];
    String file_nonce=(String)params.toArray()[1];
    TRACE_LOG.trace("Checking feasibility of save with path and nonce: " + file_path + ", "+ file_nonce);
    VoltTable result=constructNodeResultsTable();
    if (ExecutionSite.ExecutionSitesCurrentlySnapshotting.get() != -1) {
      result.addRow(context.getSite().getHost().getTypeName(),"","FAILURE","SNAPSHOT IN PROGRESS");
      return new DependencyPair(DEP_saveTest,result);
    }
    for (    Table table : getTablesToSave(context)) {
      File saveFilePath=constructFileForTable(table,file_path,file_nonce,context.getSite().getHost().getTypeName());
      TRACE_LOG.trace("Host ID " + context.getSite().getHost().getTypeName() + " table: "+ table.getTypeName()+ " to path: "+ saveFilePath);
      String file_valid="SUCCESS";
      String err_msg="";
      if (saveFilePath.exists()) {
        file_valid="FAILURE";
        err_msg="SAVE FILE ALREADY EXISTS: " + saveFilePath;
      }
 else       if (!saveFilePath.getParentFile().canWrite()) {
        file_valid="FAILURE";
        err_msg="FILE LOCATION UNWRITABLE: " + saveFilePath;
      }
 else {
        try {
          saveFilePath.createNewFile();
        }
 catch (        IOException ex) {
          file_valid="FAILURE";
          err_msg="FILE CREATION OF " + saveFilePath + "RESULTED IN IOException: "+ ex.getMessage();
        }
      }
      result.addRow(context.getSite().getHost().getTypeName(),table.getTypeName(),file_valid,err_msg);
    }
    return new DependencyPair(DEP_saveTest,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_saveTestResults) {
    TRACE_LOG.trace("Aggregating save feasiblity results");
    assert(dependencies.size() > 0);
    List<VoltTable> dep=dependencies.get(DEP_saveTest);
    VoltTable result=constructNodeResultsTable();
    for (    VoltTable table : dep) {
      while (table.advanceRow()) {
        result.add(table);
      }
    }
    return new DependencyPair(DEP_saveTestResults,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_createSnapshotTargets) {
    TRACE_LOG.trace("Creating snapshot target and handing to EEs");
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    final VoltTable result=constructNodeResultsTable();
    boolean willDoSetup=m_snapshotCreateSetupPermit.tryAcquire();
    try {
      if (willDoSetup) {
        assert(ExecutionSite.ExecutionSitesCurrentlySnapshotting.get() == -1);
        final String file_path=(String)params.toArray()[0];
        final String file_nonce=(String)params.toArray()[1];
        final long startTime=(Long)params.toArray()[2];
        final ArrayDeque<SnapshotTableTask> partitionedSnapshotTasks=new ArrayDeque<SnapshotTableTask>();
        final ArrayList<SnapshotTableTask> replicatedSnapshotTasks=new ArrayList<SnapshotTableTask>();
        final ArrayList<String> tableNames=new ArrayList<String>();
        for (        final Table table : getTablesToSave(context)) {
          tableNames.add(table.getTypeName());
        }
        final AtomicInteger numTables=new AtomicInteger(tableNames.size());
        final SnapshotRegistry.Snapshot snapshotRecord=SnapshotRegistry.startSnapshot(startTime,file_path,file_nonce,tableNames.toArray(new String[0]));
        for (        final Table table : getTablesToSave(context)) {
          String canSnapshot="SUCCESS";
          String err_msg="";
          final File saveFilePath=constructFileForTable(table,file_path,file_nonce,context.getSite().getHost().getTypeName());
          try {
            final SnapshotDataTarget sdt=constructSnapshotDataTargetForTable(context,saveFilePath,table,context.getSite().getHost(),context.getCluster().getPartitions().size(),startTime);
            final Runnable onClose=new Runnable(){
              @Override public void run(){
                final long now=System.currentTimeMillis();
                snapshotRecord.updateTable(table.getTypeName(),new SnapshotRegistry.Snapshot.TableUpdater(){
                  @Override public SnapshotRegistry.Snapshot.Table update(                  SnapshotRegistry.Snapshot.Table registryTable){
                    return snapshotRecord.new Table(registryTable,sdt.getBytesWritten(),now);
                  }
                }
);
                int tablesLeft=numTables.decrementAndGet();
                if (tablesLeft == 0) {
                  final SnapshotRegistry.Snapshot completed=SnapshotRegistry.finishSnapshot(snapshotRecord);
                  final double duration=(completed.timeFinished - completed.timeStarted) / 1000.0;
                  HOST_LOG.info("Snapshot " + snapshotRecord.nonce + " finished at "+ completed.timeFinished+ " and took "+ duration+ " seconds ");
                }
              }
            }
;
            sdt.setOnCloseHandler(onClose);
            final SnapshotTableTask task=new SnapshotTableTask(table.getRelativeIndex(),sdt,table.getIsreplicated(),table.getTypeName());
            if (table.getIsreplicated()) {
              replicatedSnapshotTasks.add(task);
            }
 else {
              partitionedSnapshotTasks.offer(task);
            }
          }
 catch (          IOException ex) {
            canSnapshot="FAILURE";
            err_msg="SNAPSHOT INITIATION OF " + saveFilePath + "RESULTED IN IOException: "+ ex.getMessage();
          }
          result.addRow(context.getSite().getHost().getTypeName(),table.getTypeName(),canSnapshot,err_msg);
        }
        ExecutionSite.ExecutionSitesCurrentlySnapshotting.set(VoltDB.instance().getLocalSites().values().size());
        final int numLocalSites=VoltDB.instance().getLocalSites().values().size();
        for (int ii=0; ii < numLocalSites; ii++) {
          m_taskListsForSites.add(new ArrayDeque<SnapshotTableTask>(partitionedSnapshotTasks));
        }
        int siteIndex=0;
        for (        SnapshotTableTask t : replicatedSnapshotTasks) {
          m_taskListsForSites.get(siteIndex++ % numLocalSites).offer(t);
        }
      }
      try {
        m_snapshotCreateBarrier.await();
      }
 catch (      Exception e) {
        result.addRow(context.getSite().getHost().getTypeName(),"","FAILURE",e.toString());
        return new DependencyPair(DEP_createSnapshotTargets,result);
      }
      final Deque<SnapshotTableTask> m_taskList=m_taskListsForSites.remove(0);
      context.getExecutionSite().initiateSnapshots(m_taskList);
      return new DependencyPair(DEP_createSnapshotTargets,result);
    }
  finally {
      if (willDoSetup) {
        m_snapshotCreateSetupPermit.release();
      }
    }
  }
 else   if (fragmentId == SysProcFragmentId.PF_createSnapshotTargetsResults) {
    TRACE_LOG.trace("Aggregating create snapshot target results");
    assert(dependencies.size() > 0);
    List<VoltTable> dep=dependencies.get(DEP_createSnapshotTargets);
    VoltTable result=constructNodeResultsTable();
    for (    VoltTable table : dep) {
      while (table.advanceRow()) {
        result.add(table);
      }
    }
    return new DependencyPair(DEP_createSnapshotTargetsResults,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_saveTables) {
    TRACE_LOG.trace("Blocking to write tables to disk");
    String status="SUCCESS";
    String err="";
    try {
      context.getExecutionSite().completeSnapshotWork();
    }
 catch (    InterruptedException e) {
      status="FAILURE";
      err=e.toString();
    }
    VoltTable result=constructPartitionResultsTable();
    result.addRow(context.getSite().getHost().getTypeName(),context.getSite().getTypeName(),status,err);
    return new DependencyPair(DEP_saveTables,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_saveTablesResults) {
    TRACE_LOG.trace("Aggregating save results");
    assert(dependencies.size() > 0);
    List<VoltTable> dep=dependencies.get(DEP_saveTables);
    VoltTable result=constructPartitionResultsTable();
    for (    VoltTable table : dep) {
      while (table.advanceRow()) {
        result.add(table);
      }
    }
    return new DependencyPair(DEP_saveTablesResults,result);
  }
  assert(false);
  return null;
}
