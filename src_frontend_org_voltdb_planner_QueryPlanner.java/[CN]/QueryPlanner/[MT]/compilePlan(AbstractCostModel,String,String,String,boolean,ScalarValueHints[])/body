{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  PlanAssembler.setUseGlobalIds(m_useGlobalIds);
  String xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (!m_quietPlanner) {
    PrintStream xmlDebugOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-hsql-xml",procName + "_" + stmtName+ ".xml");
    xmlDebugOut.println(xmlSQL);
    xmlDebugOut.close();
  }
  AbstractParsedStmt initialParsedStmt=null;
  try {
    initialParsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db);
  }
 catch (  Exception e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (initialParsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if (!m_quietPlanner) {
    PrintStream parsedDebugOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-parsed",procName + "_" + stmtName+ ".txt");
    parsedDebugOut.println(initialParsedStmt.toString());
    parsedDebugOut.close();
  }
  CompiledPlan rawplan=null;
  CompiledPlan bestPlan=null;
  double minCost=Double.MAX_VALUE;
  HashMap<String,String> planOutputs=new HashMap<String,String>();
  HashMap<String,String> dotPlanOutputs=new HashMap<String,String>();
  String winnerName="";
  int i=0;
  PlanStatistics stats=null;
  for (  AbstractParsedStmt parsedStmt : ExpressionEquivalenceProcessor.getEquivalentStmts(initialParsedStmt)) {
    m_assembler.setupForNewPlans(parsedStmt,singlePartition);
    while (true) {
      try {
        rawplan=m_assembler.getNextPlan();
      }
 catch (      PlanningErrorException e) {
        m_recentErrorMsg=e.getMessage();
        return null;
      }
      if (rawplan == null)       break;
      List<CompiledPlan> optimizedPlans=MicroOptimizationRunner.applyAll(rawplan);
      for (      CompiledPlan plan : optimizedPlans) {
        stats=new PlanStatistics();
        AbstractPlanNode planGraph=plan.fragments.get(0).planGraph;
        boolean result=planGraph.computeEstimatesRecursively(stats,m_cluster,m_db,m_estimates,paramHints);
        assert(result);
        PlanNodeList nodeList=new PlanNodeList(planGraph);
        String json=null;
        try {
          String crunchJson=nodeList.toJSONString();
          JSONObject jobj=new JSONObject(crunchJson);
          json=jobj.toString(4);
        }
 catch (        JSONException e2) {
          m_recentErrorMsg="Plan for sql: '" + sql + "' can't be serialized to JSON";
          return null;
        }
        double cost=costModel.getPlanCost(stats);
        if (cost < minCost) {
          minCost=cost;
          if (bestPlan != null) {
            bestPlan.freePlan(m_context);
          }
          bestPlan=plan;
        }
 else {
          plan.freePlan(m_context);
        }
        String filename=String.valueOf(i++);
        if (bestPlan == plan)         winnerName=filename;
        json="COST: " + String.valueOf(cost) + "\n"+ json;
        planOutputs.put(filename,json);
        dotPlanOutputs.put(filename,nodeList.toDOTString("name"));
      }
    }
  }
  if (bestPlan == null) {
    m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    return null;
  }
  bestPlan.resetPlanNodeIds();
  if (!m_quietPlanner) {
    for (    Entry<String,String> output : planOutputs.entrySet()) {
      String filename=output.getKey();
      if (winnerName.equals(filename)) {
        filename="WINNER " + filename;
      }
      PrintStream candidatePlanOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-all-plans/" + procName + "_"+ stmtName,filename + ".txt");
      candidatePlanOut.println(output.getValue());
      candidatePlanOut.close();
    }
    for (    Entry<String,String> output : dotPlanOutputs.entrySet()) {
      String filename=output.getKey();
      if (winnerName.equals(filename)) {
        filename="WINNER " + filename;
      }
      PrintStream candidatePlanOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-all-plans/" + procName + "_"+ stmtName,filename + ".dot");
      candidatePlanOut.println(output.getValue());
      candidatePlanOut.close();
    }
    PrintStream plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-stats",procName + "_" + stmtName+ ".txt");
    plansOut.println(stats.toString());
    plansOut.close();
  }
  bestPlan=Fragmentizer.fragmentize(bestPlan,m_db);
  if (bestPlan.fragments.size() > 2) {
    m_recentErrorMsg="Unable to plan for statement. Likely statement is " + "joining two partitioned tables in a multi-partition statement. " + "This is not supported at this time.";
    return null;
  }
  return bestPlan;
}
