{
  m_assembler.setupForNewPlans(parsedStmt);
  CompiledPlan rawplan=null;
  CompiledPlan bestPlan=null;
  String bestFilename=null;
  double minCost=Double.MAX_VALUE;
  PlanStatistics stats=null;
  while (true) {
    try {
      rawplan=m_assembler.getNextPlan(isPlanFinal);
    }
 catch (    PlanningErrorException e) {
      m_recentErrorMsg=e.getMessage();
      return null;
    }
    if (rawplan == null)     break;
    List<CompiledPlan> optimizedPlans=MicroOptimizationRunner.applyAll(rawplan);
    for (    CompiledPlan plan : optimizedPlans) {
      plan.sql=sql;
      plan.rootPlanGraph.resolveColumnIndexes();
      stats=new PlanStatistics();
      AbstractPlanNode planGraph=plan.rootPlanGraph;
      boolean result=planGraph.computeEstimatesRecursively(stats,m_cluster,m_db,m_estimates,paramHints);
      assert(result);
      plan.cost=costModel.getPlanCost(stats);
      String filename=String.valueOf(planIdRange[0]++);
      if (plan.cost < minCost) {
        minCost=plan.cost;
        bestPlan=plan;
        bestFilename=filename;
      }
      if (!m_quietPlanner) {
        if (m_fullDebug) {
          outputPlanFullDebug(plan,planGraph,stmtName,procName,filename);
        }
        plan.explainedPlan=planGraph.toExplainPlanString();
        outputExplainedPlan(stmtName,procName,plan,filename);
      }
    }
    planIdRange[1]=planIdRange[0];
  }
  if (isPlanFinal && bestPlan != null && !m_quietPlanner) {
    finalizeOutput(stmtName,procName,bestFilename,stats);
  }
  return bestPlan;
}
