{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  AbstractPlanNode.resetPlanNodeIds();
  VoltXMLElement xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  PlanSelector planSelector=new PlanSelector(m_cluster,m_db,m_estimates,stmtName,procName,sql,costModel,paramHints,m_quietPlanner,m_fullDebug);
  planSelector.outputCompiledStatement(xmlSQL);
  PlanAssembler assembler=new PlanAssembler(m_cluster,m_db,m_partitioning,planSelector);
  AbstractParsedStmt parsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db,joinOrder);
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  planSelector.outputParsedStatement(parsedStmt);
  CompiledPlan bestPlan=assembler.getBestCostPlan(parsedStmt);
  if (bestPlan == null) {
    m_recentErrorMsg=assembler.getErrorMessage();
    if (m_recentErrorMsg == null) {
      m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    }
    return null;
  }
  if (bestPlan.readOnly) {
    SendPlanNode sendNode=new SendPlanNode();
    sendNode.addAndLinkChild(bestPlan.rootPlanGraph);
    sendNode.generateOutputSchema(m_db);
    bestPlan.rootPlanGraph=sendNode;
  }
  planSelector.finalizeOutput(bestPlan,planSelector.m_bestFilename,planSelector.m_stats);
  bestPlan.resetPlanNodeIds();
  Fragmentizer.fragmentize(bestPlan,m_db);
  return bestPlan;
}
