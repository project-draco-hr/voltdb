{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  AbstractPlanNode.resetPlanNodeIds();
  VoltXMLElement xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputCompiledStatement(stmtName,procName,xmlSQL);
  }
  AbstractParsedStmt parsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db,joinOrder);
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputParsedStatement(stmtName,procName,parsedStmt);
  }
  CompiledPlan bestPlan=null;
  if (parsedStmt instanceof ParsedUnionStmt) {
    m_assembler.verifyTablePatition(parsedStmt);
    ParsedUnionStmt parsedUnionStmt=(ParsedUnionStmt)parsedStmt;
    ArrayList<CompiledPlan> childrenPlans=new ArrayList<CompiledPlan>();
    NextPlanParams planParams=new NextPlanParams();
    planParams.m_isFinal=false;
    for (    AbstractParsedStmt parsedSelectStmt : parsedUnionStmt.m_children) {
      CompiledPlan bestSelectPlan=getBestCostPlan(parsedSelectStmt,costModel,sql,joinOrder,stmtName,procName,paramHints,planParams);
      if (bestSelectPlan == null) {
        m_recentErrorMsg="Unable to plan for statement. Error unknown.";
        return null;
      }
      childrenPlans.add(bestSelectPlan);
    }
    bestPlan=m_assembler.getNextUnionPlan(parsedStmt,parsedUnionStmt.m_unionType,childrenPlans);
    bestPlan.sql=sql;
    boolean orderIsDeterministic=true;
    boolean contentIsDeterministic=true;
    for (    CompiledPlan childPlan : childrenPlans) {
      orderIsDeterministic=orderIsDeterministic && childPlan.isOrderDeterministic();
      contentIsDeterministic=contentIsDeterministic && childPlan.isContentDeterministic();
    }
    bestPlan.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    bestPlan.cost=0.0;
    for (    CompiledPlan bestSelectPlan : childrenPlans) {
      bestPlan.cost+=bestSelectPlan.cost;
    }
    String filename=String.valueOf(planParams.m_counter++);
    if (!m_quietPlanner) {
      if (m_fullDebug) {
        outputPlanFullDebug(bestPlan,bestPlan.rootPlanGraph,stmtName,procName,filename);
      }
      bestPlan.explainedPlan=bestPlan.rootPlanGraph.toExplainPlanString();
      outputExplainedPlan(stmtName,procName,bestPlan,filename);
    }
    PlanStatistics stats=new PlanStatistics();
    if (bestPlan != null && !m_quietPlanner) {
      finalizeOutput(stmtName,procName,filename,stats);
    }
  }
 else {
    boolean needSendReceive=true;
    NextPlanParams planParams=new NextPlanParams();
    bestPlan=getBestCostPlan(parsedStmt,costModel,sql,joinOrder,stmtName,procName,paramHints,planParams);
  }
  if (bestPlan == null) {
    m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    return null;
  }
  bestPlan.resetPlanNodeIds();
  Fragmentizer.fragmentize(bestPlan,m_db);
  return bestPlan;
}
