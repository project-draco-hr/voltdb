{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  AbstractPlanNode.resetPlanNodeIds();
  VoltXMLElement xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputCompiledStatement(stmtName,procName,xmlSQL);
  }
  AbstractParsedStmt parsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db,joinOrder);
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputParsedStatement(stmtName,procName,parsedStmt);
  }
  CompiledPlan bestPlan=null;
  if (parsedStmt instanceof ParsedUnionStmt) {
    ParsedUnionStmt parsedUnionStmt=(ParsedUnionStmt)parsedStmt;
    ArrayList<CompiledPlan> childrenPlans=new ArrayList<CompiledPlan>();
    boolean orderIsDeterministic=true;
    boolean contentIsDeterministic=true;
    boolean isPlanFinal=false;
    ArrayList<PartitioningForStatement> partitioningList=new ArrayList<PartitioningForStatement>();
    int planIdRange[]={0,1};
    for (    AbstractParsedStmt parsedChildStmt : parsedUnionStmt.m_children) {
      PartitioningForStatement partitioning=new PartitioningForStatement(null,false,true);
      CompiledPlan bestChildPlan=getBestCostPlan(parsedChildStmt,costModel,sql,joinOrder,stmtName,procName,paramHints,isPlanFinal,planIdRange,partitioning);
      if (bestChildPlan == null) {
        m_recentErrorMsg="Unable to plan for statement. Error unknown.";
        return null;
      }
      childrenPlans.add(bestChildPlan);
      orderIsDeterministic=orderIsDeterministic && bestChildPlan.isOrderDeterministic();
      contentIsDeterministic=contentIsDeterministic && bestChildPlan.isContentDeterministic();
      partitioningList.add(partitioning);
    }
    boolean hasPrtitionedTable=false;
    for (    PartitioningForStatement partition : partitioningList) {
      if (partition.getCountOfIndependentlyPartitionedTables() > 0)       if (!hasPrtitionedTable) {
        hasPrtitionedTable=true;
      }
 else {
        m_recentErrorMsg="Unable to plan for statement. More than one partitioned table in the union.";
        return null;
      }
    }
    bestPlan=m_assembler.getNextUnionPlan(parsedStmt,parsedUnionStmt.m_unionType,childrenPlans);
    bestPlan.sql=sql;
    bestPlan.statementGuaranteesDeterminism(contentIsDeterministic,orderIsDeterministic);
    bestPlan.cost=0.0;
    for (    CompiledPlan bestChildPlan : childrenPlans) {
      bestPlan.cost+=bestChildPlan.cost;
    }
    String filename=Integer.toString(planIdRange[1]);
    if (!m_quietPlanner) {
      if (m_fullDebug) {
        outputPlanFullDebug(bestPlan,bestPlan.rootPlanGraph,stmtName,procName,filename);
      }
      bestPlan.explainedPlan=bestPlan.rootPlanGraph.toExplainPlanString();
      outputExplainedPlan(stmtName,procName,bestPlan,filename);
    }
    PlanStatistics stats=new PlanStatistics();
    if (bestPlan != null && !m_quietPlanner) {
      finalizeOutput(stmtName,procName,filename,stats);
    }
  }
 else {
    boolean isPlanFinal=true;
    int planIdRange[]={0,1};
    bestPlan=getBestCostPlan(parsedStmt,costModel,sql,joinOrder,stmtName,procName,paramHints,isPlanFinal,planIdRange,null);
  }
  if (bestPlan == null) {
    m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    return null;
  }
  bestPlan.resetPlanNodeIds();
  Fragmentizer.fragmentize(bestPlan,m_db);
  return bestPlan;
}
