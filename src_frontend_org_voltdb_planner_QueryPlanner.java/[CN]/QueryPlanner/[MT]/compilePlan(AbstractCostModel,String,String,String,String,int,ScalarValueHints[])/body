{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  AbstractPlanNode.setUseGlobalIds(m_useGlobalIds);
  VoltXMLElement xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputCompiledStatement(stmtName,procName,xmlSQL);
  }
  AbstractParsedStmt parsedStmt=null;
  try {
    parsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db,joinOrder);
  }
 catch (  Exception e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    outputParsedStatement(stmtName,procName,parsedStmt);
  }
  CompiledPlan rawplan=null;
  CompiledPlan bestPlan=null;
  String bestFilename=null;
  double minCost=Double.MAX_VALUE;
  int planCounter=0;
  PlanStatistics stats=null;
{
    m_assembler.setupForNewPlans(parsedStmt);
    while (true) {
      try {
        rawplan=m_assembler.getNextPlan();
      }
 catch (      PlanningErrorException e) {
        m_recentErrorMsg=e.getMessage();
        return null;
      }
      if (rawplan == null)       break;
      List<CompiledPlan> optimizedPlans=MicroOptimizationRunner.applyAll(rawplan);
      for (      CompiledPlan plan : optimizedPlans) {
        plan.sql=sql;
        plan.fragments.get(0).planGraph.resolveColumnIndexes();
        stats=new PlanStatistics();
        AbstractPlanNode planGraph=plan.fragments.get(0).planGraph;
        boolean result=planGraph.computeEstimatesRecursively(stats,m_cluster,m_db,m_estimates,paramHints);
        assert(result);
        plan.cost=costModel.getPlanCost(stats);
        String filename=String.valueOf(planCounter++);
        if (plan.cost < minCost) {
          minCost=plan.cost;
          bestPlan=plan;
          bestFilename=filename;
        }
        if (!m_quietPlanner) {
          if (m_fullDebug) {
            outputPlanFullDebug(plan,planGraph,stmtName,procName,filename);
          }
          plan.explainedPlan=planGraph.toExplainPlanString();
          outputExplainedPlan(stmtName,procName,plan,filename);
        }
      }
    }
  }
  if (bestPlan == null) {
    m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    return null;
  }
  bestPlan.resetPlanNodeIds();
  if (!m_quietPlanner) {
    finalizeOutput(stmtName,procName,bestFilename,stats);
  }
  bestPlan=Fragmentizer.fragmentize(bestPlan,m_db);
  if (bestPlan.fragments.size() > 2) {
    m_recentErrorMsg="Unable to plan for statement. Possibly " + "joining partitioned tables in a multi-partition procedure " + "using a column that is not the partitioning attribute "+ "or a non-equality operator. "+ "This is statement not supported at this time.";
    return null;
  }
  return bestPlan;
}
