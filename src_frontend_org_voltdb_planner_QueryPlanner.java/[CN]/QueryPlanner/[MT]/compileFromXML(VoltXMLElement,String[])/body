{
  AbstractParsedStmt parsedStmt=AbstractParsedStmt.parse(m_sql,xmlSQL,paramValues,m_db,m_joinOrder);
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + m_sql;
    return null;
  }
  if ((parsedStmt.m_tableList.size() > m_maxTablesPerJoin) && (parsedStmt.m_joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + m_sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  m_planSelector.outputParsedStatement(parsedStmt);
  PlanAssembler assembler=new PlanAssembler(m_cluster,m_db,m_partitioning,(PlanSelector)m_planSelector.clone());
  CompiledPlan bestPlan=assembler.getBestCostPlan(parsedStmt);
  if (bestPlan == null) {
    if (debuggingSoRetryOnError) {
      assembler.getBestCostPlan(parsedStmt);
    }
    m_recentErrorMsg=assembler.getErrorMessage();
    if (m_recentErrorMsg == null) {
      m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    }
    return null;
  }
  if (bestPlan.readOnly) {
    SendPlanNode sendNode=new SendPlanNode();
    sendNode.addAndLinkChild(bestPlan.rootPlanGraph);
    bestPlan.rootPlanGraph=sendNode;
  }
  bestPlan.rootPlanGraph.generateOutputSchema(m_db);
  bestPlan.rootPlanGraph.resolveColumnIndexes();
  if (parsedStmt instanceof ParsedSelectStmt) {
    List<SchemaColumn> columns=bestPlan.rootPlanGraph.getOutputSchema().getColumns();
    ((ParsedSelectStmt)parsedStmt).checkPlanColumnMatch(columns);
  }
  assembler.finalizeBestCostPlan();
  bestPlan.resetPlanNodeIds();
  fragmentize(bestPlan);
  return bestPlan;
}
