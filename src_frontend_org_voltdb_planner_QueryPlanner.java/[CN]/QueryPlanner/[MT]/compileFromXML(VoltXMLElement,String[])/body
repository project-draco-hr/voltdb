{
  AbstractParsedStmt parsedStmt=AbstractParsedStmt.parse(m_sql,xmlSQL,paramValues,m_db,m_joinOrder);
  if (parsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + m_sql;
    return null;
  }
  if ((parsedStmt.tableList.size() > m_maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + m_sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  m_planSelector.outputParsedStatement(parsedStmt);
  PlanAssembler assembler=new PlanAssembler(m_cluster,m_db,m_partitioning,(PlanSelector)m_planSelector.clone());
  CompiledPlan bestPlan=assembler.getBestCostPlan(parsedStmt);
  if (bestPlan == null) {
    m_recentErrorMsg=assembler.getErrorMessage();
    if (m_recentErrorMsg == null) {
      m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    }
    return null;
  }
  if (bestPlan.readOnly == true) {
    SendPlanNode sendNode=new SendPlanNode();
    sendNode.addAndLinkChild(bestPlan.rootPlanGraph);
    bestPlan.rootPlanGraph=sendNode;
  }
  bestPlan.rootPlanGraph.generateOutputSchema(m_db);
  bestPlan.rootPlanGraph.resolveColumnIndexes();
  assembler.finalizeBestCostPlan();
  bestPlan.resetPlanNodeIds();
  Fragmentizer.fragmentize(bestPlan,m_db);
  return bestPlan;
}
