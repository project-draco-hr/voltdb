{
  assert(costModel != null);
  assert(sql != null);
  assert(stmtName != null);
  assert(procName != null);
  m_recentErrorMsg=null;
  AbstractPlanNode.setUseGlobalIds(m_useGlobalIds);
  VoltXMLElement xmlSQL=null;
  try {
    xmlSQL=m_HSQL.getXMLCompiledStatement(sql);
  }
 catch (  HSQLParseException e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    PrintStream xmlDebugOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-hsql-xml",procName + "_" + stmtName+ ".xml");
    xmlDebugOut.println(xmlSQL.toString());
    xmlDebugOut.close();
  }
  AbstractParsedStmt initialParsedStmt=null;
  try {
    initialParsedStmt=AbstractParsedStmt.parse(sql,xmlSQL,m_db,joinOrder);
  }
 catch (  Exception e) {
    m_recentErrorMsg=e.getMessage();
    return null;
  }
  if (initialParsedStmt == null) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql;
    return null;
  }
  if ((initialParsedStmt.tableList.size() > maxTablesPerJoin) && (initialParsedStmt.joinOrder == null)) {
    m_recentErrorMsg="Failed to parse SQL statement: " + sql + " because a join of > 5 tables was requested"+ " without specifying a join order. See documentation for instructions on manually"+ " specifying a join order";
    return null;
  }
  if (!m_quietPlanner && m_fullDebug) {
    PrintStream parsedDebugOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-parsed",procName + "_" + stmtName+ ".txt");
    parsedDebugOut.println(initialParsedStmt.toString());
    parsedDebugOut.close();
  }
  CompiledPlan rawplan=null;
  CompiledPlan bestPlan=null;
  String bestFilename=null;
  double minCost=Double.MAX_VALUE;
  int i=0;
  PlanStatistics stats=null;
  for (  AbstractParsedStmt parsedStmt : ExpressionEquivalenceProcessor.getEquivalentStmts(initialParsedStmt)) {
    m_assembler.setupForNewPlans(parsedStmt,singlePartition);
    while (true) {
      try {
        rawplan=m_assembler.getNextPlan();
      }
 catch (      PlanningErrorException e) {
        m_recentErrorMsg=e.getMessage();
        return null;
      }
      if (rawplan == null)       break;
      List<CompiledPlan> optimizedPlans=MicroOptimizationRunner.applyAll(rawplan);
      for (      CompiledPlan plan : optimizedPlans) {
        plan.sql=sql;
        plan.fragments.get(0).planGraph.resolveColumnIndexes();
        stats=new PlanStatistics();
        AbstractPlanNode planGraph=plan.fragments.get(0).planGraph;
        boolean result=planGraph.computeEstimatesRecursively(stats,m_cluster,m_db,m_estimates,paramHints);
        assert(result);
        plan.cost=costModel.getPlanCost(stats);
        String filename=String.valueOf(i++);
        if (plan.cost < minCost) {
          minCost=plan.cost;
          bestPlan=plan;
          bestFilename=filename;
        }
        PlanNodeList nodeList=new PlanNodeList(planGraph);
        String json=null;
        if (!m_quietPlanner) {
          if (m_fullDebug) {
            try {
              String crunchJson=nodeList.toJSONString();
              JSONObject jobj=new JSONObject(crunchJson);
              json=jobj.toString(4);
            }
 catch (            JSONException e2) {
              m_recentErrorMsg="Plan for sql: '" + sql + "' can't be serialized to JSON";
              return null;
            }
            json="PLAN:\n" + json;
            json="COST: " + String.valueOf(plan.cost) + "\n"+ json;
            assert(plan.sql != null);
            json="SQL: " + plan.sql + "\n"+ json;
            PrintStream candidatePlanOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-all-plans/" + procName + "_"+ stmtName,filename + "-json.txt");
            candidatePlanOut.println(json);
            candidatePlanOut.close();
            candidatePlanOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-all-plans/" + procName + "_"+ stmtName,filename + ".dot");
            candidatePlanOut.println(nodeList.toDOTString("name"));
            candidatePlanOut.close();
          }
          plan.explainedPlan=planGraph.toExplainPlanString();
          PrintStream candidatePlanOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-all-plans/" + procName + "_"+ stmtName,filename + ".txt");
          candidatePlanOut.println(plan.explainedPlan);
          candidatePlanOut.close();
        }
      }
    }
  }
  if (bestPlan == null) {
    m_recentErrorMsg="Unable to plan for statement. Error unknown.";
    return null;
  }
  bestPlan.resetPlanNodeIds();
  if (!m_quietPlanner) {
    String prefix=BuildDirectoryUtils.getBuildDirectoryPath() + "/" + BuildDirectoryUtils.rootPath+ "statement-all-plans/"+ procName+ "_"+ stmtName+ "/";
    String winnerFilename, winnerFilenameRenamed;
    File winnerFile, winnerFileRenamed;
    if (m_fullDebug) {
      winnerFilename=prefix + bestFilename + "-json.txt";
      winnerFile=new File(winnerFilename);
      winnerFilenameRenamed=prefix + "WINNER-" + bestFilename+ "-json.txt";
      winnerFileRenamed=new File(winnerFilenameRenamed);
      winnerFile.renameTo(winnerFileRenamed);
      winnerFilename=prefix + bestFilename + ".dot";
      winnerFile=new File(winnerFilename);
      winnerFilenameRenamed=prefix + "WINNER-" + bestFilename+ ".dot";
      winnerFileRenamed=new File(winnerFilenameRenamed);
      winnerFile.renameTo(winnerFileRenamed);
    }
    winnerFilename=prefix + bestFilename + ".txt";
    winnerFile=new File(winnerFilename);
    winnerFilenameRenamed=prefix + "WINNER-" + bestFilename+ ".txt";
    winnerFileRenamed=new File(winnerFilenameRenamed);
    winnerFile.renameTo(winnerFileRenamed);
    if (m_fullDebug) {
      PrintStream plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-stats",procName + "_" + stmtName+ ".txt");
      plansOut.println(stats.toString());
      plansOut.close();
    }
  }
  bestPlan=Fragmentizer.fragmentize(bestPlan,m_db);
  if (bestPlan.fragments.size() > 2) {
    m_recentErrorMsg="Unable to plan for statement. Likely statement is " + "joining two partitioned tables in a multi-partition statement on non-partitioned key. " + "This is not supported at this time.";
    return null;
  }
  return bestPlan;
}
