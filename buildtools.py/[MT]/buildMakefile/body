def buildMakefile(CTX):
    global version
    CPPFLAGS = ' '.join(CTX.CPPFLAGS.split())
    MAKECPPFLAGS = CPPFLAGS
    for dir in CTX.SYSTEM_DIRS:
        MAKECPPFLAGS += (' -isystem ../../%s' % dir)
    for dir in CTX.INCLUDE_DIRS:
        MAKECPPFLAGS += (' -I../../%s' % dir)
    LOCALCPPFLAGS = CPPFLAGS
    for dir in CTX.SYSTEM_DIRS:
        LOCALCPPFLAGS += (' -isystem %s' % dir)
    for dir in CTX.INCLUDE_DIRS:
        LOCALCPPFLAGS += (' -I%s' % dir)
    JNILIBFLAGS = ' '.join(CTX.JNILIBFLAGS.split())
    JNIBINFLAGS = ' '.join(CTX.JNIBINFLAGS.split())
    INPUT_PREFIX = CTX.INPUT_PREFIX.rstrip('/')
    THIRD_PARTY_INPUT_PREFIX = CTX.THIRD_PARTY_INPUT_PREFIX.rstrip('/')
    OUTPUT_PREFIX = CTX.OUTPUT_PREFIX.rstrip('/')
    TEST_PREFIX = CTX.TEST_PREFIX.rstrip('/')
    IGNORE_SYS_PREFIXES = CTX.IGNORE_SYS_PREFIXES
    JNIEXT = CTX.JNIEXT.strip()
    NM = CTX.NM
    NMFLAGS = CTX.NMFLAGS
    LIBS = (((' ' + CTX.INPUT_LIBS) + ' ') + CTX.THIRD_PARTY_LIBS)
    os.system(('mkdir -p %s' % OUTPUT_PREFIX))
    os.system(('mkdir -p %s' % (OUTPUT_PREFIX + '/nativelibs')))
    os.system(('mkdir -p %s' % (OUTPUT_PREFIX + '/objects')))
    os.system(('mkdir -p %s' % (OUTPUT_PREFIX + '/static_objects')))
    os.system(('mkdir -p %s' % (OUTPUT_PREFIX + '/cpptests')))
    os.system(('mkdir -p %s' % (OUTPUT_PREFIX + '/prod')))
    input_paths = []
    for dir in CTX.INPUT.keys():
        input = CTX.INPUT[dir].split()
        cppflags = ''
        includes = []
        if (dir in CTX.INPUT_CPPFLAGS):
            cppflags += (' ' + CTX.INPUT_CPPFLAGS[dir])
        if (dir in CTX.INPUT_INCLUDES):
            includes += CTX.INPUT_INCLUDES
        input_paths += [{'filename': ((((INPUT_PREFIX + '/') + dir) + '/') + x), 'cppflags': cppflags, 'includes': includes, } for x in input]
    third_party_input_paths = []
    for dir in CTX.THIRD_PARTY_INPUT.keys():
        flags = ''
        includes = []
        if (dir in CTX.THIRD_PARTY_CPPFLAGS):
            flags += (' ' + CTX.THIRD_PARTY_CPPFLAGS[dir])
        if (dir in CTX.THIRD_PARTY_INCLUDES):
            includes += CTX.THIRD_PARTY_INCLUDES[dir]
        input = CTX.THIRD_PARTY_INPUT[dir].split()
        third_party_input_paths += [{'filename': ((((THIRD_PARTY_INPUT_PREFIX + '/') + dir) + '/') + x), 'cppflags': flags, 'includes': includes, } for x in input]
    tests = []
    for dir in CTX.TESTS.keys():
        input = CTX.TESTS[dir].split()
        tests += [((((TEST_PREFIX + '/') + dir) + '/') + x) for x in input]
    makefile = file((OUTPUT_PREFIX + '/makefile'), 'w')
    makefile.write(('CC = %s\n' % CTX.CC))
    makefile.write(('CXX = %s\n' % CTX.CXX))
    makefile.write(('CPPFLAGS += %s\n' % MAKECPPFLAGS))
    makefile.write(('LDFLAGS += %s\n' % CTX.LDFLAGS))
    makefile.write(('JNILIBFLAGS += %s\n' % JNILIBFLAGS))
    makefile.write(('JNIBINFLAGS += %s\n' % JNIBINFLAGS))
    makefile.write(('JNIEXT = %s\n' % JNIEXT))
    makefile.write(('SRC = ../../%s\n' % INPUT_PREFIX))
    makefile.write(('THIRD_PARTY_SRC = ../../%s\n' % THIRD_PARTY_INPUT_PREFIX))
    makefile.write(('NM = %s\n' % NM))
    makefile.write(('NMFLAGS = %s\n' % NMFLAGS))
    makefile.write(('LIBS = %s\n' % LIBS))
    makefile.write('\n')
    if (CTX.TARGET == 'CLEAN'):
        makefile.write('.PHONY: clean\n')
        makefile.write('clean: \n')
        makefile.write('\trm -rf *\n')
        makefile.close()
        return
    makefile.write('.PHONY: main\n')
    if (CTX.TARGET == 'VOLTRUN'):
        makefile.write('main: prod/voltrun\n')
    elif (CTX.TARGET == 'TEST'):
        makefile.write('main: ')
    else:
        makefile.write(('main: nativelibs/libvoltdb-%s.$(JNIEXT)\n' % version))
    makefile.write('\n')
    jni_objects = []
    static_objects = []
    for file_descr in input_paths:
        filename = file_descr['filename']
        (jni, static) = outputNamesForSource(filename)
        jni_objects.append(jni)
        static_objects.append(static)
    for file_descr in third_party_input_paths:
        filename = file_descr['filename']
        (jni, static) = outputNamesForSource(filename)
        jni_objects.append(jni)
        static_objects.append(static)
    makefile.write(('# create symbols by running nm against libvoltdb-%s\n' % version))
    makefile.write(('nativelibs/libvoltdb-%s.sym: nativelibs/libvoltdb-%s.$(JNIEXT)\n' % (version, version)))
    makefile.write(('\t$(NM) $(NMFLAGS) nativelibs/libvoltdb-%s.$(JNIEXT) > $@\n' % version))
    makefile.write('\n')
    makefile.write('# main jnilib target\n')
    makefile.write(((('nativelibs/libvoltdb-%s.$(JNIEXT): ' % version) + ' '.join(jni_objects)) + '\n'))
    makefile.write('\t$(LINK.cpp) $(JNILIBFLAGS) -o $@ $^ $(LIBS)\n')
    makefile.write('\n')
    makefile.write('# voltdb instance that loads the jvm from C++\n')
    makefile.write((('prod/voltrun: $(SRC)/voltrun.cpp ' + ' '.join(static_objects)) + '\n'))
    makefile.write('\t$(LINK.cpp) $(JNIBINFLAGS) -o $@ $^ $(LIBS)\n')
    makefile.write('\n')
    makefile.write('# voltdb execution engine that accepts work on a tcp socket (vs. jni)\n')
    makefile.write(('prod/voltdbipc: $(SRC)/voltdbipc.cpp ' + ' objects/volt.a\n'))
    makefile.write(('\t$(LINK.cpp) -o $@ $^ %s\n' % CTX.LASTLDFLAGS))
    makefile.write('\n')
    makefile.write('.PHONY: test\n')
    makefile.write('test: ')
    for test in tests:
        (binname, objectname, sourcename) = namesForTestCode(test)
        makefile.write((binname + ' '))
    if (CTX.LEVEL == 'MEMCHECK'):
        makefile.write('prod/voltdbipc')
    if (CTX.LEVEL == 'MEMCHECK_NOFREELIST'):
        makefile.write('prod/voltdbipc')
    makefile.write('\n\n')
    makefile.write((('objects/volt.a: ' + ' '.join(jni_objects)) + ' objects/harness.o\n'))
    makefile.write('\t$(AR) $(ARFLAGS) $@ $?\n')
    makefile.write((('objects/harness.o: ../../' + TEST_PREFIX) + '/harness.cpp\n'))
    makefile.write('\t$(CCACHE) $(COMPILE.cpp) -o $@ $^\n')
    makefile.write('\t$(CCACHE) $(COMPILE.cpp) -o $@ $^\n')
    makefile.write('\n')
    LOCALTESTCPPFLAGS = (LOCALCPPFLAGS + (' -I%s' % TEST_PREFIX))
    for file_descr in input_paths:
        filename = file_descr['filename']
        cppflags = file_descr['cppflags']
        includes = ' '.join([('-I ../../%s' % include_name) for include_name in file_descr['includes']])
        (jni_objname, static_objname) = outputNamesForSource(filename)
        filename = filename.replace(INPUT_PREFIX, '$(SRC)')
        jni_targetpath = ((OUTPUT_PREFIX + '/') + '/'.join(jni_objname.split('/')[:(-1)]))
        static_targetpath = ((OUTPUT_PREFIX + '/') + '/'.join(static_objname.split('/')[:(-1)]))
        os.system(('mkdir -p %s' % jni_targetpath))
        os.system(('mkdir -p %s' % static_targetpath))
        makefile.write(('\n-include %s\n' % replaceExtension(jni_objname, '.d')))
        makefile.write((jni_objname + ':\n'))
        makefile.write(('\t$(CCACHE) $(COMPILE.cpp) %s %s %s -MMD -MP -o $@ %s\n' % (CTX.EXTRAFLAGS, cppflags, includes, filename)))
        makefile.write(('\n-include %s\n' % replaceExtension(static_objname, '.d')))
        makefile.write((static_objname + ':\n'))
        makefile.write(('\t$(CCACHE) $(COMPILE.cpp) %s %s %s -MMD -MP -o $@ %s\n' % (CTX.EXTRAFLAGS, cppflags, includes, filename)))
    makefile.write('\n')
    for file_descr in third_party_input_paths:
        filename = file_descr['filename']
        cppflags = file_descr['cppflags']
        includes = ' '.join([('-I ../../%s' % include_name) for include_name in file_descr['includes']])
        (jni_objname, static_objname) = outputNamesForSource(filename)
        filename = filename.replace(THIRD_PARTY_INPUT_PREFIX, '$(THIRD_PARTY_SRC)')
        jni_targetpath = ((OUTPUT_PREFIX + '/') + '/'.join(jni_objname.split('/')[:(-1)]))
        static_targetpath = ((OUTPUT_PREFIX + '/') + '/'.join(static_objname.split('/')[:(-1)]))
        os.system(('mkdir -p %s' % jni_targetpath))
        os.system(('mkdir -p %s' % static_targetpath))
        makefile.write(('\n-include %s\n' % replaceExtension(jni_objname, '.d')))
        makefile.write((jni_objname + ':\n'))
        makefile.write(('\t$(CCACHE) $(COMPILE.cpp) %s %s %s -o $@ %s\n' % (CTX.EXTRAFLAGS, cppflags, includes, filename)))
        makefile.write(('\n-include %s\n' % replaceExtension(static_objname, '.d')))
        makefile.write((static_objname + ':\n'))
        makefile.write(('\t$(CCACHE) $(COMPILE.cpp) %s %s %s -o $@ %s\n' % (CTX.EXTRAFLAGS, cppflags, includes, filename)))
    makefile.write('\n')
    for test in tests:
        (binname, objectname, sourcename) = namesForTestCode(test)
        makefile.write(('%s: ../../%s' % (objectname, sourcename)))
        makefile.write('\n')
        makefile.write(('\t$(CCACHE) $(COMPILE.cpp) -I../../%s -o $@ ../../%s\n' % (TEST_PREFIX, sourcename)))
        makefile.write(('%s: %s objects/volt.a\n' % (binname, objectname)))
        makefile.write(('\t$(LINK.cpp) -o %s %s objects/volt.a\n' % (binname, objectname)))
        targetpath = ((OUTPUT_PREFIX + '/') + '/'.join(binname.split('/')[:(-1)]))
        os.system(('mkdir -p %s' % targetpath))
        pysourcename = (sourcename[:(-3)] + 'py')
        if os.path.exists(pysourcename):
            shutil.copy(pysourcename, targetpath)
    makefile.write('\n')
    makefile.close()
    return True
