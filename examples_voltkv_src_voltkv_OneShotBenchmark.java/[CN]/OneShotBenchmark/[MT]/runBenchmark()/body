{
  System.out.print(HORIZONTAL_RULE);
  System.out.println(" Setup & Initialization");
  System.out.println(HORIZONTAL_RULE);
  connect(config.servers);
  System.out.println();
  if (config.preload) {
    System.out.println("Preloading data store...");
    for (int i=0; i < config.poolsize; i++) {
      client.callProcedure(new NullCallback(),"Put",String.format(processor.KeyFormat,i),processor.generateForStore().getStoreValue());
    }
    client.drain();
    System.out.println("Preloading complete.\n");
  }
  System.out.print(HORIZONTAL_RULE);
  System.out.println("Starting Benchmark");
  System.out.println(HORIZONTAL_RULE);
  System.out.println("Warming up...");
  final long warmupEndTime=System.currentTimeMillis() + (1000l * config.warmup);
  while (warmupEndTime > System.currentTimeMillis()) {
    if (rand.nextDouble() < config.getputratio) {
      client.callProcedure(new NullCallback(),"Get",processor.generateRandomKeyForRetrieval());
    }
 else {
      final PayloadProcessor.Pair pair=processor.generateForStore();
      client.callProcedure(new NullCallback(),"Put",pair.Key,pair.getStoreValue());
    }
  }
  fullStatsContext.fetchAndResetBaseline();
  periodicStatsContext.fetchAndResetBaseline();
  benchmarkStartTS=System.currentTimeMillis();
  schedulePeriodicStats();
  System.out.println("\nRunning benchmark...");
  final long benchmarkEndTime=System.currentTimeMillis() + (1000l * config.duration);
  long currentTime=System.currentTimeMillis();
  long previousTime=currentTime;
  int slice=4;
  long permits=config.mpratelimit / slice;
  while (benchmarkEndTime > currentTime) {
    if (rand.nextDouble() < config.getputratio) {
      if (permits > 0 && rand.nextDouble() < config.oneshotratio) {
        client.callProcedure(new GetMPCallback(),"GetMP",processor.generateRandomKeyForRetrieval());
        --permits;
      }
 else {
        client.callProcedure(new GetCallback(),"Get",processor.generateRandomKeyForRetrieval());
      }
    }
 else {
      final PayloadProcessor.Pair pair=processor.generateForStore();
      client.callProcedure(new PutCallback(pair),"Put",pair.Key,pair.getStoreValue());
    }
    currentTime=System.currentTimeMillis();
    if ((currentTime - previousTime) >= (1000 / slice)) {
      permits=config.mpratelimit / slice;
      previousTime=currentTime;
    }
  }
  timer.cancel();
  client.drain();
  printResults();
  client.close();
}
