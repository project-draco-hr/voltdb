{
  needInBuffer();
  ByteBuffer in_buffer=_inNIOBuffer.getByteBuffer();
  if (_inNIOBuffer.hasContent())   _inNIOBuffer.compact();
 else   _inNIOBuffer.clear();
  int total_filled=0;
  while (_inNIOBuffer.space() > 0 && super.isOpen()) {
    try {
      int filled=super.fill(_inNIOBuffer);
      if (_debug)       __log.debug(_session + " unwrap filled " + filled);
      if (filled <= 0)       break;
      total_filled+=filled;
    }
 catch (    IOException e) {
      if (_inNIOBuffer.length() == 0) {
        if (_outNIOBuffer != null) {
          _outNIOBuffer.clear();
          freeOutBuffer();
        }
        throw e;
      }
      break;
    }
  }
  if (total_filled == 0 && _inNIOBuffer.length() == 0) {
    if (!isOpen()) {
      freeOutBuffer();
      throw new EofException();
    }
    return false;
  }
  try {
    in_buffer.position(_inNIOBuffer.getIndex());
    in_buffer.limit(_inNIOBuffer.putIndex());
    _result=null;
    _result=_engine.unwrap(in_buffer,buffer);
    if (_debug)     __log.debug(_session + " unwrap unwrap " + _result);
    _inNIOBuffer.skip(_result.bytesConsumed());
  }
  finally {
    in_buffer.position(0);
    in_buffer.limit(in_buffer.capacity());
    freeInBuffer();
  }
switch (_result.getStatus()) {
case BUFFER_OVERFLOW:
    throw new IllegalStateException(_result.toString() + " " + buffer.position()+ " "+ buffer.limit());
case BUFFER_UNDERFLOW:
  if (Log.isDebugEnabled())   Log.debug("unwrap {}",_result);
if (!isOpen()) {
  _inNIOBuffer.clear();
  if (_outNIOBuffer != null)   _outNIOBuffer.clear();
  throw new EofException();
}
return (total_filled > 0);
case CLOSED:
_closing=true;
return total_filled > 0 || _result.bytesConsumed() > 0 || _result.bytesProduced() > 0;
case OK:
return total_filled > 0 || _result.bytesConsumed() > 0 || _result.bytesProduced() > 0;
default :
Log.warn("unwrap " + _result);
throw new IOException(_result.toString());
}
}
