{
  byte[] data=new byte[rowSize];
  byte shouldRollback=0;
  long currentRowCount;
  while (m_shouldContinue.get()) {
    r.nextBytes(data);
    try {
      currentRowCount=getRowCount();
      int tc=batchSize * r.nextInt(99);
      while ((currentRowCount < targetCount) && (m_shouldContinue.get())) {
        CountDownLatch latch=new CountDownLatch(batchSize);
        for (int i=0; i < batchSize; i++) {
          long p=Math.abs(r.nextLong());
          m_permits.acquire();
          insertsTried++;
          client.callProcedure(new InsertCallback(latch),tableName.toUpperCase() + "TableInsert",p,data);
        }
        latch.await(10,TimeUnit.SECONDS);
        long nextRowCount=getRowCount();
        if (nextRowCount == currentRowCount) {
          try {
            Thread.sleep(1000);
          }
 catch (          Exception e2) {
          }
        }
        currentRowCount=nextRowCount;
      }
    }
 catch (    Exception e) {
      log.error("BigTableLoader failed a TableInsert procedure call for table " + tableName,e);
      try {
        Thread.sleep(3000);
      }
 catch (      Exception e2) {
      }
    }
  }
  log.info("BigTableLoader normal exit for table " + tableName + " rows sent: "+ insertsTried+ " inserted: "+ rowsLoaded+ " truncates: "+ nTruncates);
}
