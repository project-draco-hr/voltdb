def get_plugins(self, depth=2):
    "Return plugins info using helper class for version comparison\n\n        This method retrieves information about all the installed plugins and\n        uses a Plugin helper class to simplify version comparison. Also uses\n        a multi key dict to allow retrieval via either short or long names.\n\n        When printing/dumping the data, the version will transparently return\n        a unicode string, which is exactly what was previously returned by the\n        API.\n\n        :param depth: JSON depth, ``int``\n        :returns: info on all plugins ``[dict]``\n\n        Example::\n\n            >>> j = Jenkins()\n            >>> info = j.get_plugins()\n            >>> print(info)\n            {('gearman-plugin', 'Gearman Plugin'):\n              {u'backupVersion': None, u'version': u'0.0.4',\n               u'deleted': False, u'supportsDynamicLoad': u'MAYBE',\n               u'hasUpdate': True, u'enabled': True, u'pinned': False,\n               u'downgradable': False, u'dependencies': [], u'url':\n               u'http://wiki.jenkins-ci.org/display/JENKINS/Gearman+Plugin',\n               u'longName': u'Gearman Plugin', u'active': True, u'shortName':\n               u'gearman-plugin', u'bundled': False}, ...}\n\n        "
    try:
        plugins_info_json = json.loads(self.jenkins_open(Request(self._build_url(PLUGIN_INFO, locals()))))
    except (HTTPError, BadStatusLine):
        raise BadHTTPException(('Error communicating with server[%s]' % self.server))
    except ValueError:
        raise JenkinsException(('Could not parse JSON info for server[%s]' % self.server))
    plugins_data = multi_key_dict.multi_key_dict()
    for plugin_data in plugins_info_json['plugins']:
        keys = (str(plugin_data['shortName']), str(plugin_data['longName']))
        plugins_data[keys] = plugins.Plugin(**plugin_data)
    return plugins_data
