{
  Statement catalogStmt=proc.getStatements().add("stmt-" + String.valueOf(compileCounter++));
  catalogStmt.setSqltext(sql);
  catalogStmt.setSinglepartition(singlePartition);
  catalogStmt.setBatched(false);
  catalogStmt.setParamnum(paramCount);
  QueryType qtype=QueryType.SELECT;
  catalogStmt.setReadonly(true);
  if (sql.toLowerCase().startsWith("insert")) {
    qtype=QueryType.INSERT;
    catalogStmt.setReadonly(false);
  }
  if (sql.toLowerCase().startsWith("update")) {
    qtype=QueryType.UPDATE;
    catalogStmt.setReadonly(false);
  }
  if (sql.toLowerCase().startsWith("delete")) {
    qtype=QueryType.DELETE;
    catalogStmt.setReadonly(false);
  }
  catalogStmt.setQuerytype(qtype.getValue());
  String name=catalogStmt.getParent().getTypeName() + "-" + catalogStmt.getTypeName();
  DatabaseEstimates estimates=new DatabaseEstimates();
  TrivialCostModel costModel=new TrivialCostModel();
  Object partitionParameter=null;
  if (singlePartition) {
    partitionParameter="PlannerTestAideDeCamp dummied up single partitioning for QueryPlanner";
  }
  PartitioningForStatement partitioning=new PartitioningForStatement(partitionParameter,true,true);
  QueryPlanner planner=new QueryPlanner(catalog.getClusters().get("cluster"),db,partitioning,hsql,estimates,false);
  CompiledPlan plan=null;
  plan=planner.compilePlan(costModel,catalogStmt.getSqltext(),joinOrder,catalogStmt.getTypeName(),catalogStmt.getParent().getTypeName(),StatementCompiler.DEFAULT_MAX_JOIN_TABLES,null);
  if (plan == null) {
    String msg="planner.compilePlan returned null plan";
    String plannerMsg=planner.getErrorMessage();
    if (plannerMsg != null) {
      msg+=" with error: \"" + plannerMsg + "\"";
    }
    throw new NullPointerException(msg);
  }
  for (  ParameterInfo param : plan.parameters) {
    StmtParameter catalogParam=catalogStmt.getParameters().add(String.valueOf(param.index));
    catalogParam.setJavatype(param.type.getValue());
    catalogParam.setIndex(param.index);
  }
  int index=0;
  for (  SchemaColumn col : plan.columns.getColumns()) {
    Column catColumn=catalogStmt.getOutput_columns().add(String.valueOf(index));
    catColumn.setNullable(false);
    catColumn.setIndex(index);
    catColumn.setName(col.getColumnName());
    catColumn.setType(col.getType().getValue());
    catColumn.setSize(col.getSize());
    index++;
  }
  List<PlanNodeList> nodeLists=new ArrayList<PlanNodeList>();
  for (  CompiledPlan.Fragment fragment : plan.fragments) {
    PlanNodeList nodeList=new PlanNodeList(fragment.planGraph);
    nodeLists.add(nodeList);
  }
  List<Pair<Integer,VoltType>> parameters=nodeLists.get(0).getParameters();
  for (  ParameterInfo param : plan.parameters) {
    Pair<Integer,VoltType> parameter=new Pair<Integer,VoltType>(param.index,param.type);
    parameters.add(parameter);
  }
  String json=null;
  try {
    JSONObject jobj=new JSONObject(nodeLists.get(0).toJSONString());
    json=jobj.toString(4);
  }
 catch (  JSONException e2) {
    e2.printStackTrace();
    System.exit(-1);
  }
  try {
    BuildDirectoryUtils.writeFile("statement-plans",name + "_json.txt",json);
    BuildDirectoryUtils.writeFile("statement-plans",name + ".dot",nodeLists.get(0).toDOTString("name"));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  List<AbstractPlanNode> plannodes=new ArrayList<AbstractPlanNode>();
  for (  PlanNodeList nodeList : nodeLists) {
    plannodes.add(nodeList.getRootPlanNode());
  }
  m_currentPlan=plan;
  return plannodes;
}
