{
  FailBot failBot=new FailBot(3,t1 != null);
  boolean skipDrops=false;
  if (isRetry) {
    log.info(_F("Catalog update retry #%d for V%d in %d seconds...",this.retryCount + 1,schemaVersionNo + 1,config.retrySleep));
    Thread.sleep(config.retrySleep * 1000);
    if (++this.retryCount >= config.retryLimit) {
      throw new IOException("Retry limit reached");
    }
    assert(this.t2 != null);
    assert(this.currentName != null);
    assert(this.newName != null);
    assert(this.versionT != null);
    if (isSchemaVersionObservable(schemaVersionNo)) {
      log.info(_F("The old version table V%d is present, enabling drop batch.",schemaVersionNo));
    }
 else {
      log.info(_F("The old version table V%d is not present, disabling drop batch.",schemaVersionNo));
      skipDrops=true;
    }
  }
  if (this.retryCount == 0) {
    this.t2=null;
    this.currentName=t1 == null ? "B" : TableHelper.getTableName(t1);
    this.newName=this.currentName;
    this.versionT=TableHelper.quickTable(_F("V%d (BIGINT)",schemaVersionNo + 1));
    if (newTable) {
      this.newName=this.currentName.equals("A") ? "B" : "A";
      this.t2=TableHelper.getTotallyRandomTable(this.newName,rand,false);
    }
 else {
      this.t2=TableHelper.mutateTable(t1,true,rand);
    }
    this.newViewRep=viewIn;
    if (this.newViewRep == null) {
      this.newViewRep=TableHelper.ViewRep.viewRepForTable("MV",this.t2,rand);
    }
 else {
      if (!this.newViewRep.compatibleWithTable(this.t2)) {
        this.newViewRep=null;
      }
    }
  }
  if (!skipDrops) {
    this.logStage("drop");
    schemaChanger.beginBatch();
    try {
      if (failBot.failHere("in drop batch")) {
        schemaChanger.addForcedFailure();
      }
      schemaChanger.dropTables(_F("V%d",schemaVersionNo));
      if (activeViewRep != null) {
        schemaChanger.dropViews(activeViewRep.viewName);
      }
      activeViewRep=this.newViewRep;
      if (activeVerifyProc != null) {
        schemaChanger.dropProcedures(activeVerifyProc.getName());
      }
      if (newTable) {
        if (activeTableNames.contains(this.newName)) {
          schemaChanger.dropTables(this.newName);
          activeTableNames.remove(this.newName);
        }
      }
      if (!schemaChanger.executeBatch(client)) {
        return null;
      }
      activeViewRep=null;
      activeVerifyProc=null;
    }
 catch (    IOException e) {
      return null;
    }
  }
  this.logStage("create/alter");
  schemaChanger.beginBatch();
  long count=0;
  long start=0;
  Class<?> provisionalActiveVerifyProc=null;
  try {
    if (failBot.failHere("in create/alter batch")) {
      schemaChanger.addForcedFailure();
    }
    schemaChanger.createTables(this.versionT);
    boolean partitioned=this.newName.equalsIgnoreCase("A");
    if (newTable) {
      schemaChanger.createTables(this.t2);
    }
 else {
      schemaChanger.updateTable(t1,this.t2);
    }
    if (partitioned) {
      schemaChanger.addTablePartitionInfo(this.t2,this.newName);
      provisionalActiveVerifyProc=VerifySchemaChangedA.class;
    }
 else {
      provisionalActiveVerifyProc=VerifySchemaChangedB.class;
    }
    schemaChanger.createProcedures(client,provisionalActiveVerifyProc);
    if (activeViewRep != null) {
      schemaChanger.createViews(activeViewRep);
    }
    count=tupleCount(t1);
    start=System.nanoTime();
    if (newTable) {
      log.info("Starting to swap tables.");
    }
 else {
      log.info("Starting to change schema.");
    }
    boolean executionSucceeded=schemaChanger.executeBatch(client);
    if (executionSucceeded && failBot.failHere("after create/alter batch")) {
      executionSucceeded=false;
    }
    if (!executionSucceeded) {
      if (!isSchemaVersionObservable(schemaVersionNo + 1)) {
        return null;
      }
      log.info(_F("The new version table V%d is present, not retrying.",schemaVersionNo + 1));
    }
  }
 catch (  IOException e) {
    return null;
  }
  if (newTable) {
    activeTableNames.add(this.newName);
  }
  activeVerifyProc=provisionalActiveVerifyProc;
  this.retryCount=0;
  int obsCatVersion=verifyAndGetSchemaVersion();
  if (obsCatVersion == schemaVersionNo) {
    log.error(_F("Catalog update was reported to be successful but did not pass " + "verification: expected V%d, observed V%d",schemaVersionNo + 1,obsCatVersion));
    assert(false);
    System.exit(-1);
  }
  if (obsCatVersion == schemaVersionNo + 1) {
    schemaVersionNo++;
  }
 else {
    assert(false);
    System.exit(-1);
  }
  long end=System.nanoTime();
  double seconds=(end - start) / 1000000000.0;
  if (newTable) {
    log.info(_F("Completed table swap in %.4f seconds",seconds));
  }
 else {
    log.info(_F("Completed %d tuples in %.4f seconds (%d tuples/sec)",count,seconds,(long)(count / seconds)));
  }
  return new Pair<VoltTable,TableHelper.ViewRep>(this.t2,this.newViewRep,false);
}
