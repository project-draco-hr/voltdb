{
  boolean execBatch=true;
  boolean success=true;
  if (retryCount == 0) {
    this.newSchema.table=null;
    this.currentName=this.currentSchema.table == null ? "B" : TableHelper.getTableName(this.currentSchema.table);
    this.newName=this.currentName;
    this.versionT=TableHelper.quickTable(_F("V%d (BIGINT)",schemaVersionNo + 1));
    if (newTable) {
      this.newName=this.currentName.equals("A") ? "B" : "A";
      this.newSchema.table=TableHelper.getTotallyRandomTable(this.newName,rand,false);
    }
 else {
      this.newSchema.table=TableHelper.mutateTable(this.currentSchema.table,true,rand);
    }
    this.newSchema.view=this.currentSchema.view;
    if (this.newSchema.view == null) {
      this.newSchema.view=TableHelper.ViewRep.viewRepForTable("MV",this.newSchema.table,rand);
    }
 else {
      if (!this.newSchema.view.compatibleWithTable(this.newSchema.table)) {
        this.newSchema.view=null;
      }
    }
  }
 else {
    assert(this.newSchema.table != null);
    assert(this.currentName != null);
    assert(this.newName != null);
    assert(this.versionT != null);
    assert(this.provisionalActiveVerifyProc != null);
    if (isSchemaVersionObservable(schemaVersionNo + 1)) {
      log.info(_F("The new version table V%d is present, not retrying.",schemaVersionNo + 1));
      execBatch=false;
    }
  }
  if (execBatch) {
    schemaChanger.beginBatch();
    try {
      if (!firstTime && config.retryForcedPercent > rand.nextInt(100)) {
        log.info(_F("Forcing failure"));
        schemaChanger.addForcedFailure();
      }
      schemaChanger.dropTables(_F("V%d",schemaVersionNo));
      schemaChanger.dropViews("MV");
      activeViewRep=this.newSchema.view;
      if (activeVerifyProc != null) {
        schemaChanger.dropProcedures(activeVerifyProc.getName());
      }
      if (newTable) {
        if (activeTableNames.contains(this.newName)) {
          schemaChanger.dropTables(this.newName);
          activeTableNames.remove(this.newName);
        }
      }
      this.count=0;
      this.start=0;
      this.provisionalActiveVerifyProc=null;
      schemaChanger.createTables(this.versionT);
      boolean partitioned=this.newName.equalsIgnoreCase("A");
      if (newTable) {
        schemaChanger.createTables(this.newSchema.table);
      }
 else {
        schemaChanger.updateTable(this.currentSchema.table,this.newSchema.table);
      }
      if (partitioned) {
        schemaChanger.addTablePartitionInfo(this.newSchema.table,this.newName);
        this.provisionalActiveVerifyProc=VerifySchemaChangedA.class;
      }
 else {
        this.provisionalActiveVerifyProc=VerifySchemaChangedB.class;
      }
      schemaChanger.createProcedures(client,this.provisionalActiveVerifyProc);
      if (activeViewRep != null) {
        schemaChanger.createViews(activeViewRep);
      }
      this.count=tupleCount(this.currentSchema.table);
      this.start=System.nanoTime();
      if (newTable) {
        log.info("Starting to swap tables.");
      }
 else {
        log.info("Starting to change schema.");
      }
      if (!schemaChanger.executeBatch(client)) {
        success=false;
      }
    }
 catch (    IOException e) {
      success=false;
    }
  }
  if (success) {
    if (newTable) {
      activeTableNames.add(this.newName);
    }
    activeVerifyProc=this.provisionalActiveVerifyProc;
    int obsCatVersion=verifyAndGetSchemaVersion();
    if (obsCatVersion == schemaVersionNo) {
      this.die("Catalog update was reported to be successful but did not pass " + "verification: expected V%d, observed V%d",schemaVersionNo + 1,obsCatVersion);
    }
    if (obsCatVersion == schemaVersionNo + 1) {
      schemaVersionNo++;
    }
 else {
      SchemaChangeUtility.die(false,null);
    }
    long end=System.nanoTime();
    double seconds=(end - this.start) / 1000000000.0;
    if (newTable) {
      log.info(_F("Completed table swap in %.4f seconds",seconds));
    }
 else {
      log.info(_F("Completed %d tuples in %.4f seconds (%d tuples/sec)",this.count,seconds,(long)(this.count / seconds)));
    }
    this.currentSchema.updateFrom(this.newSchema);
  }
  return success;
}
