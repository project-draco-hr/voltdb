{
  boolean needPadding=false;
  List<AbstractExpression> endKeys=new ArrayList<AbstractExpression>();
  IndexLookupType endType=IndexLookupType.EQ;
  List<AbstractExpression> endComparisons=ExpressionUtil.uncombine(isp.getEndExpression());
  for (  AbstractExpression ae : endComparisons) {
    assert(endType == IndexLookupType.EQ);
    if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHAN) {
      endType=IndexLookupType.LT;
    }
 else     if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHANOREQUALTO) {
      endType=IndexLookupType.LTE;
    }
 else {
      assert(ae.getExpressionType() == ExpressionType.COMPARE_EQUAL);
    }
    endKeys.add((AbstractExpression)ae.getRight().clone());
  }
  if (endType == IndexLookupType.EQ && endKeys.size() > 0 && endKeys.size() == isp.getCatalogIndex().getColumns().size() - 1 && isp.getSearchKeyExpressions().size() == isp.getCatalogIndex().getColumns().size()) {
    Index index=isp.getCatalogIndex();
    String jsonstring=index.getExpressionsjson();
    VoltType missingKeyType=VoltType.INVALID;
    needPadding=true;
    if (jsonstring.isEmpty()) {
      List<ColumnRef> indexedColRefs=CatalogUtil.getSortedCatalogItems(index.getColumns(),"index");
      int lastIndex=indexedColRefs.get(indexedColRefs.size() - 1).getColumn().getIndex();
      for (      AbstractExpression expr : endComparisons) {
        if (((TupleValueExpression)(expr.getLeft())).getColumnIndex() == lastIndex) {
          needPadding=false;
          break;
        }
      }
      if (needPadding) {
        missingKeyType=VoltType.get((byte)(indexedColRefs.get(indexedColRefs.size() - 1).getColumn().getType()));
      }
    }
 else {
      List<AbstractExpression> exprs=null;
      try {
        exprs=AbstractExpression.fromJSONArrayString(jsonstring,null);
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
      AbstractExpression lastIndexableExpr=exprs.get(exprs.size() - 1);
      for (      AbstractExpression expr : endComparisons) {
        if (expr.getLeft().bindingToIndexedExpression(lastIndexableExpr) != null) {
          needPadding=false;
          break;
        }
      }
      if (needPadding) {
        missingKeyType=lastIndexableExpr.getValueType();
      }
    }
    if (needPadding && missingKeyType.isMaxValuePaddable()) {
      ConstantValueExpression missingKey=new ConstantValueExpression();
      missingKey.setValueType(missingKeyType);
      missingKey.setValue(String.valueOf(VoltType.getPaddedMaxTypeValue(missingKeyType)));
      endType=IndexLookupType.LTE;
      endKeys.add(missingKey);
      needPadding=true;
    }
 else {
      needPadding=false;
    }
  }
  if (!needPadding && (endType != IndexLookupType.LT) && (endKeys.size() > 0)&& (endKeys.size() < isp.getCatalogIndex().getColumns().size())) {
    return null;
  }
  return new IndexCountPlanNode(isp,apn,endType,endKeys);
}
