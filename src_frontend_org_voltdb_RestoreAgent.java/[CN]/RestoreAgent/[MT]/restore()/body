{
  VoltDB.instance().onRestoreCompletion();
  if (false) {
    final long txnId=1l;
    TreeMap<Long,Snapshot> snapshots=getSnapshots();
    TreeMap<Long,SnapshotInfo> snapshotInfos=new TreeMap<Long,SnapshotInfo>();
    final long minLastSeenTxn=m_replayAgent.getMinLastSeenTxn();
    for (    Entry<Long,Snapshot> e : snapshots.entrySet()) {
      if (e.getKey() < minLastSeenTxn) {
        continue;
      }
      Snapshot s=e.getValue();
      File digest=s.m_digests.get(0);
      SnapshotInfo info=new SnapshotInfo(e.getKey(),digest.getPath(),parseDigestFilename(digest.getName()));
      for (      Entry<String,TableFiles> te : s.m_tableFiles.entrySet()) {
        TableFiles tableFile=te.getValue();
        HashSet<Integer> ids=new HashSet<Integer>();
        for (        Set<Integer> idSet : tableFile.m_validPartitionIds) {
          ids.addAll(idSet);
        }
        info.partitions.put(te.getKey(),ids);
      }
      snapshotInfos.put(e.getKey(),info);
    }
    if (VoltDB.instance().getHostMessenger() != null) {
      int lowestSite=m_context.siteTracker.getLowestLiveNonExecSiteId();
      int lowestHost=m_context.siteTracker.getHostForSite(lowestSite);
      if (VoltDB.instance().getHostMessenger().getHostId() == lowestHost) {
        String path=m_context.cluster.getLogconfig().get("log").getInternalsnapshotpath();
        initSnapshotWork(txnId,Pair.of("@SnapshotRestore",new Object[]{path,CL_NONCE}));
      }
 else {
        changeState();
      }
    }
    new Thread(new Runnable(){
      @Override public void run(){
        while (m_state == State.RESTORE) {
          m_initiator.sendHeartbeat(txnId + 1);
          try {
            Thread.sleep(500);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
).start();
  }
}
