{
  if (!isLowestHost()) {
    return null;
  }
  LOG.debug("Waiting for all hosts to send their snapshot information");
  List<String> children=null;
  while (true) {
    try {
      children=m_zk.getChildren(RESTORE,false);
    }
 catch (    KeeperException e2) {
      throw e2;
    }
catch (    InterruptedException e2) {
      continue;
    }
    Set<Integer> liveHosts=m_context.siteTracker.getAllLiveHosts();
    if (children.size() < liveHosts.size()) {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e1) {
      }
    }
 else {
      break;
    }
  }
  if (children == null) {
    throw new RuntimeException("Unable to read agreement messages from" + " other hosts for restore plan");
  }
  TreeMap<Long,Set<SnapshotInfo>> snapshotFragments=new TreeMap<Long,Set<SnapshotInfo>>();
  Long clStartTxnId=deserializeRestoreInformation(children,snapshotFragments);
  if (m_action == START_ACTION.CREATE) {
    return null;
  }
  boolean crc_catalog_match=false;
  crc_catalog_match=currySnapshotInfo(clStartTxnId,m_context.catalogCRC,snapshotFragments);
  if ((clStartTxnId != null && clStartTxnId != Long.MIN_VALUE) && snapshotFragments.size() == 0) {
    if (!crc_catalog_match) {
      LOG.fatal("No snapshot present that matches the loaded catalog.");
    }
    throw new RuntimeException("No viable snapshots to restore");
  }
  LOG.debug("There are " + snapshotFragments.size() + " snapshots available in the cluster");
  HashMap<Long,Map<String,Set<Integer>>> snapshotTablePartitions=new HashMap<Long,Map<String,Set<Integer>>>();
  Iterator<Entry<Long,Set<SnapshotInfo>>> it=snapshotFragments.entrySet().iterator();
  while (it.hasNext()) {
    Entry<Long,Set<SnapshotInfo>> e=it.next();
    long txnId=e.getKey();
    Map<String,Set<Integer>> tablePartitions=snapshotTablePartitions.get(txnId);
    if (tablePartitions == null) {
      tablePartitions=new HashMap<String,Set<Integer>>();
      snapshotTablePartitions.put(txnId,tablePartitions);
    }
    int totalPartitions=-1;
    boolean inconsistent=false;
    Set<SnapshotInfo> fragments=e.getValue();
    for (    SnapshotInfo s : fragments) {
      if (totalPartitions == -1) {
        totalPartitions=s.partitionCount;
      }
 else       if (totalPartitions != s.partitionCount) {
        inconsistent=true;
        break;
      }
      for (      Entry<String,Set<Integer>> entry : s.partitions.entrySet()) {
        Set<Integer> partitions=tablePartitions.get(entry.getKey());
        if (partitions == null) {
          tablePartitions.put(entry.getKey(),entry.getValue());
        }
 else {
          partitions.addAll(entry.getValue());
        }
      }
      if (inconsistent) {
        break;
      }
    }
    for (    Set<Integer> partitions : tablePartitions.values()) {
      if (partitions.size() != totalPartitions) {
        inconsistent=true;
        break;
      }
    }
    if (inconsistent) {
      it.remove();
    }
  }
  if (clStartTxnId != null && clStartTxnId != Long.MIN_VALUE && snapshotFragments.size() == 0) {
    throw new RuntimeException("No viable snapshots to restore");
  }
  if (snapshotFragments.isEmpty()) {
    return null;
  }
 else {
    return snapshotFragments.lastEntry().getValue();
  }
}
