{
  List<String> children=waitOnVoltZK_restore();
  if (m_action == START_ACTION.CREATE) {
    return null;
  }
  Map<String,Set<SnapshotInfo>> snapshotFragments=new HashMap<String,Set<SnapshotInfo>>();
  Long clStartTxnId=deserializeRestoreInformation(children,snapshotFragments);
  if (clStartTxnId != null && clStartTxnId == Long.MIN_VALUE) {
    snapshotFragments.clear();
  }
  LOG.debug("There are " + snapshotFragments.size() + " restore candidate snapshots available in the cluster");
  HashMap<String,Map<String,Set<Integer>>> snapshotTablePartitions=new HashMap<String,Map<String,Set<Integer>>>();
  Iterator<Entry<String,Set<SnapshotInfo>>> it=snapshotFragments.entrySet().iterator();
  SnapshotInfo newest=null;
  while (it.hasNext()) {
    Entry<String,Set<SnapshotInfo>> e=it.next();
    String nonce=e.getKey();
    Map<String,Set<Integer>> tablePartitions=snapshotTablePartitions.get(nonce);
    if (tablePartitions == null) {
      tablePartitions=new HashMap<String,Set<Integer>>();
      snapshotTablePartitions.put(nonce,tablePartitions);
    }
    int totalPartitions=-1;
    boolean inconsistent=false;
    Set<SnapshotInfo> fragments=e.getValue();
    for (    SnapshotInfo s : fragments) {
      if (totalPartitions == -1) {
        totalPartitions=s.partitionCount;
      }
 else       if (totalPartitions != s.partitionCount) {
        inconsistent=true;
        break;
      }
      for (      Entry<String,Set<Integer>> entry : s.partitions.entrySet()) {
        Set<Integer> partitions=tablePartitions.get(entry.getKey());
        if (partitions == null) {
          tablePartitions.put(entry.getKey(),entry.getValue());
        }
 else {
          partitions.addAll(entry.getValue());
        }
      }
      if (inconsistent) {
        break;
      }
    }
    for (    Set<Integer> partitions : tablePartitions.values()) {
      if (partitions.size() != totalPartitions) {
        inconsistent=true;
        break;
      }
    }
    if (inconsistent) {
      it.remove();
    }
 else {
      SnapshotInfo current=consolidateSnapshotInfos(fragments);
      if (newest == null || current.isNewerThan(newest)) {
        newest=current;
      }
    }
  }
  if (clStartTxnId != null && clStartTxnId != Long.MIN_VALUE && snapshotFragments.size() == 0) {
    throw new RuntimeException("No viable snapshots to restore");
  }
  if (snapshotFragments.isEmpty()) {
    return null;
  }
 else {
    return newest;
  }
}
