{
  byte recover=(byte)m_action.ordinal();
  Long clStartTxnId=null;
  ByteBuffer buf;
  for (  String node : children) {
    byte[] data=null;
    try {
      data=m_zk.getData(RESTORE + "/" + node,false,null);
    }
 catch (    Exception e) {
      LOG.fatal(e.getMessage());
      VoltDB.crashVoltDB();
    }
    buf=ByteBuffer.wrap(data);
    boolean hasLog=buf.get() == 1;
    if (hasLog) {
      long maxTxnId=buf.getLong();
      if (clStartTxnId == null || maxTxnId > clStartTxnId) {
        clStartTxnId=maxTxnId;
      }
    }
    byte recoverByte=buf.get();
    if (recoverByte != recover) {
      LOG.fatal("Database actions are not consistent, please enter " + "the same database action on the command-line.");
      VoltDB.crashVoltDB();
    }
    int count=buf.getInt();
    for (int i=0; i < count; i++) {
      long txnId=buf.getLong();
      Set<SnapshotInfo> fragments=snapshotFragments.get(txnId);
      if (fragments == null) {
        fragments=new HashSet<SnapshotInfo>();
        snapshotFragments.put(txnId,fragments);
      }
      long catalogCrc=buf.getLong();
      int len=buf.getInt();
      byte[] nonceBytes=new byte[len];
      buf.get(nonceBytes);
      len=buf.getInt();
      byte[] pathBytes=new byte[len];
      buf.get(pathBytes);
      int totalPartitionCount=buf.getInt();
      SnapshotInfo info=new SnapshotInfo(txnId,new String(pathBytes),new String(nonceBytes),totalPartitionCount,catalogCrc);
      fragments.add(info);
      int tableCount=buf.getInt();
      for (int j=0; j < tableCount; j++) {
        len=buf.getInt();
        byte[] tableNameBytes=new byte[len];
        buf.get(tableNameBytes);
        int partitionCount=buf.getInt();
        HashSet<Integer> partitions=new HashSet<Integer>(partitionCount);
        info.partitions.put(new String(tableNameBytes),partitions);
        for (int k=0; k < partitionCount; k++) {
          partitions.add(buf.getInt());
        }
      }
    }
  }
  return clStartTxnId;
}
