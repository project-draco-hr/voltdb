{
  byte recover=m_action != START_ACTION.CREATE ? (byte)1 : 0;
  long clStartTxnId=0;
  ByteBuffer buf;
  for (  String node : children) {
    byte[] data=null;
    try {
      data=m_zk.getData(RESTORE + "/" + node,false,null);
    }
 catch (    Exception e) {
      LOG.fatal(e.getMessage());
      VoltDB.crashVoltDB();
    }
    buf=ByteBuffer.wrap(data);
    long minTxnId=buf.getLong();
    if (minTxnId > clStartTxnId) {
      clStartTxnId=minTxnId;
    }
    byte recoverByte=buf.get();
    if (recoverByte != recover) {
      LOG.fatal("Database actions are not consistent, please enter " + "the same database action on the command-line.");
      VoltDB.crashVoltDB();
    }
    int count=buf.getInt();
    for (int i=0; i < count; i++) {
      long txnId=buf.getLong();
      Set<SnapshotInfo> fragments=snapshotFragments.get(txnId);
      if (fragments == null) {
        fragments=new HashSet<SnapshotInfo>();
        snapshotFragments.put(txnId,fragments);
      }
      int len=buf.getInt();
      byte[] nonceBytes=new byte[len];
      buf.get(nonceBytes);
      len=buf.getInt();
      byte[] pathBytes=new byte[len];
      buf.get(pathBytes);
      int totalPartitionCount=buf.getInt();
      SnapshotInfo info=new SnapshotInfo(txnId,new String(pathBytes),new String(nonceBytes),totalPartitionCount);
      fragments.add(info);
      int tableCount=buf.getInt();
      for (int j=0; j < tableCount; j++) {
        len=buf.getInt();
        byte[] tableNameBytes=new byte[len];
        buf.get(tableNameBytes);
        int partitionCount=buf.getInt();
        HashSet<Integer> partitions=new HashSet<Integer>(partitionCount);
        info.partitions.put(new String(tableNameBytes),partitions);
        for (int k=0; k < partitionCount; k++) {
          partitions.add(buf.getInt());
        }
      }
    }
  }
  return clStartTxnId;
}
