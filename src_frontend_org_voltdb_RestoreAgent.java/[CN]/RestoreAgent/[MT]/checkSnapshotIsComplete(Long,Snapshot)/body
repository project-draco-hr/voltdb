{
  int partitionCount=-1;
  for (  TableFiles tf : s.m_tableFiles.values()) {
    if (tf.m_isReplicated) {
      continue;
    }
    for (    boolean completed : tf.m_completed) {
      if (!completed) {
        LOG.debug("Rejecting snapshot because it was not completed.");
        return null;
      }
    }
    for (    int count : tf.m_totalPartitionCounts) {
      if (partitionCount == -1) {
        partitionCount=count;
      }
 else       if (count != partitionCount) {
        LOG.debug("Rejecting snapshot because it had the wrong partition count.");
        return null;
      }
    }
  }
  File digest=s.m_digests.get(0);
  Long catalog_crc=null;
  Map<Integer,Long> pidToTxnMap=new TreeMap<Integer,Long>();
  InstanceId instanceId=new InstanceId(0,0);
  try {
    JSONObject digest_detail=SnapshotUtil.CRCCheck(digest);
    catalog_crc=digest_detail.getLong("catalogCRC");
    if (digest_detail.has("partitionTransactionIds")) {
      JSONObject pidToTxnId=digest_detail.getJSONObject("partitionTransactionIds");
      @SuppressWarnings("unchecked") Iterator<String> it=pidToTxnId.keys();
      while (it.hasNext()) {
        String pidkey=it.next();
        Long txnidval=pidToTxnId.getLong(pidkey);
        pidToTxnMap.put(Integer.valueOf(pidkey),txnidval);
      }
    }
    if (digest_detail.has("instanceId")) {
      instanceId=new InstanceId(digest_detail.getJSONObject("instanceId"));
    }
  }
 catch (  IOException ioe) {
    LOG.info("Unable to read digest file: " + digest.getAbsolutePath() + " due to: "+ ioe.getMessage());
    return null;
  }
catch (  JSONException je) {
    LOG.info("Unable to extract catalog CRC from digest: " + digest.getAbsolutePath() + " due to: "+ je.getMessage());
    return null;
  }
  SnapshotInfo info=new SnapshotInfo(key,digest.getParent(),SnapshotUtil.parseNonceFromDigestFilename(digest.getName()),partitionCount,catalog_crc,m_hostId,instanceId);
  for (  Entry<String,TableFiles> te : s.m_tableFiles.entrySet()) {
    TableFiles tableFile=te.getValue();
    HashSet<Integer> ids=new HashSet<Integer>();
    for (    Set<Integer> idSet : tableFile.m_validPartitionIds) {
      ids.addAll(idSet);
    }
    if (!tableFile.m_isReplicated) {
      info.partitions.put(te.getKey(),ids);
    }
  }
  info.setPidToTxnIdMap(pidToTxnMap);
  return info;
}
