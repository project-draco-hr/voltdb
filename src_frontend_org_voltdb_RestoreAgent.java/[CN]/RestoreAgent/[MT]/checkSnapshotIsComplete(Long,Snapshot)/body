{
  int partitionCount=-1;
  for (  TableFiles tf : s.m_tableFiles.values()) {
    if (tf.m_isReplicated) {
      continue;
    }
    for (    boolean completed : tf.m_completed) {
      if (!completed) {
        LOG.debug("Rejecting snapshot because it was not completed.");
        return null;
      }
    }
    for (    int count : tf.m_totalPartitionCounts) {
      if (partitionCount == -1) {
        partitionCount=count;
      }
 else       if (count != partitionCount) {
        LOG.debug("Rejecting snapshot because it had the wrong partition count.");
        return null;
      }
    }
  }
  if (s.m_digests.isEmpty()) {
    LOG.debug("Rejecting snapshot because it had no valid digest file.");
    return null;
  }
  File digest=s.m_digests.get(0);
  Long catalog_crc=null;
  Map<Integer,Long> pidToTxnMap=new TreeMap<Integer,Long>();
  InstanceId instanceId=new InstanceId(0,0);
  int newParitionCount=-1;
  try {
    JSONObject digest_detail=SnapshotUtil.CRCCheck(digest,LOG);
    if (digest_detail == null)     throw new IOException();
    catalog_crc=digest_detail.getLong("catalogCRC");
    if (digest_detail.has("partitionTransactionIds")) {
      JSONObject pidToTxnId=digest_detail.getJSONObject("partitionTransactionIds");
      @SuppressWarnings("unchecked") Iterator<String> it=pidToTxnId.keys();
      while (it.hasNext()) {
        String pidkey=it.next();
        Long txnidval=pidToTxnId.getLong(pidkey);
        pidToTxnMap.put(Integer.valueOf(pidkey),txnidval);
      }
    }
    if (digest_detail.has("instanceId")) {
      instanceId=new InstanceId(digest_detail.getJSONObject("instanceId"));
    }
    if (digest_detail.has("newPartitionCount")) {
      newParitionCount=digest_detail.getInt("newPartitionCount");
    }
  }
 catch (  IOException ioe) {
    LOG.info("Unable to read digest file: " + digest.getAbsolutePath() + " due to: "+ ioe.getMessage());
    return null;
  }
catch (  JSONException je) {
    LOG.info("Unable to extract catalog CRC from digest: " + digest.getAbsolutePath() + " due to: "+ je.getMessage());
    return null;
  }
  if (s.m_catalogFile == null) {
    LOG.debug("Rejecting snapshot because it had no catalog.");
    return null;
  }
  FileInputStream fin=null;
  try {
    fin=new FileInputStream(s.m_catalogFile);
    byte[] buffer=new byte[(int)s.m_catalogFile.length() + 1000];
    int readBytes=0;
    int totalBytes=0;
    try {
      while (readBytes >= 0) {
        totalBytes+=readBytes;
        readBytes=fin.read(buffer,totalBytes,buffer.length - totalBytes - 1);
      }
    }
  finally {
      fin.close();
      fin=null;
    }
    byte[] catalogBytes=Arrays.copyOf(buffer,totalBytes);
    InMemoryJarfile jarfile=new InMemoryJarfile(catalogBytes);
    if (jarfile.getCRC() != catalog_crc) {
      LOG.debug("Rejecting snapshot because catalog CRC did not match digest.");
      return null;
    }
  }
 catch (  IOException ioe) {
    LOG.debug("Rejecting snapshot because catalog CRC could not be validated");
    return null;
  }
 finally {
    if (fin != null) {
      try {
        fin.close();
      }
 catch (      Exception e) {
      }
    }
  }
  SnapshotInfo info=new SnapshotInfo(key,digest.getParent(),SnapshotUtil.parseNonceFromDigestFilename(digest.getName()),partitionCount,newParitionCount,catalog_crc,m_hostId,instanceId);
  for (  Entry<String,TableFiles> te : s.m_tableFiles.entrySet()) {
    TableFiles tableFile=te.getValue();
    HashSet<Integer> ids=new HashSet<Integer>();
    for (    Set<Integer> idSet : tableFile.m_validPartitionIds) {
      ids.addAll(idSet);
    }
    if (!tableFile.m_isReplicated) {
      info.partitions.put(te.getKey(),ids);
    }
  }
  info.setPidToTxnIdMap(pidToTxnMap);
  return info;
}
