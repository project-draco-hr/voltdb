{
  SocketChannel socket=null;
  DataInputStream in=null;
  DataOutputStream out=null;
  LOG.debug("Starting Coordinator");
  try {
    HashSet<Integer> hostsFound=null;
    while (m_sockets.size() < (m_expectedHosts - 1)) {
      socket=m_listenerSocket.accept();
      socket.socket().setTcpNoDelay(true);
      socket.socket().setPerformancePreferences(0,2,1);
      InputStream s=socket.socket().getInputStream();
      in=new DataInputStream(new BufferedInputStream(s));
      int hostId=in.readInt();
      m_timestamp=in.readLong();
      m_addr=in.readInt();
      int numHosts=in.readInt();
      HashSet<Integer> hosts=new HashSet<Integer>(numHosts);
      for (int ii=0; ii < numHosts; ii++) {
        hosts.add(in.readInt());
      }
      if (hostsFound == null) {
        hostsFound=hosts;
        m_expectedHosts=hostsFound.size() + 1;
        System.out.println(hostsFound.toString());
      }
 else       if (!hostsFound.equals(hosts)) {
        recoveryLog.fatal("Inconsistent live host set during rejoin");
        VoltDB.crashVoltDB();
      }
      m_sockets.put(hostId,socket);
      recoveryLog.info("Have " + m_sockets.size() + " of "+ (m_expectedHosts - 1)+ " with hostId "+ hostId);
    }
    long difftimes[]=new long[m_expectedHosts - 1];
    int readHostIds[]=new int[m_expectedHosts - 1];
    long othercrcs[]=new long[m_expectedHosts - 1];
    int catalogVersions[]=new int[m_expectedHosts - 1];
    for (    Entry<Integer,SocketChannel> e : m_sockets.entrySet()) {
      out=getOutputForHost(e.getKey());
      out.writeInt(COMMAND_SENDTIME_AND_CRC);
      out.flush();
    }
    int i=0;
    for (    Entry<Integer,SocketChannel> e : m_sockets.entrySet()) {
      in=getInputForHost(e.getKey());
      readHostIds[i]=in.readInt();
      othercrcs[i]=in.readLong();
      long timestamp=in.readLong();
      difftimes[i]=System.currentTimeMillis() - timestamp;
      catalogVersions[i]=in.readInt();
      i++;
    }
    int command=COMMAND_COMPLETE;
    long minimumDiff=0;
    long maximumDiff=0;
    for (    long diff : difftimes) {
      if (diff > maximumDiff)       maximumDiff=diff;
      if (diff < minimumDiff)       minimumDiff=diff;
    }
    long maxDiffMS=maximumDiff - minimumDiff;
    if (maxDiffMS > MAX_ACCEPTABLE_TIME_DIFF_IN_MS)     command=COMMAND_NTPFAIL;
    m_localHostId=readHostIds[0];
    recoveryLog.info("Selecting host id " + m_localHostId);
    for (i=1; i < readHostIds.length; i++) {
      if (readHostIds[i] != m_localHostId) {
        command=COMMAND_HOSTIDFAIL;
      }
    }
    for (    long crc : othercrcs) {
      if (crc != m_catalogCRC) {
        command=COMMAND_CRCFAIL;
      }
    }
    m_discoveredCatalogVersion=catalogVersions[0];
    for (    int version : catalogVersions) {
      if (version != m_discoveredCatalogVersion) {
        command=COMMAND_CATVERFAIL;
      }
    }
    for (    Entry<Integer,SocketChannel> e : m_sockets.entrySet()) {
      out=getOutputForHost(e.getKey());
      out.writeLong(maxDiffMS);
      out.writeInt(command);
      out.flush();
    }
    if (m_hostLog != null)     m_hostLog.info("Maximum clock/network skew is " + maxDiffMS + " milliseconds (according to rejoined node)");
    if (command == COMMAND_NTPFAIL) {
      if (m_hostLog != null)       m_hostLog.error("Maximum clock/network is " + (maxDiffMS * 100) / MAX_ACCEPTABLE_TIME_DIFF_IN_MS + "% higher than allowable limit");
      VoltDB.crashVoltDB();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      m_listenerSocket.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}
