{
  final Map<Long,PartitionInfo> currentPartitionInfo=app.getPartitionData();
  final long partitionCount=currentPartitionInfo.size();
  final CountDownLatch latch=new CountDownLatch((int)partitionCount);
  AtomicBoolean unfinished=new AtomicBoolean(false);
  long yieldTimeMs=app.config.deleteyieldtime;
  try {
    TimestampType dateTarget=app.getTargetDate();
    long rowTarget=app.getTargetRowsPerPartition();
    for (    PartitionInfo pinfo : currentPartitionInfo.values()) {
      try {
        if (app.config.historyseconds > 0) {
          app.client.callProcedure(new Callback(latch,unfinished),"DeleteAfterDate",pinfo.partitionKey,dateTarget,app.config.deletechunksize);
        }
 else {
          app.client.callProcedure(new Callback(latch,unfinished),"DeleteOldestToTarget",pinfo.partitionKey,rowTarget,app.config.deletechunksize);
        }
      }
 catch (      Exception e) {
        failureCount.incrementAndGet();
        latch.countDown();
      }
    }
    latch.await();
    if (unfinished.get()) {
      yieldTimeMs=0;
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
 finally {
    app.scheduler.schedule(this,yieldTimeMs,TimeUnit.MILLISECONDS);
  }
}
