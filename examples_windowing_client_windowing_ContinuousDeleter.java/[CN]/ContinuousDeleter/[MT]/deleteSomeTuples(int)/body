{
  final Map<Long,PartitionInfo> currentPartitionInfo=app.getPartitionData();
  final long partitionCount=currentPartitionInfo.size();
  final CountDownLatch latch=new CountDownLatch((int)partitionCount * rounds);
  AtomicLong tuplesNotDeleted=null;
  try {
    for (int round=0; round < rounds; round++) {
      final AtomicLong tuplesNotDeletedForRound=new AtomicLong(0);
      TimestampType dateTarget=app.getTargetDate();
      long rowTarget=app.getTargetRowsPerPartition();
      for (      PartitionInfo pinfo : currentPartitionInfo.values()) {
        try {
          if (app.config.historyseconds > 0) {
            app.client.callProcedure(new Callback(latch,tuplesNotDeletedForRound),"DeleteAfterDate",pinfo.partitionKey,dateTarget,app.config.deletechunksize);
          }
 else {
            app.client.callProcedure(new Callback(latch,tuplesNotDeletedForRound),"DeleteOldestToTarget",pinfo.partitionKey,rowTarget,app.config.deletechunksize);
          }
        }
 catch (        Exception e) {
          failureCount.incrementAndGet();
          latch.countDown();
        }
      }
      tuplesNotDeleted=tuplesNotDeletedForRound;
    }
    latch.await();
    long finalTuplesNotDeleted=tuplesNotDeleted.get();
    if (tuplesNotDeleted.get() > 0) {
      double avgOutstandingPerPartition=finalTuplesNotDeleted / (double)app.getPartitionCount();
      int desiredRounds=(int)Math.ceil(avgOutstandingPerPartition / app.config.deletechunksize);
      assert(desiredRounds > 0);
      app.scheduler.execute(getRunnableForMulitpleRounds(desiredRounds));
      return;
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  app.scheduler.schedule(this,app.config.deleteyieldtime,TimeUnit.MILLISECONDS);
}
