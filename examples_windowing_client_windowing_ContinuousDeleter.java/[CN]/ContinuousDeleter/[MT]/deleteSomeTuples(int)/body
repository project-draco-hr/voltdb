{
  final Map<Long,PartitionInfo> currentPartitionInfo=app.getPartitionData();
  final long partitionCount=currentPartitionInfo.size();
  final CountDownLatch latch=new CountDownLatch((int)partitionCount * rounds);
  AtomicLong tuplesNotDeleted=null;
  for (int round=0; round < rounds; round++) {
    final AtomicLong tuplesNotDeletedForRound=new AtomicLong(0);
    TimestampType dateTarget=app.getTargetDate();
    long rowTarget=app.getTargetRowsPerPartition();
    for (    PartitionInfo pinfo : currentPartitionInfo.values()) {
      try {
        if (app.config.historyseconds > 0) {
          app.client.callProcedure(new Callback(latch,tuplesNotDeletedForRound),"DeleteAfterDate",pinfo.partitionKey,dateTarget,app.config.deletechunksize);
        }
 else {
          app.client.callProcedure(new Callback(latch,tuplesNotDeletedForRound),"DeleteOldestToTarget",pinfo.partitionKey,rowTarget,app.config.deletechunksize);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        latch.countDown();
      }
    }
    tuplesNotDeleted=tuplesNotDeletedForRound;
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  long finalTuplesNotDeleted=tuplesNotDeleted.get();
  if (tuplesNotDeleted.get() > 0) {
    double avgOutstandingPerPartition=finalTuplesNotDeleted / (double)app.getPartitionCount();
    int desiredRounds=(int)Math.ceil(avgOutstandingPerPartition / app.config.deletechunksize);
    assert(desiredRounds > 0);
    app.scheduler.execute(getRunnableForMulitpleRounds(desiredRounds));
  }
 else {
    app.scheduler.schedule(this,app.config.deleteyieldtime,TimeUnit.MILLISECONDS);
  }
}
