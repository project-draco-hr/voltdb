{
  try {
    Map<Long,PartitionInfo> currentPartitionInfo=partitionData.get();
    long partitionCount=currentPartitionInfo.size();
    latch=new CountDownLatch((int)partitionCount);
    for (    PartitionInfo pinfo : currentPartitionInfo.values()) {
      try {
        client.callProcedure(new Callback(),"DeleteAfterDate",pinfo.partitionKey,dateTarget,CHUNK_SIZE);
      }
 catch (      Exception e) {
        e.printStackTrace();
        latch.countDown();
      }
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    try {
      if (partitionsUnfinished.get() > 0) {
        scheduler.execute(new DeleteToTarget());
      }
 else {
        scheduler.schedule(new DeleteToTarget(),100,TimeUnit.MILLISECONDS);
      }
    }
 catch (    RejectedExecutionException e) {
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw t;
  }
}
