{
  m_delimiter=delimiter;
  m_extension=(delimiter == ',') ? ".csv" : ".tsv";
  m_nonce=nonce;
  m_outDir=outdir;
  m_tableDecoders=new HashMap<Long,HashMap<String,ExportToFileDecoder>>();
  m_period=period;
  m_dateFormatOriginalString=dateformatString;
  m_dateformat=new ThreadLocal<SimpleDateFormat>(){
    @Override protected SimpleDateFormat initialValue(){
      return new SimpleDateFormat(m_dateFormatOriginalString);
    }
  }
;
  m_ODBCDateformat=new ThreadLocal<SimpleDateFormat>(){
    @Override protected SimpleDateFormat initialValue(){
      SimpleDateFormat sdf=new SimpleDateFormat(VoltDB.ODBC_DATE_FORMAT_STRING);
      sdf.setTimeZone(tz);
      return sdf;
    }
  }
;
  m_binaryEncoding=be;
  m_firstfield=firstfield;
  m_batched=batched;
  m_withSchema=withSchema;
  if (fullDelimiters != null) {
    fullDelimiters=StringEscapeUtils.unescapeHtml4(fullDelimiters);
    m_fullDelimiters=new char[4];
    for (int i=0; i < 4; i++) {
      m_fullDelimiters[i]=fullDelimiters.charAt(i);
    }
  }
 else {
    m_fullDelimiters=null;
  }
  assert(m_current == null);
  m_current=new PeriodicExportContext();
  Runnable rotator=new Runnable(){
    @Override public void run(){
      try {
        roll();
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
    }
  }
;
  m_ses=CoreUtils.getScheduledThreadPoolExecutor("Export file rotate timer for nonce " + nonce,1,CoreUtils.SMALL_STACK_SIZE);
  m_ses.scheduleWithFixedDelay(rotator,m_period,m_period,TimeUnit.MINUTES);
}
