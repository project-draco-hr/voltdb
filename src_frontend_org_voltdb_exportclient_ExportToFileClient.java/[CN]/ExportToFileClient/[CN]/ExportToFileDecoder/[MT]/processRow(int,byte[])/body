{
  Object[] row=null;
  try {
    row=decodeRow(rowData);
  }
 catch (  IOException e) {
    m_logger.error("Unable to decode row for table: " + m_source.tableName);
    return false;
  }
  try {
    String[] fields=new String[m_tableSchema.size() - m_firstfield];
    for (int i=m_firstfield; i < m_tableSchema.size(); i++) {
      if (row[i] == null) {
        fields[i - m_firstfield]="NULL";
      }
 else       if (m_tableSchema.get(i) == VoltType.VARBINARY) {
        if (m_binaryEncoding == BinaryEncoding.HEX) {
          fields[i - m_firstfield]=Encoder.hexEncode((byte[])row[i]);
        }
 else {
          fields[i - m_firstfield]=Encoder.base64Encode((byte[])row[i]);
        }
      }
 else       if (m_tableSchema.get(i) == VoltType.STRING) {
        fields[i - m_firstfield]=(String)row[i];
      }
 else       if (m_tableSchema.get(i) == VoltType.TIMESTAMP) {
        TimestampType timestamp=(TimestampType)row[i];
        fields[i - m_firstfield]=m_ODBCDateformat.get().format(timestamp.asApproximateJavaDate());
      }
 else {
        fields[i - m_firstfield]=row[i].toString();
      }
    }
    m_writer.writeNext(fields);
  }
 catch (  Exception x) {
    x.printStackTrace();
    return false;
  }
  return true;
}
