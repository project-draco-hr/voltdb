{
  Object[] row=null;
  try {
    row=decodeRow(rowData);
  }
 catch (  IOException e) {
    m_logger.error("Unable to decode row for table: " + m_source.tableName());
    return false;
  }
  StringBuilder sb=new StringBuilder();
  final SimpleDateFormat sdf=new SimpleDateFormat("yyyy.MM.dd HH:mm:ss:SSS:");
  for (int i=0; i < m_tableSchema.size(); i++) {
    if (i != 0) {
      sb.append(m_escaper.getDelimiter());
    }
    if (row[i] == null) {
      sb.append("NULL");
    }
 else     if (m_tableSchema.get(i) == VoltType.STRING) {
      sb.append(m_escaper.escape((String)row[i]));
    }
 else     if (m_tableSchema.get(i) == VoltType.TIMESTAMP) {
      StringBuilder builder=new StringBuilder(64);
      TimestampType timestamp=(TimestampType)row[i];
      builder.append(sdf.format(timestamp.asApproximateJavaDate()));
      builder.append(timestamp.getUSec());
      sb.append(m_escaper.escape(builder.toString()));
    }
 else {
      sb.append(row[i].toString());
    }
  }
  sb.append("\n");
  byte bytes[]=null;
  try {
    bytes=sb.toString().getBytes("UTF-8");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return false;
  }
  try {
    m_fos.write(bytes);
    m_fos.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e.getMessage());
  }
  return true;
}
