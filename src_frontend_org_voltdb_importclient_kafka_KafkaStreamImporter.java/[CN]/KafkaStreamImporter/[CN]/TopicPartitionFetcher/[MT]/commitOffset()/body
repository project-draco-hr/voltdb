{
  if (m_seenOffset.isEmpty())   return false;
  long offset=m_seenOffset.last();
  SortedSet<Long> removeSet=m_seenOffset.subSet(m_seenOffset.first(),offset);
  final int correlationId=m_topicAndPartition.partition();
  final short version=1;
  if (m_lastCommittedOffset != offset) {
    OffsetAndMetadata offsetMetdata=new OffsetAndMetadata(offset,"commitRequest",ErrorMapping.NoError());
    Map<TopicAndPartition,OffsetAndMetadata> reqMap=new HashMap<TopicAndPartition,OffsetAndMetadata>();
    reqMap.put(m_topicAndPartition,offsetMetdata);
    OffsetCommitRequest offsetCommitRequest=new OffsetCommitRequest(m_groupId,reqMap,correlationId,CLIENT_ID,version);
    OffsetCommitResponse offsetCommitResponse=null;
    try {
      SimpleConsumer consumer=m_offsetManager.get();
      if (consumer == null) {
        getOffsetCoordinator();
        consumer=m_offsetManager.get();
      }
      if (consumer != null) {
        offsetCommitResponse=consumer.commitOffsets(offsetCommitRequest);
        final short code=((Short)offsetCommitResponse.errors().get(m_topicAndPartition));
        if (code == ErrorMapping.NotCoordinatorForConsumerCode()) {
          info("Not coordinator for committing offset for " + m_topicAndPartition + " Updating coordinator.");
          getOffsetCoordinator();
          consumer=m_offsetManager.get();
          if (consumer != null) {
            offsetCommitResponse=consumer.commitOffsets(offsetCommitRequest);
          }
        }
      }
 else {
        error("Commit Offset Failed to get offset coordinator for " + m_topicAndPartition);
        return false;
      }
    }
 catch (    Exception e) {
      error(e,"Failed to commit Offset for " + m_topicAndPartition);
      return false;
    }
    final short code=((Short)offsetCommitResponse.errors().get(m_topicAndPartition));
    if (code != ErrorMapping.NoError()) {
      final String msg="Commit Offset Failed to commit for " + m_topicAndPartition + " Code: %d";
      error(null,msg,code);
      return false;
    }
  }
  m_lastCommittedOffset=offset;
synchronized (m_seenOffset) {
    removeSet.clear();
  }
  return true;
}
