{
  int groupColCount=stmt.groupByColumns.size();
  int displayColCount=stmt.displayColumns.size();
  String msg="Materialized view \"" + viewName + "\" ";
  if (stmt.tableList.size() != 1) {
    msg+="has " + String.valueOf(stmt.tableList.size()) + " sources. "+ "Only one source view or source table is allowed.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (displayColCount <= groupColCount) {
    msg+="has too few columns.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (stmt.hasComplexAgg()) {
    msg+="contains an expression involving an aggregate function. " + "Expressions with aggregate functions are not currently supported in views.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  int i;
  for (i=0; i < groupColCount; i++) {
    ParsedSelectStmt.ParsedColInfo gbcol=stmt.groupByColumns.get(i);
    ParsedSelectStmt.ParsedColInfo outcol=stmt.displayColumns.get(i);
    if (!outcol.expression.equals(gbcol.expression)) {
      msg+="must exactly match the GROUP BY clause at index " + String.valueOf(i) + " of SELECT list.";
      throw m_compiler.new VoltCompilerException(msg);
    }
  }
  AbstractExpression coli=stmt.displayColumns.get(i).expression;
  if (coli.getExpressionType() != ExpressionType.AGGREGATE_COUNT_STAR) {
    msg+="is missing count(*) as the column after the group by columns, a materialized view requirement.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  for (i++; i < displayColCount; i++) {
    ParsedSelectStmt.ParsedColInfo outcol=stmt.displayColumns.get(i);
    if ((outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_COUNT) && (outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_SUM)) {
      msg+="must have non-group by columns aggregated by sum or count.";
      throw m_compiler.new VoltCompilerException(msg);
    }
  }
}
