{
  int groupColCount=stmt.m_groupByColumns.size();
  int displayColCount=stmt.m_displayColumns.size();
  String msg="Materialized view \"" + viewName + "\" ";
  if (stmt.hasSubquery()) {
    msg+="with subquery sources is not supported.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (stmt.m_tableList.size() != 1) {
    msg+="has " + String.valueOf(stmt.m_tableList.size()) + " sources. "+ "Only one source table is allowed.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (stmt.orderByColumns().size() != 0) {
    msg+="with ORDER BY clause is not supported.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (stmt.hasLimitOrOffset()) {
    msg+="with LIMIT or OFFSET clause is not supported.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (stmt.m_having != null) {
    msg+="with HAVING clause is not supported.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  if (displayColCount <= groupColCount) {
    msg+="has too few columns.";
    throw m_compiler.new VoltCompilerException(msg);
  }
  List<AbstractExpression> checkExpressions=new ArrayList<AbstractExpression>();
  int i;
  for (i=0; i < groupColCount; i++) {
    ParsedColInfo gbcol=stmt.m_groupByColumns.get(i);
    ParsedColInfo outcol=stmt.m_displayColumns.get(i);
    if (!outcol.expression.equals(gbcol.expression)) {
      msg+="must exactly match the GROUP BY clause at index " + String.valueOf(i) + " of SELECT list.";
      throw m_compiler.new VoltCompilerException(msg);
    }
    checkExpressions.add(outcol.expression);
  }
  AbstractExpression coli=stmt.m_displayColumns.get(i).expression;
  if (coli.getExpressionType() != ExpressionType.AGGREGATE_COUNT_STAR) {
    msg+="must have count(*) after the GROUP BY columns (if any) but before the aggregate functions (if any).";
    throw m_compiler.new VoltCompilerException(msg);
  }
  for (i++; i < displayColCount; i++) {
    ParsedColInfo outcol=stmt.m_displayColumns.get(i);
    if ((outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_COUNT) && (outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_SUM) && (outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_MIN)&& (outcol.expression.getExpressionType() != ExpressionType.AGGREGATE_MAX)) {
      msg+="must have non-group by columns aggregated by sum, count, min or max.";
      throw m_compiler.new VoltCompilerException(msg);
    }
    checkExpressions.add(outcol.expression);
  }
  AbstractExpression where=stmt.getSingleTableFilterExpression();
  checkExpressions.add(where);
  for (  AbstractExpression expr : checkExpressions) {
    if (containsTimeSensitiveFunction(expr,FunctionSQL.voltGetCurrentTimestampId())) {
      msg+="cannot include the function NOW or CURRENT_TIMESTAMP.";
      throw m_compiler.new VoltCompilerException(msg);
    }
  }
}
