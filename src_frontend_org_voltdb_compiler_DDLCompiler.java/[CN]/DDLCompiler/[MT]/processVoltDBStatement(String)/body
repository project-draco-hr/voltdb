{
  if (statement == null || statement.trim().isEmpty()) {
    return false;
  }
  statement=statement.trim();
  Matcher statementMatcher=voltdbStatementPrefixPattern.matcher(statement);
  ;
  if (!statementMatcher.find()) {
    return false;
  }
  String commandPrefix=statementMatcher.group(1).toUpperCase();
  statementMatcher=procedureClassPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String clazz=checkIdentifierStart(statementMatcher.group(1),statement);
    ProcedureDescriptor descriptor=m_compiler.new ProcedureDescriptor(new ArrayList<String>(),clazz);
    m_partitionMap.add(descriptor);
    return true;
  }
  statementMatcher=procedureSingleStatementPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String clazz=checkIdentifierStart(statementMatcher.group(1),statement);
    String sqlStatement=statementMatcher.group(2);
    ProcedureDescriptor descriptor=m_compiler.new ProcedureDescriptor(new ArrayList<String>(),clazz,sqlStatement,null,null,false);
    m_partitionMap.add(descriptor);
    return true;
  }
  statementMatcher=prePartitionPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String partitionee=statementMatcher.group(1).toUpperCase();
    if (TABLE.equals(partitionee)) {
      statementMatcher=partitionTablePattern.matcher(statement);
      if (!statementMatcher.matches()) {
        throw m_compiler.new VoltCompilerException(String.format("Bad PARTITION DDL statement: \"%s\", " + "expected syntax: PARTITION TABLE <table> ON COLUMN <column>",statement.substring(0,statement.length() - 1)));
      }
      m_partitionMap.put(checkIdentifierStart(statementMatcher.group(1),statement),checkIdentifierStart(statementMatcher.group(2),statement));
      return true;
    }
 else     if (PROCEDURE.equals(partitionee)) {
      statementMatcher=partitionProcedurePattern.matcher(statement);
      if (!statementMatcher.matches()) {
        throw m_compiler.new VoltCompilerException(String.format("Bad PARTITION DDL statement: \"%s\", " + "expected syntax: PARTITION PROCEDURE <procedure> ON " + "'<table>.<column>: <parameter-index-no>'",statement.substring(0,statement.length() - 1)));
      }
      checkIdentifierStart(statementMatcher.group(3),statement);
      checkIdentifierStart(statementMatcher.group(4),statement);
      m_partitionMap.addProcedurePartitionInfoTo(checkIdentifierStart(statementMatcher.group(1),statement),statementMatcher.group(2));
      return true;
    }
  }
  statementMatcher=replicatePattern.matcher(statement);
  if (statementMatcher.matches()) {
    m_partitionMap.put(checkIdentifierStart(statementMatcher.group(1),statement),null);
    return true;
  }
  if (PARTITION.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Bad PARTITION DDL statement: \"%s\", " + "expected syntax: \"PARTITION TABLE <table> ON COLUMN <column>\" or " + "\"PARTITION PROCEDURE <procedure> ON "+ "'<table>.<column>: <parameter-index-no>'\"",statement.substring(0,statement.length() - 1)));
  }
  if (REPLICATE.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Bad REPLICATE DDL statement: \"%s\", " + "expected syntax: REPLICATE TABLE <table>",statement.substring(0,statement.length() - 1)));
  }
  if (PROCEDURE.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Bad CREATE PROCEDURE DDL statement: \"%s\", " + "expected syntax: \"CREATE PROCEDURE FROM CLASS <class-name>\" " + "or: \"CREATE PROCEDURE <name> AS <single-select-or-dml-statement>\"",statement.substring(0,statement.length() - 1)));
  }
  return false;
}
