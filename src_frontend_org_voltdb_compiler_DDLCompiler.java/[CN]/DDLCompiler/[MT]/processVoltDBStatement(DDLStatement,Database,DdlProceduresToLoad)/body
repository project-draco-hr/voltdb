{
  String statement=ddlStatement.statement;
  if (statement == null || statement.trim().isEmpty()) {
    return false;
  }
  statement=statement.trim();
  Matcher statementMatcher=voltdbStatementPrefixPattern.matcher(statement);
  if (!statementMatcher.find()) {
    return false;
  }
  String commandPrefix=statementMatcher.group(1).toUpperCase();
  statementMatcher=procedureClassPattern.matcher(statement);
  if (statementMatcher.matches()) {
    if (whichProcs != DdlProceduresToLoad.ALL_DDL_PROCEDURES) {
      return true;
    }
    String className=checkIdentifierStart(statementMatcher.group(5),statement);
    Class<?> clazz;
    try {
      clazz=Class.forName(className,true,m_classLoader);
    }
 catch (    Throwable cause) {
      if (CoreUtils.isStoredProcThrowableFatalToServer(cause)) {
        throw (Error)cause;
      }
 else {
        throw m_compiler.new VoltCompilerException(String.format("Cannot load class for procedure: %s",className),cause);
      }
    }
    ProcedureDescriptor descriptor=m_compiler.new ProcedureDescriptor(new ArrayList<String>(),Language.JAVA,null,clazz);
    if (statementMatcher.group(1) != null) {
      for (      String roleName : StringUtils.split(statementMatcher.group(1),',')) {
        String roleNameFixed=roleName.trim().toLowerCase();
        if (!descriptor.m_authGroups.contains(roleNameFixed)) {
          descriptor.m_authGroups.add(roleNameFixed);
        }
      }
    }
    String procName=m_tracker.add(descriptor);
    addProcedurePartitionInfo(procName,statementMatcher.group(2),statementMatcher.group(3),statementMatcher.group(4),statement);
    return true;
  }
  statementMatcher=procedureSingleStatementPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String clazz=checkIdentifierStart(statementMatcher.group(1),statement);
    String sqlStatement=statementMatcher.group(6) + ";";
    ProcedureDescriptor descriptor=m_compiler.new ProcedureDescriptor(new ArrayList<String>(),clazz,sqlStatement,null,null,false,null,null,null);
    if (statementMatcher.group(2) != null) {
      for (      String roleName : StringUtils.split(statementMatcher.group(2),',')) {
        descriptor.m_authGroups.add(roleName.trim().toLowerCase());
      }
    }
    m_tracker.add(descriptor);
    addProcedurePartitionInfo(clazz,statementMatcher.group(3),statementMatcher.group(4),statementMatcher.group(5),statement);
    return true;
  }
  statementMatcher=procedureWithScriptPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String className=checkIdentifierStart(statementMatcher.group(1),statement);
    String codeBlock=statementMatcher.group(6);
    Language language=Language.valueOf(statementMatcher.group(7).toUpperCase());
    Class<?> scriptClass=null;
    if (language == Language.GROOVY) {
      try {
        scriptClass=GroovyCodeBlockCompiler.instance().parseCodeBlock(codeBlock,className);
      }
 catch (      CodeBlockCompilerException ex) {
        throw m_compiler.new VoltCompilerException(String.format("Procedure \"%s\" code block has syntax errors:\n%s",className,ex.getMessage()));
      }
catch (      Exception ex) {
        throw m_compiler.new VoltCompilerException(ex);
      }
    }
 else {
      throw m_compiler.new VoltCompilerException(String.format("Language \"%s\" is not a supported",language.name()));
    }
    ProcedureDescriptor descriptor=m_compiler.new ProcedureDescriptor(new ArrayList<String>(),language,codeBlock,scriptClass);
    if (statementMatcher.group(2) != null) {
      for (      String roleName : StringUtils.split(statementMatcher.group(2),',')) {
        descriptor.m_authGroups.add(roleName.trim().toLowerCase());
      }
    }
    m_tracker.add(descriptor);
    addProcedurePartitionInfo(className,statementMatcher.group(3),statementMatcher.group(4),statementMatcher.group(5),statement);
    return true;
  }
  statementMatcher=procedureDropPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String classOrProcName=checkIdentifierStart(statementMatcher.group(1),statement);
    m_tracker.removeProcedure(classOrProcName,(statementMatcher.group(2) != null));
    return true;
  }
  statementMatcher=prePartitionPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String partitionee=statementMatcher.group(1).toUpperCase();
    if (TABLE.equals(partitionee)) {
      statementMatcher=partitionTablePattern.matcher(statement);
      if (!statementMatcher.matches()) {
        throw m_compiler.new VoltCompilerException(String.format("Invalid PARTITION statement: \"%s\", " + "expected syntax: PARTITION TABLE <table> ON COLUMN <column>",statement.substring(0,statement.length() - 1)));
      }
      String tableName=checkIdentifierStart(statementMatcher.group(1),statement);
      String columnName=checkIdentifierStart(statementMatcher.group(2),statement);
      VoltXMLElement tableXML=m_schema.findChild("table",tableName.toUpperCase());
      if (tableXML != null) {
        tableXML.attributes.put("partitioncolumn",columnName.toUpperCase());
      }
 else {
        throw m_compiler.new VoltCompilerException(String.format("Invalid PARTITION statement: table %s does not exist",tableName));
      }
      return true;
    }
 else     if (PROCEDURE.equals(partitionee)) {
      if (whichProcs != DdlProceduresToLoad.ALL_DDL_PROCEDURES) {
        return true;
      }
      statementMatcher=partitionProcedureStatementPattern.matcher(statement);
      if (!statementMatcher.matches()) {
        throw m_compiler.new VoltCompilerException(String.format("Invalid PARTITION statement: \"%s\", " + "expected syntax: PARTITION PROCEDURE <procedure> ON " + "TABLE <table> COLUMN <column> [PARAMETER <parameter-index-no>]",statement.substring(0,statement.length() - 1)));
      }
      String tableName=checkIdentifierStart(statementMatcher.group(2),statement);
      String columnName=checkIdentifierStart(statementMatcher.group(3),statement);
      String parameterNo=statementMatcher.group(4);
      if (parameterNo == null) {
        parameterNo="0";
      }
      String partitionInfo=String.format("%s.%s: %s",tableName,columnName,parameterNo);
      m_tracker.addProcedurePartitionInfoTo(checkIdentifierStart(statementMatcher.group(1),statement),partitionInfo);
      return true;
    }
  }
  statementMatcher=replicatePattern.matcher(statement);
  if (statementMatcher.matches()) {
    String tableName=checkIdentifierStart(statementMatcher.group(1),statement);
    VoltXMLElement tableXML=m_schema.findChild("table",tableName.toUpperCase());
    if (tableXML != null) {
      tableXML.attributes.remove("partitioncolumn");
    }
 else {
      throw m_compiler.new VoltCompilerException(String.format("Invalid REPLICATE statement: table %s does not exist",tableName));
    }
    return true;
  }
  statementMatcher=importClassPattern.matcher(statement);
  if (statementMatcher.matches()) {
    if (whichProcs == DdlProceduresToLoad.ALL_DDL_PROCEDURES) {
      if (!(m_classLoader instanceof InMemoryJarfile.JarLoader)) {
        String classNameStr=statementMatcher.group(1);
        checkIdentifierWithWildcard(classNameStr,statement);
        ClassNameMatchStatus matchStatus=m_classMatcher.addPattern(classNameStr);
        if (matchStatus == ClassNameMatchStatus.NO_EXACT_MATCH) {
          throw m_compiler.new VoltCompilerException(String.format("IMPORT CLASS not found: '%s'",classNameStr));
        }
 else         if (matchStatus == ClassNameMatchStatus.NO_WILDCARD_MATCH) {
          m_compiler.addWarn(String.format("IMPORT CLASS no match for wildcarded class: '%s'",classNameStr),ddlStatement.lineNo);
        }
      }
 else {
        m_compiler.addInfo("Internal cluster recompilation ignoring IMPORT CLASS line: " + statement);
      }
      m_tracker.addImportLine(statement);
    }
    return true;
  }
  statementMatcher=createRolePattern.matcher(statement);
  if (statementMatcher.matches()) {
    String roleName=statementMatcher.group(1).toLowerCase();
    CatalogMap<Group> groupMap=db.getGroups();
    if (groupMap.get(roleName) != null) {
      throw m_compiler.new VoltCompilerException(String.format("Role name \"%s\" in CREATE ROLE statement already exists.",roleName));
    }
    org.voltdb.catalog.Group catGroup=groupMap.add(roleName);
    if (statementMatcher.group(2) != null) {
      try {
        EnumSet<Permission> permset=Permission.getPermissionsFromAliases(Arrays.asList(StringUtils.split(statementMatcher.group(2),',')));
        Permission.setPermissionsInGroup(catGroup,permset);
      }
 catch (      IllegalArgumentException iaex) {
        throw m_compiler.new VoltCompilerException(String.format("Invalid permission \"%s\" in CREATE ROLE statement: \"%s\", " + "available permissions: %s",iaex.getMessage(),statement.substring(0,statement.length() - 1),Permission.toListString()));
      }
    }
    return true;
  }
  statementMatcher=dropRolePattern.matcher(statement);
  if (statementMatcher.matches()) {
    String roleName=statementMatcher.group(1).toUpperCase();
    boolean ifExists=(statementMatcher.group(2) != null);
    CatalogMap<Group> groupMap=db.getGroups();
    if (groupMap.get(roleName) == null) {
      if (!ifExists) {
        throw m_compiler.new VoltCompilerException(String.format("Role name \"%s\" in DROP ROLE statement does not exist.",roleName));
      }
 else {
        return true;
      }
    }
 else {
      if (roleName.equals("ADMINISTRATOR") || roleName.equals("USER")) {
        throw m_compiler.new VoltCompilerException(String.format("You may not drop the built-in role \"%s\".",roleName));
      }
      groupMap.delete(roleName);
    }
    return true;
  }
  statementMatcher=exportPattern.matcher(statement);
  if (statementMatcher.matches()) {
    String tableName=checkIdentifierStart(statementMatcher.group(1),statement);
    VoltXMLElement tableXML=m_schema.findChild("table",tableName.toUpperCase());
    if (tableXML != null) {
      tableXML.attributes.put("export","true");
    }
 else {
      throw m_compiler.new VoltCompilerException(String.format("Invalid EXPORT statement: table %s was not present in the catalog.",tableName));
    }
    return true;
  }
  if (PARTITION.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Invalid PARTITION statement: \"%s\", " + "expected syntax: \"PARTITION TABLE <table> ON COLUMN <column>\" or " + "\"PARTITION PROCEDURE <procedure> ON "+ "TABLE <table> COLUMN <column> [PARAMETER <parameter-index-no>]\"",statement.substring(0,statement.length() - 1)));
  }
  if (REPLICATE.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Invalid REPLICATE statement: \"%s\", " + "expected syntax: REPLICATE TABLE <table>",statement.substring(0,statement.length() - 1)));
  }
  if (PROCEDURE.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Invalid CREATE PROCEDURE statement: \"%s\", " + "expected syntax: \"CREATE PROCEDURE [ALLOW <role> [, <role> ...] FROM CLASS <class-name>\" " + "or: \"CREATE PROCEDURE <name> [ALLOW <role> [, <role> ...] AS <single-select-or-dml-statement>\" "+ "or: \"CREATE PROCEDURE <proc-name> [ALLOW <role> ...] AS ### <code-block> ### LANGUAGE GROOVY\"",statement.substring(0,statement.length() - 1)));
  }
  if (ROLE.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Invalid CREATE ROLE statement: \"%s\", " + "expected syntax: CREATE ROLE <role>",statement.substring(0,statement.length() - 1)));
  }
  if (EXPORT.equals(commandPrefix)) {
    throw m_compiler.new VoltCompilerException(String.format("Invalid EXPORT TABLE statement: \"%s\", " + "expected syntax: EXPORT TABLE <table>",statement.substring(0,statement.length() - 1)));
  }
  return false;
}
