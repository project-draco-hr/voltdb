{
  CatalogMap<Index> allIndexes=srcTable.getIndexes();
  StmtTableScan tableScan=new StmtTargetTableScan(srcTable,srcTable.getTypeName());
  for (  Index index : allIndexes) {
    boolean matchedAll=true;
    if (groupbyExprs == null) {
      String expressionjson=index.getExpressionsjson();
      if (!expressionjson.isEmpty()) {
        continue;
      }
      List<ColumnRef> indexedColRefs=CatalogUtil.getSortedCatalogItems(index.getColumns(),"index");
      List<ColumnRef> groupbyColRefs=CatalogUtil.getSortedCatalogItems(matviewinfo.getGroupbycols(),"index");
      if (indexedColRefs.size() != groupbyColRefs.size()) {
        continue;
      }
      for (int i=0; i < indexedColRefs.size(); ++i) {
        int groupbyColIndex=groupbyColRefs.get(i).getColumn().getIndex();
        int indexedColIndex=indexedColRefs.get(i).getColumn().getIndex();
        if (groupbyColIndex != indexedColIndex) {
          matchedAll=false;
          break;
        }
      }
    }
 else {
      String expressionjson=index.getExpressionsjson();
      if (expressionjson.isEmpty()) {
        continue;
      }
      List<AbstractExpression> indexedExprs=null;
      try {
        indexedExprs=AbstractExpression.fromJSONArrayString(expressionjson,tableScan);
      }
 catch (      JSONException e) {
        e.printStackTrace();
        assert(false);
        return null;
      }
      if (indexedExprs.size() != groupbyExprs.size()) {
        continue;
      }
      for (int i=0; i < indexedExprs.size(); ++i) {
        if (!indexedExprs.get(i).equals(groupbyExprs.get(i))) {
          matchedAll=false;
          break;
        }
      }
    }
    if (matchedAll && !index.getPredicatejson().isEmpty()) {
      List<AbstractExpression> coveringExprs=new ArrayList<AbstractExpression>();
      List<AbstractExpression> exactMatchCoveringExprs=new ArrayList<AbstractExpression>();
      try {
        String encodedPredicate=matviewinfo.getPredicate();
        if (!encodedPredicate.isEmpty()) {
          String predicate=Encoder.hexDecodeToString(encodedPredicate);
          AbstractExpression matViewPredicate=AbstractExpression.fromJSONString(predicate,tableScan);
          coveringExprs.addAll(ExpressionUtil.uncombineAny(matViewPredicate));
        }
      }
 catch (      JSONException e) {
        e.printStackTrace();
        assert(false);
        return null;
      }
      matchedAll=SubPlanAssembler.isPartialIndexPredicateIsCovered(tableScan,coveringExprs,index,exactMatchCoveringExprs);
    }
    if (matchedAll) {
      return index;
    }
  }
  return null;
}
