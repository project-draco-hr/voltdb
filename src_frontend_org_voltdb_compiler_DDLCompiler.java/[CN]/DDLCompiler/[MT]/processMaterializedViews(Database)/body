{
  for (  Entry<Table,String> entry : matViewMap.entrySet()) {
    Table destTable=entry.getKey();
    String query=entry.getValue();
    VoltXMLElement xmlquery=null;
    try {
      xmlquery=m_hsql.getXMLCompiledStatement(query);
    }
 catch (    HSQLParseException e) {
      e.printStackTrace();
    }
    assert(xmlquery != null);
    ParsedSelectStmt stmt=null;
    try {
      stmt=(ParsedSelectStmt)AbstractParsedStmt.parse(query,xmlquery,null,db,null);
    }
 catch (    Exception e) {
      throw m_compiler.new VoltCompilerException(e.getMessage());
    }
    assert(stmt != null);
    String viewName=destTable.getTypeName();
    checkViewMeetsSpec(viewName,stmt);
    for (    Index destIndex : destTable.getIndexes()) {
      if (destIndex.getUnique()) {
        String msg="A UNIQUE index is not allowed on a materialized view. " + "Remove the qualifier \"UNIQUE\" from the index " + destIndex.getTypeName() + "defined on the materialized view \""+ viewName+ "\".";
        throw m_compiler.new VoltCompilerException(msg);
      }
    }
    Table srcTable=stmt.tableList.get(0);
    MaterializedViewInfo matviewinfo=srcTable.getViews().add(viewName);
    matviewinfo.setDest(destTable);
    AbstractExpression where=stmt.getSingleTableFilterExpression();
    if (where != null) {
      String hex=Encoder.hexEncode(where.toJSONString());
      matviewinfo.setPredicate(hex);
    }
 else {
      matviewinfo.setPredicate("");
    }
    destTable.setMaterializer(srcTable);
    List<Column> srcColumnArray=CatalogUtil.getSortedCatalogItems(srcTable.getColumns(),"index");
    List<Column> destColumnArray=CatalogUtil.getSortedCatalogItems(destTable.getColumns(),"index");
    List<AbstractExpression> groupbyExprs=null;
    if (stmt.hasComplexGroupby()) {
      groupbyExprs=new ArrayList<AbstractExpression>();
      HashSet<TupleValueExpression> tves=new HashSet<TupleValueExpression>();
      for (      ParsedColInfo col : stmt.groupByColumns) {
        groupbyExprs.add(col.expression);
        tves.addAll(ExpressionUtil.getTupleValueExpressions(col.expression));
      }
      for (      TupleValueExpression tve : tves) {
        matviewinfo.getGroupbycols().add(tve.getColumnName());
      }
      String groupbyExprsJson=null;
      try {
        groupbyExprsJson=convertToJSONArray(groupbyExprs);
      }
 catch (      JSONException e) {
        throw m_compiler.new VoltCompilerException("Unexpected error serializing non-column " + "expressions for group by expressions: " + e.toString());
      }
      matviewinfo.setGroupbyexpressionsjson(groupbyExprsJson);
    }
 else {
      for (int i=0; i < stmt.groupByColumns.size(); i++) {
        ParsedSelectStmt.ParsedColInfo gbcol=stmt.groupByColumns.get(i);
        Column srcCol=srcColumnArray.get(gbcol.index);
        ColumnRef cref=matviewinfo.getGroupbycols().add(srcCol.getTypeName());
        cref.setIndex(i);
        cref.setColumn(srcCol);
      }
      for (int i=0; i < stmt.groupByColumns.size(); i++) {
        ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
        Column destColumn=destColumnArray.get(i);
        processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumn,ExpressionType.VALUE_TUPLE,(TupleValueExpression)col.expression);
      }
    }
    ParsedSelectStmt.ParsedColInfo countCol=stmt.displayColumns.get(stmt.groupByColumns.size());
    assert(countCol.expression.getExpressionType() == ExpressionType.AGGREGATE_COUNT_STAR);
    assert(countCol.expression.getLeft() == null);
    processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumnArray.get(stmt.groupByColumns.size()),ExpressionType.AGGREGATE_COUNT_STAR,null);
    Index pkIndex=destTable.getIndexes().add("MATVIEW_PK_INDEX");
    pkIndex.setType(IndexType.BALANCED_TREE.getValue());
    pkIndex.setUnique(true);
    for (int i=0; i < stmt.groupByColumns.size(); i++) {
      ColumnRef c=pkIndex.getColumns().add(String.valueOf(i));
      c.setColumn(destColumnArray.get(i));
      c.setIndex(i);
    }
    Constraint pkConstraint=destTable.getConstraints().add("MATVIEW_PK_CONSTRAINT");
    pkConstraint.setType(ConstraintType.PRIMARY_KEY.getValue());
    pkConstraint.setIndex(pkIndex);
    for (int i=stmt.groupByColumns.size() + 1; i < stmt.displayColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
      Column destColumn=destColumnArray.get(i);
      AbstractExpression colExpr=col.expression.getLeft();
      assert(colExpr.getExpressionType() == ExpressionType.VALUE_TUPLE);
      processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumn,col.expression.getExpressionType(),(TupleValueExpression)colExpr);
      destColumn.setType(col.expression.getValueType().getValue());
    }
  }
}
