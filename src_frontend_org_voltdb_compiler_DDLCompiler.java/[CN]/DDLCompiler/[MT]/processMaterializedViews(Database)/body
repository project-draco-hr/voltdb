{
  HashSet<String> viewTableNames=new HashSet<>();
  for (  Entry<Table,String> entry : matViewMap.entrySet()) {
    viewTableNames.add(entry.getKey().getTypeName());
  }
  for (  Entry<Table,String> entry : matViewMap.entrySet()) {
    Table destTable=entry.getKey();
    String query=entry.getValue();
    VoltXMLElement xmlquery=null;
    try {
      xmlquery=m_hsql.getXMLCompiledStatement(query);
    }
 catch (    HSQLParseException e) {
      e.printStackTrace();
    }
    assert(xmlquery != null);
    ParsedSelectStmt stmt=null;
    try {
      stmt=(ParsedSelectStmt)AbstractParsedStmt.parse(query,xmlquery,null,db,null);
    }
 catch (    Exception e) {
      throw m_compiler.new VoltCompilerException(e.getMessage());
    }
    assert(stmt != null);
    String viewName=destTable.getTypeName();
    checkViewMeetsSpec(viewName,stmt);
    for (    Index destIndex : destTable.getIndexes()) {
      if (destIndex.getUnique() || destIndex.getAssumeunique()) {
        String msg="A UNIQUE or ASSUMEUNIQUE index is not allowed on a materialized view. " + "Remove the qualifier from the index " + destIndex.getTypeName() + "defined on the materialized view \""+ viewName+ "\".";
        throw m_compiler.new VoltCompilerException(msg);
      }
    }
    Table srcTable=stmt.tableList.get(0);
    if (viewTableNames.contains(srcTable.getTypeName())) {
      String msg=String.format("A materialized view (%s) can not be defined on another view (%s).",viewName,srcTable.getTypeName());
      throw m_compiler.new VoltCompilerException(msg);
    }
    MaterializedViewInfo matviewinfo=srcTable.getViews().add(viewName);
    matviewinfo.setDest(destTable);
    AbstractExpression where=stmt.getSingleTableFilterExpression();
    if (where != null) {
      String hex=Encoder.hexEncode(where.toJSONString());
      matviewinfo.setPredicate(hex);
    }
 else {
      matviewinfo.setPredicate("");
    }
    destTable.setMaterializer(srcTable);
    List<Column> srcColumnArray=CatalogUtil.getSortedCatalogItems(srcTable.getColumns(),"index");
    List<Column> destColumnArray=CatalogUtil.getSortedCatalogItems(destTable.getColumns(),"index");
    List<AbstractExpression> groupbyExprs=null;
    if (stmt.hasComplexGroupby()) {
      groupbyExprs=new ArrayList<AbstractExpression>();
      for (      ParsedColInfo col : stmt.groupByColumns) {
        groupbyExprs.add(col.expression);
      }
      String groupbyExprsJson=null;
      try {
        groupbyExprsJson=convertToJSONArray(groupbyExprs);
      }
 catch (      JSONException e) {
        throw m_compiler.new VoltCompilerException("Unexpected error serializing non-column " + "expressions for group by expressions: " + e.toString());
      }
      matviewinfo.setGroupbyexpressionsjson(groupbyExprsJson);
    }
 else {
      for (int i=0; i < stmt.groupByColumns.size(); i++) {
        ParsedSelectStmt.ParsedColInfo gbcol=stmt.groupByColumns.get(i);
        Column srcCol=srcColumnArray.get(gbcol.index);
        ColumnRef cref=matviewinfo.getGroupbycols().add(srcCol.getTypeName());
        cref.setIndex(i);
        cref.setColumn(srcCol);
      }
      for (int i=0; i < stmt.groupByColumns.size(); i++) {
        ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
        Column destColumn=destColumnArray.get(i);
        processMaterializedViewColumn(matviewinfo,srcTable,destColumn,ExpressionType.VALUE_TUPLE,(TupleValueExpression)col.expression);
      }
    }
    ParsedSelectStmt.ParsedColInfo countCol=stmt.displayColumns.get(stmt.groupByColumns.size());
    assert(countCol.expression.getExpressionType() == ExpressionType.AGGREGATE_COUNT_STAR);
    assert(countCol.expression.getLeft() == null);
    processMaterializedViewColumn(matviewinfo,srcTable,destColumnArray.get(stmt.groupByColumns.size()),ExpressionType.AGGREGATE_COUNT_STAR,null);
    Index pkIndex=destTable.getIndexes().add("MATVIEW_PK_INDEX");
    pkIndex.setType(IndexType.BALANCED_TREE.getValue());
    pkIndex.setUnique(true);
    for (int i=0; i < stmt.groupByColumns.size(); i++) {
      ColumnRef c=pkIndex.getColumns().add(String.valueOf(i));
      c.setColumn(destColumnArray.get(i));
      c.setIndex(i);
    }
    Constraint pkConstraint=destTable.getConstraints().add("MATVIEW_PK_CONSTRAINT");
    pkConstraint.setType(ConstraintType.PRIMARY_KEY.getValue());
    pkConstraint.setIndex(pkIndex);
    List<AbstractExpression> aggregationExprs=new ArrayList<AbstractExpression>();
    boolean hasAggregationExprs=false;
    boolean hasMinOrMaxAgg=false;
    ArrayList<AbstractExpression> minMaxAggs=new ArrayList<AbstractExpression>();
    for (int i=stmt.groupByColumns.size() + 1; i < stmt.displayColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
      AbstractExpression aggExpr=col.expression.getLeft();
      if (aggExpr.getExpressionType() != ExpressionType.VALUE_TUPLE) {
        hasAggregationExprs=true;
      }
      aggregationExprs.add(aggExpr);
      if (col.expression.getExpressionType() == ExpressionType.AGGREGATE_MIN || col.expression.getExpressionType() == ExpressionType.AGGREGATE_MAX) {
        hasMinOrMaxAgg=true;
        minMaxAggs.add(aggExpr);
      }
    }
    if (hasAggregationExprs) {
      String aggregationExprsJson=null;
      try {
        aggregationExprsJson=convertToJSONArray(aggregationExprs);
      }
 catch (      JSONException e) {
        throw m_compiler.new VoltCompilerException("Unexpected error serializing non-column " + "expressions for aggregation expressions: " + e.toString());
      }
      matviewinfo.setAggregationexpressionsjson(aggregationExprsJson);
    }
    if (hasMinOrMaxAgg) {
      Index found=findBestMatchIndexForMatviewMinOrMax(matviewinfo,srcTable,groupbyExprs);
      if (found != null) {
        matviewinfo.setIndexforminmax(found.getTypeName());
      }
 else {
        matviewinfo.setIndexforminmax("");
        m_compiler.addWarn("No index found to support min() / max() UPDATE and DELETE on Materialized View " + matviewinfo.getTypeName() + ", and a sequential scan might be issued when current min / max value is updated / deleted.");
      }
    }
 else {
      matviewinfo.setIndexforminmax("");
    }
    for (int i=stmt.groupByColumns.size() + 1; i < stmt.displayColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
      Column destColumn=destColumnArray.get(i);
      AbstractExpression colExpr=col.expression.getLeft();
      TupleValueExpression tve=null;
      if (colExpr.getExpressionType() == ExpressionType.VALUE_TUPLE) {
        tve=(TupleValueExpression)colExpr;
      }
      processMaterializedViewColumn(matviewinfo,srcTable,destColumn,col.expression.getExpressionType(),tve);
      destColumn.setType(col.expression.getValueType().getValue());
    }
  }
}
