{
  for (  Entry<Table,String> entry : matViewMap.entrySet()) {
    Table destTable=entry.getKey();
    String query=entry.getValue();
    VoltXMLElement xmlquery=null;
    try {
      xmlquery=m_hsql.getXMLCompiledStatement(query);
    }
 catch (    HSQLParseException e) {
      e.printStackTrace();
    }
    assert(xmlquery != null);
    ParsedSelectStmt stmt=null;
    try {
      stmt=(ParsedSelectStmt)AbstractParsedStmt.parse(query,xmlquery,null,db,null);
    }
 catch (    Exception e) {
      throw m_compiler.new VoltCompilerException(e.getMessage());
    }
    assert(stmt != null);
    checkViewMeetsSpec(destTable.getTypeName(),stmt);
    Table srcTable=stmt.tableList.get(0);
    MaterializedViewInfo matviewinfo=srcTable.getViews().add(destTable.getTypeName());
    matviewinfo.setDest(destTable);
    AbstractExpression where=stmt.getCombinedFilterExpression();
    if (where != null) {
      String hex=Encoder.hexEncode(where.toJSONString());
      matviewinfo.setPredicate(hex);
    }
 else {
      matviewinfo.setPredicate("");
    }
    destTable.setMaterializer(srcTable);
    List<Column> srcColumnArray=CatalogUtil.getSortedCatalogItems(srcTable.getColumns(),"index");
    List<Column> destColumnArray=CatalogUtil.getSortedCatalogItems(destTable.getColumns(),"index");
    for (int i=0; i < stmt.groupByColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo gbcol=stmt.groupByColumns.get(i);
      Column srcCol=srcColumnArray.get(gbcol.index);
      ColumnRef cref=matviewinfo.getGroupbycols().add(srcCol.getTypeName());
      cref.setIndex(i);
      cref.setColumn(srcCol);
    }
    ParsedSelectStmt.ParsedColInfo countCol=stmt.displayColumns.get(stmt.groupByColumns.size());
    assert(countCol.expression.getExpressionType() == ExpressionType.AGGREGATE_COUNT_STAR);
    assert(countCol.expression.getLeft() == null);
    processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumnArray.get(stmt.groupByColumns.size()),ExpressionType.AGGREGATE_COUNT_STAR,null);
    Index pkIndex=destTable.getIndexes().add("MATVIEW_PK_INDEX");
    pkIndex.setType(IndexType.BALANCED_TREE.getValue());
    pkIndex.setUnique(true);
    for (int i=0; i < stmt.groupByColumns.size(); i++) {
      ColumnRef c=pkIndex.getColumns().add(String.valueOf(i));
      c.setColumn(destColumnArray.get(i));
      c.setIndex(i);
    }
    Constraint pkConstraint=destTable.getConstraints().add("MATVIEW_PK_CONSTRAINT");
    pkConstraint.setType(ConstraintType.PRIMARY_KEY.getValue());
    pkConstraint.setIndex(pkIndex);
    for (int i=0; i < stmt.groupByColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
      Column destColumn=destColumnArray.get(i);
      processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumn,ExpressionType.VALUE_TUPLE,(TupleValueExpression)col.expression);
    }
    for (int i=stmt.groupByColumns.size() + 1; i < stmt.displayColumns.size(); i++) {
      ParsedSelectStmt.ParsedColInfo col=stmt.displayColumns.get(i);
      Column destColumn=destColumnArray.get(i);
      AbstractExpression colExpr=col.expression.getLeft();
      assert(colExpr.getExpressionType() == ExpressionType.VALUE_TUPLE);
      processMaterializedViewColumn(matviewinfo,srcTable,destTable,destColumn,col.expression.getExpressionType(),(TupleValueExpression)colExpr);
      destColumn.setType(col.expression.getValueType().getValue());
    }
  }
}
