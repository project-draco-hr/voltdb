{
  int messagesOffered=0;
  if (!m_socket.isConnected() || !m_socket.isOpen()) {
    m_state=CLOSING;
  }
  if (m_state == CLOSING) {
    return messagesOffered;
  }
  ExportProtoMessage m=null;
  do {
    try {
      m=nextMessage();
    }
 catch (    IOException e) {
      m_logger.error("Socket error: " + e.getMessage());
      m_state=CLOSING;
    }
    if (m != null && m.isError()) {
      m_state=CLOSING;
    }
    if (!m_socket.isConnected() || !m_socket.isOpen()) {
      m_state=CLOSING;
    }
    if (m != null && m.isPollResponse()) {
      m_lastAckOffset=m.getAckOffset();
      HashMap<String,HashMap<Integer,ExportDataSink>> gen_map=m_sinks.get(m.getGeneration());
      if (gen_map == null) {
        m_logger.error("Could not find sinks for generation " + m.getGeneration());
        continue;
      }
      HashMap<Integer,ExportDataSink> part_map=gen_map.get(m.getSignature());
      if (part_map == null) {
        m_logger.error("Could not find datasink for generation " + m.getGeneration() + " table signature "+ m.getSignature());
        continue;
      }
      ExportDataSink rx_sink=part_map.get(m.getPartitionId());
      if (rx_sink == null) {
        m_logger.error("Could not datasink for generation " + m.getGeneration() + " table signature "+ m.getSignature()+ " partition "+ m.getPartitionId());
        continue;
      }
      rx_sink.getRxQueue(name).offer(m);
      messagesOffered++;
    }
  }
 while (m_state == CONNECTED && m != null);
  for (  HashMap<String,HashMap<Integer,ExportDataSink>> gen_map : m_sinks.values()) {
    for (    HashMap<Integer,ExportDataSink> part_map : gen_map.values()) {
      for (      ExportDataSink tx_sink : part_map.values()) {
        Queue<ExportProtoMessage> tx_queue=tx_sink.getTxQueue(name);
        if (tx_queue != null) {
          ExportProtoMessage tx_m=tx_queue.poll();
          if (tx_m != null) {
            try {
              sendMessage(tx_m);
            }
 catch (            IOException e) {
              m_logger.trace("Failed to send message to server",e);
            }
          }
        }
      }
    }
  }
  return messagesOffered;
}
