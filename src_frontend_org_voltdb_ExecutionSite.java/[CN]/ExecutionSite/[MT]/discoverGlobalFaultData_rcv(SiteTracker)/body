{
  java.util.ArrayList<FailureSiteUpdateMessage> messages=new java.util.ArrayList<FailureSiteUpdateMessage>();
  long blockedOnReceiveStart=System.currentTimeMillis();
  long lastReportTime=0;
  do {
    VoltMessage m=m_mailbox.recvBlocking(new Subject[]{Subject.FAILURE,Subject.FAILURE_SITE_UPDATE},5);
    final long now=System.currentTimeMillis();
    if (now - blockedOnReceiveStart > 10000) {
      if (now - lastReportTime > 60000) {
        lastReportTime=System.currentTimeMillis();
        haveNecessaryFaultInfo(newTracker,m_pendingFailedSites,true);
      }
    }
    if (m == null) {
      tick();
      continue;
    }
    FailureSiteUpdateMessage fm=null;
    if (m.getSubject() == Subject.FAILURE_SITE_UPDATE.getId()) {
      fm=(FailureSiteUpdateMessage)m;
      messages.add(fm);
      m_failureSiteUpdateLedger.put(Pair.of(fm.m_sourceHSId,fm.m_initiatorForSafeTxnId),Pair.of(fm.m_safeTxnId,fm.m_committedTxnId));
    }
 else     if (m.getSubject() == Subject.FAILURE.getId()) {
      HashSet<SiteFailureFault> faults=((ExecutionSiteNodeFailureMessage)m).m_failedSites;
      HashSet<Long> newFailedSiteIds=new HashSet<Long>();
      for (      SiteFailureFault fault : faults) {
        newFailedSiteIds.addAll((fault).getSiteIds());
      }
      m_mailbox.deliverFront(m);
      m_recoveryLog.info("Detected a concurrent failure from FaultDistributor, new failed sites " + CoreUtils.hsIdCollectionToString(newFailedSiteIds));
      return false;
    }
    m_recoveryLog.info("Received failure message  from " + CoreUtils.hsIdToString(fm.m_sourceHSId) + " for failed sites "+ CoreUtils.hsIdCollectionToString(fm.m_failedHSIds)+ " for initiator id "+ CoreUtils.hsIdToString(fm.m_initiatorForSafeTxnId)+ " with commit point "+ fm.m_committedTxnId+ " safe txn id "+ fm.m_safeTxnId);
  }
 while (!haveNecessaryFaultInfo(newTracker,m_pendingFailedSites,false));
  return true;
}
