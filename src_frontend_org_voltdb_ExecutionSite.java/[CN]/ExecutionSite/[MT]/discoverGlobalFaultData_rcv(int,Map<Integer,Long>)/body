{
  final int localPartitionId=m_context.siteTracker.getPartitionForSite(m_siteId);
  int responses=0;
  int responsesFromSamePartition=0;
  long commitPoint=Long.MIN_VALUE;
  java.util.ArrayList<FailureSiteUpdateMessage> messages=new java.util.ArrayList<FailureSiteUpdateMessage>();
  do {
    VoltMessage m=m_mailbox.recvBlocking(new Subject[]{Subject.FAILURE,Subject.FAILURE_SITE_UPDATE},5);
    if (m == null) {
      tick();
      continue;
    }
    FailureSiteUpdateMessage fm=null;
    if (m.getSubject() == Subject.FAILURE_SITE_UPDATE.getId()) {
      fm=(FailureSiteUpdateMessage)m;
      messages.add(fm);
    }
 else     if (m.getSubject() == Subject.FAILURE.getId()) {
      HashSet<NodeFailureFault> faults=((ExecutionSiteNodeFailureMessage)m).m_failedHosts;
      HashSet<Integer> newFailedSiteIds=new HashSet<Integer>();
      for (      NodeFailureFault fault : faults) {
        newFailedSiteIds.addAll(m_context.siteTracker.getAllSitesForHost(fault.getHostId()));
      }
      m_mailbox.deliverFront(m);
      m_recoveryLog.info("Detected a concurrent failure from FaultDistributor, new failed sites " + newFailedSiteIds);
      return null;
    }
    if (!m_knownFailedSites.equals(fm.m_failedSiteIds)) {
      if (!m_knownFailedSites.containsAll(fm.m_failedSiteIds)) {
        HashSet<Integer> difference=new HashSet<Integer>(fm.m_failedSiteIds);
        difference.removeAll(m_knownFailedSites);
        Set<Integer> differenceHosts=new HashSet<Integer>();
        for (        Integer siteId : difference) {
          differenceHosts.add(m_context.siteTracker.getHostForSite(siteId));
        }
        for (        Integer hostId : differenceHosts) {
          String hostname=String.valueOf(hostId);
          if (VoltDB.instance() != null) {
            if (VoltDB.instance().getHostMessenger() != null) {
              String hostnameTemp=VoltDB.instance().getHostMessenger().getHostnameForHostID(hostId);
              if (hostnameTemp != null)               hostname=hostnameTemp;
            }
          }
          VoltDB.instance().getFaultDistributor().reportFault(new NodeFailureFault(hostId,m_context.siteTracker.getNonExecSitesForHost(hostId),hostname));
        }
        m_recoveryLog.info("Detected a concurrent failure from " + fm.m_sourceSiteId + " with new failed sites "+ difference.toString());
        m_mailbox.deliver(m);
        return null;
      }
 else {
        HashSet<Integer> difference=new HashSet<Integer>(m_knownFailedSites);
        difference.removeAll(fm.m_failedSiteIds);
        m_recoveryLog.info("Discarding failure message from " + fm.m_sourceSiteId + " because it was missing failed sites "+ difference.toString());
        continue;
      }
    }
    ++responses;
    m_recoveryLog.info("Received failure message " + responses + " of "+ expectedResponses+ " from "+ fm.m_sourceSiteId+ " for failed sites "+ fm.m_failedSiteIds+ " with commit point "+ fm.m_committedTxnId+ " safe txn id "+ fm.m_safeTxnId);
    commitPoint=Math.max(commitPoint,fm.m_committedTxnId);
    final int remotePartitionId=m_context.siteTracker.getPartitionForSite(fm.m_sourceSiteId);
    if (remotePartitionId == localPartitionId) {
      Integer initiatorId=fm.m_initiatorForSafeTxnId;
      if (!initiatorSafeInitPoint.containsKey(initiatorId)) {
        initiatorSafeInitPoint.put(initiatorId,Long.MIN_VALUE);
      }
      initiatorSafeInitPoint.put(initiatorId,Math.max(initiatorSafeInitPoint.get(initiatorId),fm.m_safeTxnId));
      responsesFromSamePartition++;
    }
  }
 while (responses < expectedResponses);
  assert(commitPoint != Long.MIN_VALUE);
  assert(!initiatorSafeInitPoint.containsValue(Long.MIN_VALUE));
  return commitPoint;
}
