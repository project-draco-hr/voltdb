{
  long globalCommitPoint=Long.MAX_VALUE;
  long globalInitiationPoint=Long.MAX_VALUE;
  m_context=VoltDB.instance().getCatalogContext();
  ArrayList<Integer> failedSites=m_context.siteTracker.getAllSitesForHost(hostId);
  for (  Integer i : failedSites) {
    if (m_context.siteTracker.getSiteForId(i).getIsexec() == false) {
      m_transactionQueue.gotFaultForInitiator(i);
    }
  }
  Iterator<Long> it=m_transactionsById.keySet().iterator();
  while (it.hasNext()) {
    final long tid=it.next();
    TransactionState ts=m_transactionsById.get(tid);
    ts.handleSiteFaults(failedSites);
    if (ts.txnId > globalInitiationPoint && failedSites.contains(ts.initiatorSiteId)) {
      log.info("Site " + getSiteId() + " faulting transaction "+ ts.txnId+ " as a result of host failure at node "+ hostId);
      it.remove();
      m_transactionQueue.faultTransaction(ts);
    }
 else     if (ts instanceof MultiPartitionParticipantTxnState && failedSites.contains(ts.coordinatorSiteId)) {
      if (ts.isInProgress() && ts.txnId <= globalCommitPoint) {
        System.err.println("Commit in-progress MP on failure, not supported.");
        VoltDB.crashVoltDB();
      }
 else       if (ts.isInProgress() && ts.txnId > globalCommitPoint) {
        System.err.println("Rollback in-progress MP on failure, not supported.");
        VoltDB.crashVoltDB();
      }
 else {
        log.info("Site " + getSiteId() + " faulting transaction "+ ts.txnId+ " as a result of host failure at node "+ hostId);
        it.remove();
        m_transactionQueue.faultTransaction(ts);
      }
    }
  }
}
