{
  if (!haveNecessaryFaultInfo(newTracker,m_pendingFailedSites)) {
    VoltDB.crashLocalVoltDB("Error extracting fault data",true,null);
  }
  long commitPoint=Long.MIN_VALUE;
  final int localPartitionId=newTracker.getPartitionForSite(m_siteId);
  Iterator<Map.Entry<Pair<Long,Long>,Pair<Long,Long>>> iter=m_failureSiteUpdateLedger.entrySet().iterator();
  while (iter.hasNext()) {
    final Map.Entry<Pair<Long,Long>,Pair<Long,Long>> entry=iter.next();
    final Pair<Long,Long> key=entry.getKey();
    final Pair<Long,Long> value=entry.getValue();
    final Long safeTxnId=value.getFirst();
    final Long commitedTxnId=value.getSecond();
    if (!m_tracker.m_allExecutionSitesImmutable.contains(key.getFirst())) {
      continue;
    }
    final int remotePartitionId=m_tracker.getPartitionForSite(key.getFirst());
    commitPoint=Math.max(commitPoint,commitedTxnId);
    if (remotePartitionId == localPartitionId) {
      Long initiatorId=key.getSecond();
      if (!initiatorSafeInitPoint.containsKey(initiatorId)) {
        initiatorSafeInitPoint.put(initiatorId,Long.MIN_VALUE);
      }
      initiatorSafeInitPoint.put(initiatorId,Math.max(initiatorSafeInitPoint.get(initiatorId),safeTxnId));
    }
  }
  assert(commitPoint != Long.MIN_VALUE);
  assert(!initiatorSafeInitPoint.containsValue(Long.MIN_VALUE));
  return commitPoint;
}
