def install_python(home_dir, lib_dir, inc_dir, bin_dir, site_packages, clear):
    'Install just the base environment, no distutils patches etc'
    if sys.executable.startswith(bin_dir):
        print 'Please use the *system* python to run this script'
        return
    if clear:
        rmtree(lib_dir)
        logger.notify('Not deleting %s', bin_dir)
    if hasattr(sys, 'real_prefix'):
        logger.notify(('Using real prefix %r' % sys.real_prefix))
        prefix = sys.real_prefix
    elif hasattr(sys, 'base_prefix'):
        logger.notify(('Using base prefix %r' % sys.base_prefix))
        prefix = sys.base_prefix
    else:
        prefix = sys.prefix
    mkdir(lib_dir)
    fix_lib64(lib_dir)
    stdlib_dirs = [os.path.dirname(os.__file__)]
    if is_win:
        stdlib_dirs.append(join(os.path.dirname(stdlib_dirs[0]), 'DLLs'))
    elif is_darwin:
        stdlib_dirs.append(join(stdlib_dirs[0], 'site-packages'))
    if hasattr(os, 'symlink'):
        logger.info('Symlinking Python bootstrap modules')
    else:
        logger.info('Copying Python bootstrap modules')
    logger.indent += 2
    try:
        for stdlib_dir in stdlib_dirs:
            if (not os.path.isdir(stdlib_dir)):
                continue
            for fn in os.listdir(stdlib_dir):
                bn = os.path.splitext(fn)[0]
                if ((fn != 'site-packages') and (bn in REQUIRED_FILES)):
                    copyfile(join(stdlib_dir, fn), join(lib_dir, fn))
        copy_required_modules(home_dir)
    finally:
        logger.indent -= 2
    mkdir(join(lib_dir, 'site-packages'))
    import site
    site_filename = site.__file__
    if site_filename.endswith('.pyc'):
        site_filename = site_filename[:(-1)]
    elif site_filename.endswith('$py.class'):
        site_filename = site_filename.replace('$py.class', '.py')
    site_filename_dst = change_prefix(site_filename, home_dir)
    site_dir = os.path.dirname(site_filename_dst)
    writefile(site_filename_dst, SITE_PY)
    writefile(join(site_dir, 'orig-prefix.txt'), prefix)
    site_packages_filename = join(site_dir, 'no-global-site-packages.txt')
    if (not site_packages):
        writefile(site_packages_filename, '')
    if (is_pypy or is_win):
        stdinc_dir = join(prefix, 'include')
    else:
        stdinc_dir = join(prefix, 'include', (py_version + abiflags))
    if os.path.exists(stdinc_dir):
        copyfile(stdinc_dir, inc_dir)
    else:
        logger.debug(('No include dir %s' % stdinc_dir))
    platinc_dir = distutils.sysconfig.get_python_inc(plat_specific=1)
    if (platinc_dir != stdinc_dir):
        platinc_dest = distutils.sysconfig.get_python_inc(plat_specific=1, prefix=home_dir)
        if (platinc_dir == platinc_dest):
            platinc_dest = subst_path(platinc_dir, prefix, home_dir)
        if platinc_dest:
            copyfile(platinc_dir, platinc_dest)
    if ((sys.exec_prefix != prefix) and (not is_pypy)):
        if is_win:
            exec_dir = join(sys.exec_prefix, 'lib')
        elif is_jython:
            exec_dir = join(sys.exec_prefix, 'Lib')
        else:
            exec_dir = join(sys.exec_prefix, 'lib', py_version)
        for fn in os.listdir(exec_dir):
            copyfile(join(exec_dir, fn), join(lib_dir, fn))
    if is_jython:
        for name in ('jython-dev.jar', 'javalib', 'jython.jar'):
            src = join(prefix, name)
            if os.path.exists(src):
                copyfile(src, join(home_dir, name))
        src = join(prefix, 'registry')
        if os.path.exists(src):
            copyfile(src, join(home_dir, 'registry'), symlink=False)
        copyfile(join(prefix, 'cachedir'), join(home_dir, 'cachedir'), symlink=False)
    mkdir(bin_dir)
    py_executable = join(bin_dir, os.path.basename(sys.executable))
    if ('Python.framework' in prefix):
        if os.environ.get('__PYVENV_LAUNCHER__'):
            os.unsetenv('__PYVENV_LAUNCHER__')
        if re.search('/Python(?:-32|-64)*$', py_executable):
            py_executable = os.path.join(os.path.dirname(py_executable), 'python')
    logger.notify('New %s executable in %s', expected_exe, py_executable)
    pcbuild_dir = os.path.dirname(sys.executable)
    pyd_pth = os.path.join(lib_dir, 'site-packages', 'virtualenv_builddir_pyd.pth')
    if (is_win and os.path.exists(os.path.join(pcbuild_dir, 'build.bat'))):
        logger.notify('Detected python running from build directory %s', pcbuild_dir)
        logger.notify('Writing .pth file linking to build directory for *.pyd files')
        writefile(pyd_pth, pcbuild_dir)
    else:
        pcbuild_dir = None
        if os.path.exists(pyd_pth):
            logger.info(('Deleting %s (not Windows env or not build directory python)' % pyd_pth))
            os.unlink(pyd_pth)
    if (sys.executable != py_executable):
        executable = sys.executable
        shutil.copyfile(executable, py_executable)
        make_exe(py_executable)
        if (is_win or is_cygwin):
            pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw):
                logger.info('Also created pythonw.exe')
                shutil.copyfile(pythonw, os.path.join(os.path.dirname(py_executable), 'pythonw.exe'))
            python_d = os.path.join(os.path.dirname(sys.executable), 'python_d.exe')
            python_d_dest = os.path.join(os.path.dirname(py_executable), 'python_d.exe')
            if os.path.exists(python_d):
                logger.info('Also created python_d.exe')
                shutil.copyfile(python_d, python_d_dest)
            elif os.path.exists(python_d_dest):
                logger.info('Removed python_d.exe as it is no longer at the source')
                os.unlink(python_d_dest)
            py_executable_dll = ('python%s%s.dll' % (sys.version_info[0], sys.version_info[1]))
            py_executable_dll_d = ('python%s%s_d.dll' % (sys.version_info[0], sys.version_info[1]))
            pythondll = os.path.join(os.path.dirname(sys.executable), py_executable_dll)
            pythondll_d = os.path.join(os.path.dirname(sys.executable), py_executable_dll_d)
            pythondll_d_dest = os.path.join(os.path.dirname(py_executable), py_executable_dll_d)
            if os.path.exists(pythondll):
                logger.info(('Also created %s' % py_executable_dll))
                shutil.copyfile(pythondll, os.path.join(os.path.dirname(py_executable), py_executable_dll))
            if os.path.exists(pythondll_d):
                logger.info(('Also created %s' % py_executable_dll_d))
                shutil.copyfile(pythondll_d, pythondll_d_dest)
            elif os.path.exists(pythondll_d_dest):
                logger.info(('Removed %s as the source does not exist' % pythondll_d_dest))
                os.unlink(pythondll_d_dest)
        if is_pypy:
            python_executable = os.path.join(os.path.dirname(py_executable), 'python')
            if (sys.platform in ('win32', 'cygwin')):
                python_executable += '.exe'
            logger.info(('Also created executable %s' % python_executable))
            copyfile(py_executable, python_executable)
            if is_win:
                for name in ('libexpat.dll', 'libpypy.dll', 'libpypy-c.dll', 'libeay32.dll', 'ssleay32.dll', 'sqlite.dll'):
                    src = join(prefix, name)
                    if os.path.exists(src):
                        copyfile(src, join(bin_dir, name))
    if (os.path.splitext(os.path.basename(py_executable))[0] != expected_exe):
        secondary_exe = os.path.join(os.path.dirname(py_executable), expected_exe)
        py_executable_ext = os.path.splitext(py_executable)[1]
        if (py_executable_ext == '.exe'):
            secondary_exe += py_executable_ext
        if os.path.exists(secondary_exe):
            logger.warn(('Not overwriting existing %s script %s (you must use %s)' % (expected_exe, secondary_exe, py_executable)))
        else:
            logger.notify(('Also creating executable in %s' % secondary_exe))
            shutil.copyfile(sys.executable, secondary_exe)
            make_exe(secondary_exe)
    if ('.framework' in prefix):
        if ('Python.framework' in prefix):
            logger.debug('MacOSX Python framework detected')
            original_python = os.path.join(prefix, 'Resources/Python.app/Contents/MacOS/Python')
        if ('EPD' in prefix):
            logger.debug('EPD framework detected')
            original_python = os.path.join(prefix, 'bin/python')
        shutil.copy(original_python, py_executable)
        virtual_lib = os.path.join(home_dir, '.Python')
        if os.path.exists(virtual_lib):
            os.unlink(virtual_lib)
        copyfile(os.path.join(prefix, 'Python'), virtual_lib)
        try:
            mach_o_change(py_executable, os.path.join(prefix, 'Python'), '@executable_path/../.Python')
        except:
            e = sys.exc_info()[1]
            logger.warn(('Could not call mach_o_change: %s. Trying to call install_name_tool instead.' % e))
            try:
                call_subprocess(['install_name_tool', '-change', os.path.join(prefix, 'Python'), '@executable_path/../.Python', py_executable])
            except:
                logger.fatal("Could not call install_name_tool -- you must have Apple's development tools installed")
                raise
    if (not is_win):
        py_exe_version_major = ('python%s' % sys.version_info[0])
        py_exe_version_major_minor = ('python%s.%s' % (sys.version_info[0], sys.version_info[1]))
        py_exe_no_version = 'python'
        required_symlinks = [py_exe_no_version, py_exe_version_major, py_exe_version_major_minor]
        py_executable_base = os.path.basename(py_executable)
        if (py_executable_base in required_symlinks):
            required_symlinks.remove(py_executable_base)
        for pth in required_symlinks:
            full_pth = join(bin_dir, pth)
            if os.path.exists(full_pth):
                os.unlink(full_pth)
            os.symlink(py_executable_base, full_pth)
    if (is_win and (' ' in py_executable)):
        py_executable = ('"%s"' % py_executable)
    cmd = [py_executable, '-c', 'import sys;out=sys.stdout;getattr(out, "buffer", out).write(sys.prefix.encode("utf-8"))']
    logger.info(('Testing executable with %s %s "%s"' % tuple(cmd)))
    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        (proc_stdout, proc_stderr) = proc.communicate()
    except OSError:
        e = sys.exc_info()[1]
        if (e.errno == errno.EACCES):
            logger.fatal(('ERROR: The executable %s could not be run: %s' % (py_executable, e)))
            sys.exit(100)
        else:
            raise e
    proc_stdout = proc_stdout.strip().decode('utf-8')
    proc_stdout = os.path.normcase(os.path.abspath(proc_stdout))
    norm_home_dir = os.path.normcase(os.path.abspath(home_dir))
    if hasattr(norm_home_dir, 'decode'):
        norm_home_dir = norm_home_dir.decode(sys.getfilesystemencoding())
    if (proc_stdout != norm_home_dir):
        logger.fatal(('ERROR: The executable %s is not functioning' % py_executable))
        logger.fatal(('ERROR: It thinks sys.prefix is %r (should be %r)' % (proc_stdout, norm_home_dir)))
        logger.fatal('ERROR: virtualenv is not compatible with this system or executable')
        if is_win:
            logger.fatal('Note: some Windows users have reported this error when they installed Python for "Only this user" or have multiple versions of Python installed. Copying the appropriate PythonXX.dll to the virtualenv Scripts/ directory may fix this problem.')
        sys.exit(100)
    else:
        logger.info(('Got sys.prefix result: %r' % proc_stdout))
    pydistutils = os.path.expanduser('~/.pydistutils.cfg')
    if os.path.exists(pydistutils):
        logger.notify(('Please make sure you remove any previous custom paths from your %s file.' % pydistutils))
    fix_local_scheme(home_dir)
    if site_packages:
        if os.path.exists(site_packages_filename):
            logger.info(('Deleting %s' % site_packages_filename))
            os.unlink(site_packages_filename)
    return py_executable
