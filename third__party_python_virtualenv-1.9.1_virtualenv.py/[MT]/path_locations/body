def path_locations(home_dir):
    'Return the path locations for the environment (where libraries are,\n    where scripts go, etc)'
    if is_win:
        mkdir(home_dir)
        if (' ' in home_dir):
            import ctypes
            GetShortPathName = ctypes.windll.kernel32.GetShortPathNameW
            size = max((len(home_dir) + 1), 256)
            buf = ctypes.create_unicode_buffer(size)
            try:
                u = unicode
            except NameError:
                u = str
            ret = GetShortPathName(u(home_dir), buf, size)
            if (not ret):
                print ('Error: the path "%s" has a space in it' % home_dir)
                print 'We could not determine the short pathname for it.'
                print 'Exiting.'
                sys.exit(3)
            home_dir = str(buf.value)
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'Scripts')
    if is_jython:
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'bin')
    elif is_pypy:
        lib_dir = home_dir
        inc_dir = join(home_dir, 'include')
        bin_dir = join(home_dir, 'bin')
    elif (not is_win):
        lib_dir = join(home_dir, 'lib', py_version)
        multiarch_exec = '/usr/bin/multiarch-platform'
        if is_executable_file(multiarch_exec):
            p = subprocess.Popen(multiarch_exec, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = p.communicate()
            inc_dir = join(home_dir, 'include', stdout.strip(), (py_version + abiflags))
        else:
            inc_dir = join(home_dir, 'include', (py_version + abiflags))
        bin_dir = join(home_dir, 'bin')
    return (home_dir, lib_dir, inc_dir, bin_dir)
