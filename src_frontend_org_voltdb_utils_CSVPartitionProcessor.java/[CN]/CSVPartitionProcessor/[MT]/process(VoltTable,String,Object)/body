{
  List<CSVLineWithMetaData> batchList=new ArrayList<CSVLineWithMetaData>();
  while (true) {
    if (m_errored) {
      CSVFileReader.errored=true;
      return;
    }
    List<CSVLineWithMetaData> mlineList=new ArrayList<CSVLineWithMetaData>();
    m_partitionQueue.drainTo(mlineList,config.batch);
    for (    CSVLineWithMetaData lineList : mlineList) {
      if (lineList == endOfData) {
        if (table.getRowCount() > 0) {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this,failedQueue);
          try {
            if (!isMP) {
              csvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              csvClient.callProcedure(cbmt,procName,tableName,table);
            }
            m_partitionProcessedCount.addAndGet(table.getRowCount());
          }
 catch (          IOException ex) {
            String[] info={lineList.rawLine.toString(),ex.toString()};
            m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          }
        }
        return;
      }
      if (!config.useSuppliedProcedure) {
        try {
          if (VoltTableUtil.addRowToVoltTableFromLine(table,lineList.correctedLine,columnTypes)) {
            batchList.add(lineList);
          }
 else {
            String[] info={lineList.rawLine.toString(),"Missing or Invalid Data in Row."};
            m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
            continue;
          }
        }
 catch (        Exception ex) {
          String[] info={lineList.rawLine.toString(),ex.toString()};
          m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          continue;
        }
        if (table.getRowCount() >= config.batch) {
          try {
            PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this,failedQueue);
            if (!isMP) {
              csvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              csvClient.callProcedure(cbmt,procName,tableName,table);
            }
            m_partitionProcessedCount.addAndGet(table.getRowCount());
            table.clearRowData();
          }
 catch (          IOException ex) {
            table.clearRowData();
            String[] info={lineList.rawLine.toString(),ex.toString()};
            m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
            return;
          }
          batchList=new ArrayList<CSVLineWithMetaData>();
        }
      }
 else {
        try {
          PartitionSingleExecuteProcedureCallback cbmt=new PartitionSingleExecuteProcedureCallback(lineList,this);
          csvClient.callProcedure(cbmt,procName,(Object[])lineList.correctedLine);
          m_partitionProcessedCount.incrementAndGet();
        }
 catch (        IOException ex) {
          String[] info={lineList.rawLine.toString(),ex.toString()};
          m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          return;
        }
      }
    }
  }
}
