{
  VoltTable table=new VoltTable(colInfo);
  while (true) {
    CSVLineWithMetaData lineList=null;
    try {
      lineList=lineq.take();
    }
 catch (    InterruptedException ex) {
      Logger.getLogger(CSVLoaderMT.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (lineList == dummy) {
      if (table.getRowCount() > 0) {
        CSVLoaderMT.MyMTCallback cbmt=new CSVLoaderMT.MyMTCallback(table.getRowCount());
        try {
          byte pparam[]=new byte[1];
          pparam[0]=((Integer)partitionId).byteValue();
          csvClient.callProcedure(cbmt,"@LoadPartitionData",partitionId,tableName,table);
          CSVFileReader.inCount.addAndGet(table.getRowCount());
          partitionProcessedCount+=table.getRowCount();
        }
 catch (        IOException ex) {
          Logger.getLogger(CSVPartitionProcessor.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
      System.out.println("Done Processing partition: " + partitionId + " Processed: "+ partitionProcessedCount);
      break;
    }
    if (lineList == null) {
      continue;
    }
    VoltTableUtil.toVoltTableFromLine(table,lineList.line,colNames,columnTypes);
    if (table.getRowCount() > batchmax) {
      try {
        CSVLoaderMT.MyMTCallback cbmt=new CSVLoaderMT.MyMTCallback(table.getRowCount());
        byte pparam[]=new byte[1];
        pparam[0]=((Integer)partitionId).byteValue();
        csvClient.callProcedure(cbmt,"@LoadPartitionData",partitionId,tableName,table);
        CSVFileReader.inCount.addAndGet(table.getRowCount());
        partitionProcessedCount+=table.getRowCount();
        table.clearRowData();
      }
 catch (      IOException ex) {
        Logger.getLogger(CSVPartitionProcessor.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}
