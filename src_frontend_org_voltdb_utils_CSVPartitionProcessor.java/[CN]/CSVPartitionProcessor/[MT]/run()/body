{
  Client lcsvClient=csvClient;
  VoltTable table=new VoltTable(colInfo);
  String procName=(isMP ? "@LoadMultipartitionTable" : (isLoadTable ? "@LoadPartitionData" : "@LoadSinglepartitionTable"));
  if (config.ping) {
    procName="@Ping";
  }
 else   if (config.legacy) {
    procName=insertProcedure;
  }
  m_log.info("Using Procedure: " + procName);
  Object partitionParam;
  if (isLoadTable) {
    partitionParam=partitionId;
  }
 else {
    partitionParam=TheHashinator.valueToBytes(partitionId);
  }
  String lastLine[]=null;
  while (true) {
    List<CSVLineWithMetaData> mlineList=new ArrayList<CSVLineWithMetaData>();
    lineq.drainTo(mlineList);
    boolean end=false;
    for (    CSVLineWithMetaData lineList : mlineList) {
      if (errored) {
        end=true;
        break;
      }
      if (lineList == dummy) {
        if (config.legacy) {
          end=true;
          break;
        }
        if (table.getRowCount() > 0) {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(table.getRowCount(),lastLine,this);
          try {
            if (!isMP) {
              lcsvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              lcsvClient.callProcedure(cbmt,procName,tableName,table);
            }
            partitionProcessedCount+=table.getRowCount();
          }
 catch (          IOException ex) {
            errored=synchronizeErrorInfo(lineList.lineNumber,lineList.line);
            break;
          }
        }
        end=true;
        break;
      }
      lastLine=lineList.line;
      if (!config.legacy) {
        try {
          VoltTableUtil.toVoltTableFromLine(table,lineList.line,columnTypes);
        }
 catch (        Exception ex) {
          errored=synchronizeErrorInfo(lineList.lineNumber,lineList.line);
          continue;
        }
        if (table.getRowCount() > config.batch) {
          try {
            PartitionProcedureCallback cbmt=new PartitionProcedureCallback(table.getRowCount(),lineList.line,this);
            if (!isMP) {
              lcsvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              lcsvClient.callProcedure(cbmt,procName,tableName,table);
            }
            partitionProcessedCount+=table.getRowCount();
            table.clearRowData();
          }
 catch (          IOException ex) {
            table.clearRowData();
            errored=synchronizeErrorInfo(lineList.lineNumber,lineList.line);
            break;
          }
        }
      }
 else {
        try {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(1,lineList.line,this);
          csvClient.callProcedure(cbmt,procName,(Object[])lineList.line);
          partitionProcessedCount++;
        }
 catch (        IOException ex) {
          errored=synchronizeErrorInfo(lineList.lineNumber,lineList.line);
          break;
        }
      }
    }
    if (end) {
      break;
    }
  }
  try {
    lcsvClient.drain();
  }
 catch (  NoConnectionsException ex) {
    Logger.getLogger(CSVPartitionProcessor.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  InterruptedException ex) {
    Logger.getLogger(CSVPartitionProcessor.class.getName()).log(Level.SEVERE,null,ex);
  }
  CSVPartitionProcessor.pcount.countDown();
  System.out.println("Done Processing partition: " + partitionId + " Processed: "+ partitionProcessedCount);
}
