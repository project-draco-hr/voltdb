{
  VoltTable table=new VoltTable(colInfo);
  String procName=(isMP ? "@LoadMultipartitionTable" : "@LoadSinglepartitionTable");
  if (config.useSuppliedProcedure) {
    procName=insertProcedure;
  }
  Object partitionParam=null;
  if (!isMP) {
    partitionParam=TheHashinator.valueToBytes(partitionId);
  }
  while (true) {
    List<CSVLineWithMetaData> mlineList=new ArrayList<CSVLineWithMetaData>();
    List<CSVLineWithMetaData> batchList=new ArrayList<CSVLineWithMetaData>();
    lineq.drainTo(mlineList);
    boolean end=false;
    for (    CSVLineWithMetaData lineList : mlineList) {
      if (errored) {
        end=true;
        break;
      }
      if (lineList == dummy) {
        if (config.useSuppliedProcedure) {
          end=true;
          break;
        }
        if (table.getRowCount() > 0) {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this);
          try {
            if (!isMP) {
              csvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              csvClient.callProcedure(cbmt,procName,tableName,table);
            }
            partitionProcessedCount+=table.getRowCount();
          }
 catch (          IOException ex) {
            String[] info={lineList.rawLineData.toString(),ex.toString()};
            errored=synchronizeErrorInfo(lineList.lineNumber,info);
            break;
          }
        }
        end=true;
        break;
      }
      if (!config.useSuppliedProcedure) {
        try {
          VoltTableUtil.toVoltTableFromLine(table,lineList.line,columnTypes);
          batchList.add(lineList);
        }
 catch (        Exception ex) {
          String[] info={lineList.rawLineData.toString(),ex.toString()};
          errored=synchronizeErrorInfo(lineList.lineNumber,info);
          continue;
        }
        if (table.getRowCount() > config.batch) {
          try {
            batchList.add(lineList);
            PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this);
            if (!isMP) {
              csvClient.callProcedure(cbmt,procName,partitionParam,tableName,table);
            }
 else {
              csvClient.callProcedure(cbmt,procName,tableName,table);
            }
            partitionProcessedCount+=table.getRowCount();
            table.clearRowData();
            batchList.clear();
            batchList=new ArrayList<CSVLineWithMetaData>();
          }
 catch (          IOException ex) {
            table.clearRowData();
            String[] info={lineList.rawLineData.toString(),ex.toString()};
            errored=synchronizeErrorInfo(lineList.lineNumber,info);
            break;
          }
        }
      }
 else {
        try {
          batchList.add(lineList);
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this);
          csvClient.callProcedure(cbmt,procName,(Object[])lineList.line);
          partitionProcessedCount++;
          batchList=new ArrayList<CSVLineWithMetaData>();
        }
 catch (        IOException ex) {
          String[] info={lineList.rawLineData.toString(),ex.toString()};
          errored=synchronizeErrorInfo(lineList.lineNumber,info);
          break;
        }
      }
    }
    if (end) {
      break;
    }
  }
  try {
    csvClient.drain();
  }
 catch (  NoConnectionsException ex) {
    m_log.warn("Failed to Drain the client: ",ex);
  }
catch (  InterruptedException ex) {
    m_log.warn("Failed to Drain the client: ",ex);
  }
  CSVPartitionProcessor.pcount.countDown();
  m_log.info("Done Processing partition: " + partitionId + " Processed: "+ partitionProcessedCount);
}
