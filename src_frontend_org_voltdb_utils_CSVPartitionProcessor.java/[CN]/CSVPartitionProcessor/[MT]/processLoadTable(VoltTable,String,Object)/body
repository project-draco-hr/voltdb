{
  List<CSVLineWithMetaData> batchList=new ArrayList<CSVLineWithMetaData>();
  NumberFormat nf=NumberFormat.getInstance();
  while (true) {
    if (m_errored) {
      CSVFileReader.m_errored=true;
      return;
    }
    List<CSVLineWithMetaData> mlineList=new ArrayList<CSVLineWithMetaData>();
    m_partitionQueue.drainTo(mlineList,m_config.batch);
    for (    CSVLineWithMetaData lineList : mlineList) {
      if (lineList == m_endOfData) {
        if (table.getRowCount() > 0) {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this,failedQueue);
          try {
            if (!m_isMP) {
              m_csvClient.callProcedure(cbmt,procName,partitionParam,m_tableName,table);
            }
 else {
              m_csvClient.callProcedure(cbmt,procName,m_tableName,table);
            }
            m_partitionProcessedCount.addAndGet(table.getRowCount());
          }
 catch (          IOException ex) {
            String[] info={lineList.rawLine.toString(),ex.toString()};
            m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          }
        }
        return;
      }
      try {
        if (VoltTableUtil.addRowToVoltTableFromLine(table,lineList.correctedLine,m_columnTypes,nf)) {
          batchList.add(lineList);
        }
 else {
          String[] info={lineList.rawLine.toString(),"Missing or Invalid Data in Row."};
          m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          continue;
        }
      }
 catch (      Exception ex) {
        String[] info={lineList.rawLine.toString(),ex.toString()};
        m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
        continue;
      }
      if (table.getRowCount() >= m_config.batch) {
        try {
          PartitionProcedureCallback cbmt=new PartitionProcedureCallback(batchList,this,failedQueue);
          if (!m_isMP) {
            m_csvClient.callProcedure(cbmt,procName,partitionParam,m_tableName,table);
          }
 else {
            m_csvClient.callProcedure(cbmt,procName,m_tableName,table);
          }
          m_partitionProcessedCount.addAndGet(table.getRowCount());
          table.clearRowData();
        }
 catch (        IOException ex) {
          table.clearRowData();
          String[] info={lineList.rawLine.toString(),ex.toString()};
          m_errored=synchronizeErrorInfo(lineList.lineNumber,info);
          return;
        }
        batchList=new ArrayList<CSVLineWithMetaData>();
      }
    }
  }
}
