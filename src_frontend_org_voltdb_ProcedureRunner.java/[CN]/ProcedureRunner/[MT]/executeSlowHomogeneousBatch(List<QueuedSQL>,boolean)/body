{
  BatchState state=new BatchState(batch.size(),m_txnState,m_site.getCorrespondingSiteId(),finalTask);
  for (int i=0; i < batch.size(); ++i) {
    QueuedSQL queuedSQL=batch.get(i);
    assert(queuedSQL.stmt != null);
    int collectorOutputDepId=m_txnState.getNextDependencyId();
    state.m_depsToResume[i]=collectorOutputDepId;
    FastSerializer fs=new FastSerializer();
    try {
      queuedSQL.params.writeExternal(fs);
    }
 catch (    IOException e) {
      throw new RuntimeException("Error serializing parameters for SQL statement: " + queuedSQL.stmt.getText() + " with params: "+ queuedSQL.params.toJSONString(),e);
    }
    ByteBuffer params=fs.getBuffer();
    assert(params != null);
    state.addStatement(i,queuedSQL.stmt,params,m_site);
  }
  m_txnState.setupProcedureResume(finalTask,state.m_depsToResume);
  for (int i=0; i < state.m_depsForLocalTask.length; i++) {
    if (state.m_depsForLocalTask[i] < 0)     continue;
    state.m_localTask.addInputDepId(i,state.m_depsForLocalTask[i]);
  }
  m_txnState.createLocalFragmentWork(state.m_localTask,state.m_localFragsAreNonTransactional && finalTask);
  if (!state.m_distributedTask.isEmpty()) {
    m_txnState.createAllParticipatingFragmentWork(state.m_distributedTask);
  }
  Map<Integer,List<VoltTable>> mapResults=m_site.recursableRun(m_txnState);
  assert(mapResults != null);
  assert(state.m_depsToResume != null);
  assert(state.m_depsToResume.length == batch.size());
  for (int i=0; i < batch.size(); i++) {
    List<VoltTable> matchingTablesForId=mapResults.get(state.m_depsToResume[i]);
    assert(matchingTablesForId != null);
    assert(matchingTablesForId.size() == 1);
    state.m_results[i]=matchingTablesForId.get(0);
    final SQLStmt stmt=batch.get(i).stmt;
    boolean isReplicated;
    isReplicated=stmt.isReplicatedTableDML;
    if (isReplicated) {
      long newVal=state.m_results[i].asScalarLong() / m_site.getReplicatedDMLDivisor();
      state.m_results[i]=new VoltTable(new VoltTable.ColumnInfo("modified_tuples",VoltType.BIGINT));
      state.m_results[i].addRow(newVal);
    }
  }
  return state.m_results;
}
