{
  if (param == null || param == VoltType.NULL_STRING_OR_VARBINARY || param == VoltType.NULL_DECIMAL) {
    if (m_paramTypes[paramTypeIndex].isPrimitive()) {
      VoltType type=VoltType.typeFromClass(m_paramTypes[paramTypeIndex]);
switch (type) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case FLOAT:
        return type.getNullValue();
default :
    }
  }
  return null;
}
if (param instanceof SystemProcedureExecutionContext) {
  return param;
}
Class<?> pclass=param.getClass();
if ((m_paramTypes[paramTypeIndex] == String.class) && (pclass == byte[].class)) {
  String sparam=null;
  sparam=new String((byte[])param,"UTF-8");
  return sparam;
}
if ((m_paramTypes[paramTypeIndex] == byte[].class) && (pclass == String.class)) {
  return Encoder.hexDecode((String)param);
}
boolean slotIsArray=m_paramTypes[paramTypeIndex].isArray();
if (slotIsArray != pclass.isArray()) throw new Exception("Array / Scalar parameter mismatch");
if (slotIsArray) {
  Class<?> pSubCls=pclass.getComponentType();
  Class<?> sSubCls=m_paramTypes[paramTypeIndex].getComponentType();
  if (pSubCls == sSubCls) {
    return param;
  }
 else   if (Array.getLength(param) == 0) {
    return Array.newInstance(sSubCls,0);
  }
 else {
    throw new Exception("tryScalarMakeCompatible: Unable to match parameter array:" + sSubCls.getName() + " to provided "+ pSubCls.getName());
  }
}
final Class<?> slot=m_paramTypes[paramTypeIndex];
if ((slot == long.class) && (pclass == Long.class || pclass == Integer.class || pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == int.class) && (pclass == Integer.class || pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == short.class) && (pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == byte.class) && (pclass == Byte.class)) return param;
if ((slot == double.class) && (param instanceof Number)) return ((Number)param).doubleValue();
if ((slot == String.class) && (pclass == String.class)) return param;
if (slot == TimestampType.class) {
  if (pclass == Long.class)   return new TimestampType((Long)param);
  if (pclass == TimestampType.class)   return param;
  if (pclass == Date.class)   return new TimestampType((Date)param);
  if (pclass == String.class) {
    try {
      return new TimestampType((String)param);
    }
 catch (    IllegalArgumentException e) {
    }
  }
}
if (slot == BigDecimal.class) {
  if ((pclass == Long.class) || (pclass == Integer.class) || (pclass == Short.class)|| (pclass == Byte.class)) {
    BigInteger bi=new BigInteger(param.toString());
    BigDecimal bd=new BigDecimal(bi);
    bd=bd.setScale(VoltDecimalHelper.kDefaultScale,BigDecimal.ROUND_HALF_EVEN);
    return bd;
  }
  if (pclass == BigDecimal.class) {
    BigDecimal bd=(BigDecimal)param;
    bd=bd.setScale(VoltDecimalHelper.kDefaultScale,BigDecimal.ROUND_HALF_EVEN);
    return bd;
  }
  if (pclass == String.class) {
    BigDecimal bd=VoltDecimalHelper.deserializeBigDecimalFromString((String)param);
    return bd;
  }
}
if (slot == VoltTable.class && pclass == VoltTable.class) {
  return param;
}
if ((slot == int.class) && (pclass == Long.class)) {
  long val=((Number)param).longValue();
  if ((val <= Integer.MAX_VALUE) && (val >= Integer.MIN_VALUE) && (val != VoltType.NULL_INTEGER))   return ((Number)param).intValue();
}
if ((slot == short.class) && (pclass == Long.class || pclass == Integer.class)) {
  long val=((Number)param).longValue();
  if ((val <= Short.MAX_VALUE) && (val >= Short.MIN_VALUE) && (val != VoltType.NULL_SMALLINT))   return ((Number)param).shortValue();
}
if ((slot == byte.class) && (pclass == Long.class || pclass == Integer.class || pclass == Short.class)) {
  long val=((Number)param).longValue();
  if ((val <= Byte.MAX_VALUE) && (val >= Byte.MIN_VALUE) && (val != VoltType.NULL_TINYINT))   return ((Number)param).byteValue();
}
throw new Exception("tryToMakeCompatible: Unable to match parameters or out of range for taget param: " + slot.getName() + " to provided "+ pclass.getName());
}
