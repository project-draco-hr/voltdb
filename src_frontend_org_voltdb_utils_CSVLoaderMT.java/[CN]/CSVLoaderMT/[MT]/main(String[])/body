{
  start=System.currentTimeMillis();
  long insertTimeStart=start;
  long insertTimeEnd;
  ClientStatsContext periodicStatsContext=null;
  Timer timer=null;
  CSVConfig cfg=new CSVConfig();
  cfg.parse(CSVLoaderMT.class.getName(),args);
  config=cfg;
  configuration();
  Tokenizer tokenizer=null;
  Map<String,ICsvListReader> readerMap=new HashMap<String,ICsvListReader>();
  try {
    long st=System.currentTimeMillis();
    if (CSVLoaderMT.standin) {
      tokenizer=new Tokenizer(new BufferedReader(new InputStreamReader(System.in)),csvPreference,config.strictquotes,config.escape,config.columnsizelimit,config.skip);
      ICsvListReader listReader=new CsvListReader(tokenizer,csvPreference);
      readerMap.put("stdin",listReader);
    }
 else {
      StringTokenizer tokens=new StringTokenizer(config.file,",");
      while (tokens.hasMoreTokens()) {
        String fname=tokens.nextToken();
        tokenizer=new Tokenizer(new FileReader(fname),csvPreference,config.strictquotes,config.escape,config.columnsizelimit,config.skip);
        ICsvListReader listReader=new CsvListReader(tokenizer,csvPreference);
        readerMap.put(fname,listReader);
      }
    }
  }
 catch (  FileNotFoundException e) {
    m_log.error("CSV file '" + config.file + "' could not be found.");
    System.exit(-1);
  }
  String[] serverlist=config.servers.split(",");
  ClientConfig c_config=new ClientConfig(config.user,config.password);
  c_config.setProcedureCallTimeout(0);
  Client csvClient=null;
  try {
    csvClient=CSVLoaderMT.getClient(c_config,serverlist,config.port);
  }
 catch (  Exception e) {
    m_log.error("Error to connect to the servers:" + config.servers);
    close_cleanup();
    System.exit(-1);
  }
  assert(csvClient != null);
  int partitionedColumnIndex=-1;
  try {
    int columnCnt=0;
    ProcedureCallback cb=null;
    VoltTable procInfo=null;
    boolean isProcExist=false;
    try {
      procInfo=csvClient.callProcedure("@SystemCatalog","PROCEDURECOLUMNS").getResults()[0];
      while (procInfo.advanceRow()) {
        if (insertProcedure.matches((String)procInfo.get("PROCEDURE_NAME",VoltType.STRING))) {
          columnCnt++;
          isProcExist=true;
          String typeStr=(String)procInfo.get("TYPE_NAME",VoltType.STRING);
          typeList.add(VoltType.typeFromString(typeStr));
        }
      }
    }
 catch (    Exception e) {
      m_log.error(e.getMessage(),e);
      close_cleanup();
      System.exit(-1);
    }
    if (isProcExist == false) {
      m_log.error("No matching insert procedure available");
      close_cleanup();
      System.exit(-1);
    }
    try {
      if (isProcedureMp(csvClient)) {
        m_log.warn("Using a multi-partitioned procedure to load data will be slow. " + "If loading a partitioned table, use a single-partitioned procedure " + "for best performance.");
      }
    }
 catch (    Exception e) {
      m_log.fatal(e.getMessage(),e);
      close_cleanup();
      System.exit(-1);
    }
    ArrayList<VoltType> columnTypes=new ArrayList<VoltType>();
    ArrayList<String> colNames=new ArrayList<String>();
    procInfo=csvClient.callProcedure("@SystemCatalog","COLUMNS").getResults()[0];
    while (procInfo.advanceRow()) {
      String table=procInfo.getString("TABLE_NAME");
      if (config.table.equalsIgnoreCase(table)) {
        columnTypes.add(VoltType.typeFromString(procInfo.getString("TYPE_NAME")));
        colNames.add(procInfo.getString("COLUMN_NAME"));
        String remarks=procInfo.getString("REMARKS");
        if (remarks != null && remarks.equalsIgnoreCase("PARTITION_COLUMN")) {
          partitionedColumnIndex=(int)procInfo.getLong("ORDINAL_POSITION");
        }
      }
    }
    VoltTable.ColumnInfo colInfo[]=new VoltTable.ColumnInfo[columnTypes.size()];
    for (int i=0; i < columnTypes.size(); i++) {
      VoltType type=columnTypes.get(i);
      String cname=colNames.get(i);
      VoltTable.ColumnInfo ci=new VoltTable.ColumnInfo(cname,type);
      colInfo[i]=ci;
    }
    int numPartitions=-1;
    int sitesPerHost=1;
    int kfactor=0;
    int hostcount=1;
    procInfo=csvClient.callProcedure("@SystemInformation","deployment").getResults()[0];
    while (procInfo.advanceRow()) {
      String prop=procInfo.getString("PROPERTY");
      if (prop != null && prop.equalsIgnoreCase("sitesperhost")) {
        sitesPerHost=Integer.parseInt(procInfo.getString("VALUE"));
      }
      if (prop != null && prop.equalsIgnoreCase("hostcount")) {
        hostcount=Integer.parseInt(procInfo.getString("VALUE"));
      }
      if (prop != null && prop.equalsIgnoreCase("kfactor")) {
        kfactor=Integer.parseInt(procInfo.getString("VALUE"));
      }
    }
    numPartitions=(hostcount * sitesPerHost) / (kfactor + 1);
    if (partitionedColumnIndex != -1 && numPartitions == -1) {
      System.out.println("Could not figure out number of partitions...exiting..");
      System.exit(-1);
    }
    System.out.println("Number of Partitions: " + numPartitions);
    System.out.println("Batch Size is: " + config.batch);
    TheHashinator.initialize(LegacyHashinator.class,LegacyHashinator.getConfigureBytes(numPartitions));
    CSVPartitionProcessor.colInfo=colInfo;
    CSVPartitionProcessor.columnTypes=columnTypes;
    CSVPartitionProcessor.insertProcedure=insertProcedure;
    CSVPartitionProcessor.isMP=(partitionedColumnIndex == -1 ? true : false);
    CSVPartitionProcessor.isLoadTable=config.loadTable;
    CSVPartitionProcessor.config=config;
    List<Thread> rthreads=new ArrayList<Thread>();
    List<CSVFileReader> readers=new ArrayList<CSVFileReader>();
    int tnum=0;
    for (    String readerFile : readerMap.keySet()) {
      CSVFileReader rdr=new CSVFileReader();
      readers.add(rdr);
      Map<Integer,BlockingQueue<CSVLineWithMetaData>> lineq=new HashMap<Integer,BlockingQueue<CSVLineWithMetaData>>();
      rdr.config=config;
      rdr.columnCnt=columnCnt;
      rdr.lineq=lineq;
      rdr.listReader=readerMap.get(readerFile);
      rdr.fileName=readerFile;
      rdr.csvClient=csvClient;
      rdr.partitionedColumnIndex=partitionedColumnIndex;
      rdr.tableName=config.table;
      rdr.typeList=typeList;
      List<Thread> spawned=new ArrayList<Thread>();
      CSVLineWithMetaData dummy=new CSVLineWithMetaData();
      rdr.dummy=dummy;
      rdr.spawned=spawned;
      Thread th=new Thread(rdr);
      th.setName("CSVReader-" + tnum++);
      th.setDaemon(true);
      rthreads.add(th);
      th.start();
    }
    for (    Thread th : rthreads) {
      th.join();
    }
    long readerTime=0;
    for (    CSVFileReader rdr : readers) {
      readerTime+=(rdr.parsingTimeEnd - rdr.parsingTimeSt);
    }
    readerTime=readerTime / 1000000;
    m_log.info("Parsing CSV file took " + readerTime + " milliseconds.");
    for (    CSVFileReader rdr : readers) {
      for (      Thread th2 : rdr.spawned) {
        try {
          th2.join();
        }
 catch (        InterruptedException ex) {
        }
      }
    }
    insertTimeEnd=System.currentTimeMillis();
    m_log.info("Inserting Data took " + ((insertTimeEnd - insertTimeStart) - readerTime) + " milliseconds.");
    produceFiles();
    close_cleanup();
    if (timer != null) {
      timer.cancel();
      printStatistics(periodicStatsContext,start);
    }
    csvClient.drain();
    csvClient.close();
    m_log.info("Inserted " + CSVFileReader.inCount.get() + " and acknowledged "+ CSVFileReader.outCount.get()+ " rows (final)");
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    if (timer != null) {
      timer.cancel();
    }
  }
}
