def _determine_partitioning(self):
    max_row_count = max((table.row_count for table in self.iter_tables()))
    for table in self.iter_tables():
        if (((table.row_count * 100) / G.partitioning_row_count_percent) >= max_row_count):
            if table.primary_key_columns:
                pkey_column_name = table.primary_key_columns[0].name
                if (table.row_count == max_row_count):
                    reason_chosen = ('%s has the maximum row count of %d' % (table.name, max_row_count))
                else:
                    reason_chosen = ('%s row count (%d) is within %d%% of the maximum.' % (table.name, table.row_count, G.partitioning_row_count_percent))
                ptable = PartitionedTable(table, pkey_column_name, reason_chosen)
                self.partitioned_tables[table.name] = ptable
    for table in self.iter_tables():
        if (table.name not in self.partitioned_tables):
            for fk_name in table.schema.foreign_keys:
                fk = table.schema.foreign_keys[fk_name]
                if (fk.referenced_table_name in self.partitioned_tables):
                    ptable = self.partitioned_tables[fk.referenced_table_name]
                    pkey = None
                    for icolumn in range(len(fk.columns)):
                        if (fk.referenced_columns[i].name == ptable.pkey_column_name):
                            pkey_column_name = fk.columns[i].name
                            reason_chosen = ('%s references partitioned table %s through a foreign key that references the partition key' % (table.name, ptable.name))
                            ptable = PartitionedTable(table, pkey_column_name, reason_chosen)
                            self.partitioned_tables[table.name] = ptable
                            break
