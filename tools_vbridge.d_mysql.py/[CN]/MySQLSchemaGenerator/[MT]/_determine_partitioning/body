def _determine_partitioning(self):
    max_row_count = 0
    biggest_table = None
    for table in self.iter_tables():
        if (table.row_count > max_row_count):
            max_row_count = table.row_count
            biggest_table = table
    if (not biggest_table):
        utility.abort('No table has rows. The database must be populated')
    pkey_column_name = biggest_table.primary_key_columns[0].name
    reason_chosen = ('%s has the largest row count of %d.' % (biggest_table.name, max_row_count))
    biggest_ptable = PartitionedTable(biggest_table, pkey_column_name, reason_chosen)
    self.partitioned_tables[biggest_table.name] = biggest_ptable
    for table in self.iter_tables():
        if (table.name == biggest_table.name):
            continue
        for fk_name in table.schema.foreign_keys:
            fk = table.schema.foreign_keys[fk_name]
            if (fk.referenced_table_name != biggest_table.name):
                continue
            for icolumn in range(len(fk.columns)):
                print table.name, fk.referenced_columns[i], biggest_ptable.pkey_column_name
                if (fk.referenced_columns[i] == biggest_ptable.pkey_column_name):
                    pkey_column_name = fk.columns[i]
                    reason_chosen = ('%s references partitioned table %s through a foreign key that references the partition key' % (table.name, biggest_ptable.name))
                    fk_ptable = PartitionedTable(table, pkey_column_name, reason_chosen)
                    self.partitioned_tables[table.name] = fk_ptable
                    break
