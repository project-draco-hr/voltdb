{
  final LocalObjectMessage wrapper=(LocalObjectMessage)message;
  if (wrapper.payload instanceof AdHocPlannerWork) {
    final AdHocPlannerWork w=(AdHocPlannerWork)(wrapper.payload);
    Boolean hasDDL=null;
    for (    String stmt : w.sqlStatements) {
      String ddlToken=SQLLexer.extractDDLToken(stmt);
      if (hasDDL == null) {
        hasDDL=(ddlToken != null) ? true : false;
      }
 else       if ((hasDDL && ddlToken == null) || (!hasDDL && ddlToken != null)) {
        AsyncCompilerResult errResult=AsyncCompilerResult.makeErrorResult(w,"DDL mixed with DML and queries is unsupported.");
        w.completionHandler.onCompletion(errResult);
        return;
      }
      if (hasDDL && !SQLLexer.isPermitted(stmt)) {
        AsyncCompilerResult errResult=AsyncCompilerResult.makeErrorResult(w,"AdHoc DDL contains an unsupported DDL statement: " + stmt);
        w.completionHandler.onCompletion(errResult);
        return;
      }
    }
    if (!hasDDL) {
      final AsyncCompilerResult result=compileAdHocPlan(w);
      w.completionHandler.onCompletion(result);
    }
 else {
      final CatalogChangeWork ccw=new CatalogChangeWork(w);
      dispatchCatalogChangeWork(ccw);
    }
  }
 else   if (wrapper.payload instanceof CatalogChangeWork) {
    final CatalogChangeWork w=(CatalogChangeWork)(wrapper.payload);
    dispatchCatalogChangeWork(w);
  }
 else {
    hostLog.warn("Unexpected message received by AsyncCompilerAgent.  " + "Please contact VoltDB support with this message and the contents: " + message.toString());
  }
}
