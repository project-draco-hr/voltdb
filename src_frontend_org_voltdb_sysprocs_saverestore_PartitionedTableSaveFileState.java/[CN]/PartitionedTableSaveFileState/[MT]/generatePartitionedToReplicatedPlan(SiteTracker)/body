{
  ArrayList<SynthesizedPlanFragment> restorePlan=new ArrayList<SynthesizedPlanFragment>();
  Set<Integer> coveredPartitions=new HashSet<Integer>();
  for (  Integer host : m_partitionsAtHost.keySet()) {
    List<Integer> loadPartitions=new ArrayList<Integer>();
    List<Integer> loadOrigHosts=new ArrayList<Integer>();
    Set<Pair<Integer,Integer>> partitionAndOrigHostSet=m_partitionsAtHost.get(host);
    Iterator<Pair<Integer,Integer>> itr=partitionAndOrigHostSet.iterator();
    while (itr.hasNext()) {
      Pair<Integer,Integer> pair=itr.next();
      if (!coveredPartitions.contains(pair.getFirst())) {
        loadPartitions.add(pair.getFirst());
        loadOrigHosts.add(pair.getSecond());
        coveredPartitions.add(pair.getFirst());
      }
    }
    if (loadPartitions.size() > 0) {
      int[] relevantPartitionIds=new int[loadPartitions.size()];
      int[] originalHosts=new int[loadOrigHosts.size()];
      List<Long> sitesAtHost=st.getSitesForHost(host);
      int index=0;
      for (      Integer p : loadPartitions) {
        relevantPartitionIds[index++]=p;
      }
      index=0;
      for (      Integer h : loadOrigHosts) {
        originalHosts[index++]=h;
      }
      for (      Long site : sitesAtHost) {
        restorePlan.add(constructLoadPartitionedTableFragment(site,relevantPartitionIds,originalHosts));
      }
    }
  }
  restorePlan.add(constructLoadPartitionedTableAggregatorFragment());
  assert(coveredPartitions.size() == m_partitionsSeen.size());
  return restorePlan.toArray(new SynthesizedPlanFragment[0]);
}
