{
  if (joinOrder.length < 2)   return false;
  List<AbstractExpression> expressions=new ArrayList<AbstractExpression>();
  for (int i=0; i < accessPath.length; ++i) {
    expressions.addAll(accessPath[i].joinExprs);
    expressions.addAll(accessPath[i].indexExprs);
  }
  if (expressions.size() != joinOrder.length - 1)   return false;
  Map<String,String> partitionMap=new HashMap<String,String>();
  for (  Table t : joinOrder) {
    if (!t.getIsreplicated()) {
      Column partition=t.getPartitioncolumn();
      assert(partition != null);
      partitionMap.put(t.getTypeName(),partition.getTypeName());
    }
 else     partitionMap.put(t.getTypeName(),null);
  }
  boolean joinOnPartition=true;
  Set<String> seenTables=new HashSet<String>();
  for (  AbstractExpression expr : expressions) {
    if (expr.getExpressionType() != ExpressionType.COMPARE_EQUAL) {
      joinOnPartition=false;
      break;
    }
    AbstractExpression[] subs=new AbstractExpression[2];
    subs[0]=expr.getLeft();
    subs[1]=expr.getRight();
    for (    AbstractExpression sub : subs) {
      if (sub == null || !(sub instanceof TupleValueExpression)) {
        joinOnPartition=false;
        break;
      }
      TupleValueExpression tve=(TupleValueExpression)sub;
      assert(partitionMap.containsKey(tve.getTableName()));
      String c=partitionMap.get(tve.getTableName());
      if (c != null && !tve.getColumnName().equals(c)) {
        joinOnPartition=false;
        break;
      }
      seenTables.add(tve.getTableName());
    }
    if (!joinOnPartition)     break;
  }
  if (seenTables.size() != joinOrder.length)   joinOnPartition=false;
  return joinOnPartition;
}
