{
  final List<Table> tables=SnapshotUtil.getTablesToSave(catalogDatabase);
  final Set<String> tableNamesToInclude=new HashSet<String>();
  final Set<String> tableNamesToExclude=new HashSet<>();
  if (jsData != null) {
    JSONArray tableNames=jsData.optJSONArray("tables");
    if (tableNames != null) {
      for (int i=0; i < tableNames.length(); i++) {
        try {
          final String s=tableNames.getString(i).trim().toUpperCase();
          if (!s.isEmpty()) {
            tableNamesToInclude.add(s);
          }
        }
 catch (        JSONException e) {
          SNAP_LOG.warn("Unable to parse tables to include for snapshot",e);
        }
      }
    }
    JSONArray excludeTableNames=jsData.optJSONArray("skiptables");
    if (excludeTableNames != null) {
      for (int i=0; i < excludeTableNames.length(); i++) {
        try {
          final String s=excludeTableNames.getString(i).trim().toUpperCase();
          if (!s.isEmpty()) {
            tableNamesToExclude.add(s);
          }
        }
 catch (        JSONException e) {
          SNAP_LOG.warn("Unable to parse tables to exclude for snapshot",e);
        }
      }
    }
  }
  if (!tableNamesToInclude.isEmpty() || !tableNamesToExclude.isEmpty()) {
    ListIterator<Table> iter=tables.listIterator();
    while (iter.hasNext()) {
      Table table=iter.next();
      if ((!tableNamesToInclude.isEmpty() && !tableNamesToInclude.contains(table.getTypeName())) || tableNamesToExclude.contains(table.getTypeName())) {
        iter.remove();
      }
    }
  }
  return tables.toArray(new Table[0]);
}
