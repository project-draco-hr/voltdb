{
  String node;
  if ((node=stmtNode.attributes.get("distinct")) != null)   m_distinct=Boolean.parseBoolean(node);
  VoltXMLElement limitElement=null, offsetElement=null, havingElement=null;
  VoltXMLElement displayElement=null, orderbyElement=null, groupbyElement=null;
  for (  VoltXMLElement child : stmtNode.children) {
    if (child.name.equalsIgnoreCase("limit")) {
      limitElement=child;
    }
 else     if (child.name.equalsIgnoreCase("offset")) {
      offsetElement=child;
    }
 else     if (child.name.equalsIgnoreCase("columns")) {
      displayElement=child;
    }
 else     if (child.name.equalsIgnoreCase("ordercolumns")) {
      orderbyElement=child;
    }
 else     if (child.name.equalsIgnoreCase("groupcolumns")) {
      groupbyElement=child;
    }
 else     if (child.name.equalsIgnoreCase("having")) {
      havingElement=child;
    }
  }
  parseLimitAndOffset(limitElement,offsetElement);
  if (m_aggregationList == null) {
    m_aggregationList=new ArrayList<AbstractExpression>();
  }
  assert(displayElement != null);
  parseDisplayColumns(displayElement,false);
  if (groupbyElement == null && havingElement == null && m_distinct) {
    groupbyElement=displayElement.duplicate();
    m_distinct=false;
  }
  if (groupbyElement != null) {
    parseGroupByColumns(groupbyElement);
    insertToColumnList(m_aggResultColumns,m_groupByColumns);
  }
  if (orderbyElement != null && !hasAOneRowResult()) {
    parseOrderColumns(orderbyElement,false);
  }
  if (havingElement != null) {
    parseHavingExpression(havingElement,false);
  }
  m_aggregationList=null;
  if (needComplexAggregation()) {
    fillUpAggResultColumns();
  }
 else {
    m_aggResultColumns=m_displayColumns;
  }
  placeTVEsinColumns();
  prepareLimitPlanNode();
  if (mayNeedAvgPushdown()) {
    processAvgPushdownOptimization(displayElement,orderbyElement,groupbyElement,havingElement);
  }
  prepareMVBasedQueryFix();
}
