{
  Map<AbstractExpression,Integer> aggTableIndexMap=new HashMap<AbstractExpression,Integer>();
  Map<Integer,ParsedColInfo> indexToColumnMap=new HashMap<Integer,ParsedColInfo>();
  int index=0;
  for (  ParsedColInfo col : m_aggResultColumns) {
    aggTableIndexMap.put(col.expression,index);
    if (col.alias == null) {
      col.alias="$$_" + col.expression.getExpressionType().symbol() + "_$$_"+ index;
    }
    indexToColumnMap.put(index,col);
    index++;
  }
  m_projectSchema=new NodeSchema();
  for (  ParsedColInfo col : m_displayColumns) {
    AbstractExpression expr=col.expression;
    if (hasComplexAgg()) {
      expr=col.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    }
    SchemaColumn schema_col=new SchemaColumn(col.tableName,col.tableAlias,col.columnName,col.alias,expr);
    m_projectSchema.addColumn(schema_col);
  }
  for (  ParsedColInfo orderCol : m_orderColumns) {
    AbstractExpression expr=orderCol.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    if (hasComplexAgg()) {
      orderCol.expression=expr;
    }
 else {
      if (orderCol.expression.hasAnySubexpressionOfClass(AggregateExpression.class) || hasComplexGroupby()) {
        orderCol.expression=expr;
      }
    }
  }
  m_groupByExpressions=new HashMap<String,AbstractExpression>();
  for (  ParsedColInfo groupbyCol : m_groupByColumns) {
    assert(aggTableIndexMap.get(groupbyCol.expression) != null);
    assert(m_groupByExpressions.get(groupbyCol.alias) == null);
    AbstractExpression expr=groupbyCol.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    m_groupByExpressions.put(groupbyCol.alias,expr);
  }
  if (m_having != null) {
    m_having=m_having.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    ExpressionUtil.finalizeValueTypes(m_having);
  }
}
