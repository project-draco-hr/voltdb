{
  Map<AbstractExpression,Integer> aggTableIndexMap=new HashMap<AbstractExpression,Integer>();
  Map<Integer,ParsedColInfo> indexToColumnMap=new HashMap<Integer,ParsedColInfo>();
  int index=0;
  for (  ParsedColInfo col : m_aggResultColumns) {
    aggTableIndexMap.put(col.expression,index);
    if (col.alias == null) {
      col.alias="$$_" + col.expression.getExpressionType().symbol() + "_$$_"+ index;
    }
    indexToColumnMap.put(index,col);
    index++;
  }
  if (m_projectSchema == null) {
    m_projectSchema=new NodeSchema();
    for (    ParsedColInfo col : m_displayColumns) {
      AbstractExpression expr=col.expression;
      if (hasComplexAgg()) {
        expr=col.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
      }
      SchemaColumn schema_col=new SchemaColumn(col.tableName,col.tableAlias,col.columnName,col.alias,expr);
      m_projectSchema.addColumn(schema_col);
    }
  }
  for (  ParsedColInfo orderCol : m_orderColumns) {
    AbstractExpression expr=orderCol.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    if (hasComplexAgg()) {
      orderCol.expression=expr;
    }
 else {
      if (orderCol.expression.hasAnySubexpressionOfClass(AggregateExpression.class) || hasComplexGroupby()) {
        orderCol.expression=expr;
      }
    }
  }
  m_groupByExpressions=new HashMap<String,AbstractExpression>();
  for (  ParsedColInfo groupbyCol : m_groupByColumns) {
    assert(aggTableIndexMap.get(groupbyCol.expression) != null);
    assert(m_groupByExpressions.get(groupbyCol.alias) == null);
    AbstractExpression expr=groupbyCol.expression.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    m_groupByExpressions.put(groupbyCol.alias,expr);
  }
  if (m_having != null) {
    m_having=m_having.replaceWithTVE(aggTableIndexMap,indexToColumnMap);
    ExpressionUtil.finalizeValueTypes(m_having);
  }
}
