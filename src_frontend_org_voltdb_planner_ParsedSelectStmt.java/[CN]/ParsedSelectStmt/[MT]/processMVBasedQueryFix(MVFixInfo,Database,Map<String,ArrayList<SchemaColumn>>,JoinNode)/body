{
  String mvTableName=mvFixInfo.mvTable.getTypeName();
  Table srcTable=mvFixInfo.mvTable.getMaterializer();
  if (srcTable == null) {
    return;
  }
  Column partitionCol=srcTable.getPartitioncolumn();
  if (partitionCol == null) {
    return;
  }
  String partitionColName=partitionCol.getName();
  MaterializedViewInfo mvInfo=srcTable.getViews().get(mvTableName);
  boolean partitionColInGroupbyCols=false;
  int numOfGroupByColumns;
  String complexGroupbyJson=mvInfo.getGroupbyexpressionsjson();
  if (complexGroupbyJson.length() > 0) {
    List<AbstractExpression> mvComplexGroupbyCols=null;
    try {
      mvComplexGroupbyCols=AbstractExpression.fromJSONArrayString(complexGroupbyJson,db);
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
    numOfGroupByColumns=mvComplexGroupbyCols.size();
    for (    AbstractExpression expr : mvComplexGroupbyCols) {
      if (expr instanceof TupleValueExpression) {
        TupleValueExpression tve=(TupleValueExpression)expr;
        if (tve.getColumnName().equals(partitionColName)) {
          partitionColInGroupbyCols=true;
          break;
        }
      }
    }
  }
 else {
    CatalogMap<ColumnRef> mvSimpleGroupbyCols=mvInfo.getGroupbycols();
    numOfGroupByColumns=mvSimpleGroupbyCols.size();
    for (    ColumnRef colRef : mvSimpleGroupbyCols) {
      if (colRef.getColumn().getName().equals(partitionColName)) {
        partitionColInGroupbyCols=true;
        break;
      }
    }
  }
  if (partitionColInGroupbyCols) {
    return;
  }
  mvFixInfo.needed=true;
  Set<SchemaColumn> mvNewScanColumns=new HashSet<SchemaColumn>();
  Set<SchemaColumn> mvDDLGroupbyColumns=new HashSet<SchemaColumn>();
  Map<String,ExpressionType> mvColumnAggType=new HashMap<String,ExpressionType>();
  List<Column> mvColumnArray=CatalogUtil.getSortedCatalogItems(mvFixInfo.mvTable.getColumns(),"index");
  for (  Column mvCol : mvColumnArray) {
    ExpressionType reAggType=ExpressionType.get(mvCol.getAggregatetype());
    if (reAggType == ExpressionType.AGGREGATE_COUNT_STAR || reAggType == ExpressionType.AGGREGATE_COUNT) {
      reAggType=ExpressionType.AGGREGATE_SUM;
    }
    mvColumnAggType.put(mvCol.getName(),reAggType);
  }
  NodeSchema inlineProjSchema=new NodeSchema();
  assert(scanColumns.keySet().size() <= 1);
  if (scanColumns.keySet().size() == 1) {
    mvNewScanColumns.addAll(scanColumns.get(mvTableName));
  }
  for (  SchemaColumn scol : mvNewScanColumns) {
    inlineProjSchema.addColumn(scol);
  }
  assert(numOfGroupByColumns > 0);
  for (int i=0; i < numOfGroupByColumns; i++) {
    Column mvCol=mvColumnArray.get(i);
    TupleValueExpression tve=new TupleValueExpression();
    tve.setColumnIndex(i);
    tve.setColumnName(mvCol.getName());
    tve.setTableName(mvTableName);
    tve.setColumnAlias(mvCol.getName());
    tve.setValueType(VoltType.get((byte)mvCol.getType()));
    tve.setValueSize(mvCol.getSize());
    SchemaColumn scol=new SchemaColumn(mvTableName,mvCol.getName(),mvCol.getName(),tve);
    mvDDLGroupbyColumns.add(scol);
    if (!mvNewScanColumns.contains(scol)) {
      mvNewScanColumns.add(scol);
      inlineProjSchema.addColumn(scol);
    }
  }
  mvFixInfo.scanInlinedProjectionNode=new ProjectionPlanNode();
  mvFixInfo.scanInlinedProjectionNode.setOutputSchema(inlineProjSchema);
  mvFixInfo.reAggNode=new HashAggregatePlanNode();
  int outputColumnIndex=0;
  NodeSchema aggSchema=new NodeSchema();
  for (  SchemaColumn scol : mvNewScanColumns) {
    if (mvDDLGroupbyColumns.contains(scol)) {
      mvFixInfo.reAggNode.addGroupByExpression(scol.getExpression());
    }
 else {
      ExpressionType reAggType=mvColumnAggType.get(scol.getColumnName());
      assert(reAggType != null);
      AbstractExpression agg_input_expr=scol.getExpression();
      assert(agg_input_expr instanceof TupleValueExpression);
      mvFixInfo.reAggNode.addAggregate(reAggType,false,outputColumnIndex,agg_input_expr);
    }
    aggSchema.addColumn(scol);
    outputColumnIndex++;
  }
  mvFixInfo.reAggNode.setOutputSchema(aggSchema);
  assert(joinTree != null);
  AbstractExpression where=joinTree.getSimpleFilterExpression();
  if (where != null) {
    List<TupleValueExpression> needReAggTVEs=new ArrayList<TupleValueExpression>();
    for (int i=numOfGroupByColumns; i < mvColumnArray.size(); i++) {
      Column mvCol=mvColumnArray.get(i);
      TupleValueExpression tve=new TupleValueExpression();
      tve.setColumnIndex(i);
      tve.setColumnName(mvCol.getName());
      tve.setTableName(mvTableName);
      tve.setColumnAlias(mvCol.getName());
      tve.setValueType(VoltType.get((byte)mvCol.getType()));
      tve.setValueSize(mvCol.getSize());
      needReAggTVEs.add(tve);
    }
    List<AbstractExpression> exprs=ExpressionUtil.uncombine(where);
    List<AbstractExpression> pushdownExprs=new ArrayList<AbstractExpression>();
    List<AbstractExpression> aggPostExprs=new ArrayList<AbstractExpression>();
    for (    AbstractExpression expr : exprs) {
      ArrayList<AbstractExpression> tves=expr.findBaseTVEs();
      boolean pushdown=true;
      for (      TupleValueExpression needReAggTVE : needReAggTVEs) {
        if (tves.contains(needReAggTVE)) {
          pushdown=false;
          break;
        }
      }
      if (pushdown) {
        pushdownExprs.add(expr);
      }
 else {
        aggPostExprs.add(expr);
      }
    }
    AbstractExpression aggPostExpr=ExpressionUtil.combine(aggPostExprs);
    mvFixInfo.reAggNode.setPostPredicate(aggPostExpr);
    assert(joinTree.m_whereExpr == null);
    joinTree.m_joinExpr=ExpressionUtil.combine(pushdownExprs);
  }
}
