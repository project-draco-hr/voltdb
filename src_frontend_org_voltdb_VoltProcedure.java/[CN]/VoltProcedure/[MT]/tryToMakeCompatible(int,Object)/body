{
  if (param == null || param == VoltType.NULL_STRING || param == VoltType.NULL_DECIMAL) {
    if (paramTypeIsPrimitive[paramTypeIndex]) {
      VoltType type=VoltType.typeFromClass(paramTypes[paramTypeIndex]);
switch (type) {
case TINYINT:
case SMALLINT:
case INTEGER:
case BIGINT:
case FLOAT:
        return type.getNullValue();
    }
  }
  return null;
}
if (param instanceof ExecutionSite.SystemProcedureExecutionContext) {
  return param;
}
Class<?> pclass=param.getClass();
boolean slotIsArray=paramTypeIsArray[paramTypeIndex];
if (slotIsArray != pclass.isArray()) throw new Exception("Array / Scalar parameter mismatch");
if (slotIsArray) {
  Class<?> pSubCls=pclass.getComponentType();
  Class<?> sSubCls=paramTypeComponentType[paramTypeIndex];
  if (pSubCls == sSubCls) {
    return param;
  }
 else   if (Array.getLength(param) == 0) {
    return Array.newInstance(sSubCls,0);
  }
 else {
    throw new Exception("tryScalarMakeCompatible: Unable to match parameter array:" + sSubCls.getName() + " to provided "+ pSubCls.getName());
  }
}
final Class<?> slot=paramTypes[paramTypeIndex];
if ((slot == long.class) && (pclass == Long.class || pclass == Integer.class || pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == int.class) && (pclass == Integer.class || pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == short.class) && (pclass == Short.class || pclass == Byte.class)) return param;
if ((slot == byte.class) && (pclass == Byte.class)) return param;
if ((slot == double.class) && (pclass == Double.class)) return param;
if ((slot == String.class) && (pclass == String.class)) return param;
if (slot == TimestampType.class) {
  if (pclass == Long.class)   return new TimestampType((Long)param);
  if (pclass == TimestampType.class)   return param;
}
if (slot == BigDecimal.class) {
  if (pclass == Long.class) {
    BigInteger bi=new BigInteger(param.toString());
    BigDecimal bd=new BigDecimal(bi);
    bd.setScale(4,BigDecimal.ROUND_HALF_EVEN);
    return bd;
  }
  if (pclass == BigDecimal.class) {
    BigDecimal bd=(BigDecimal)param;
    bd.setScale(4,BigDecimal.ROUND_HALF_EVEN);
    return bd;
  }
}
if (slot == VoltTable.class && pclass == VoltTable.class) {
  return param;
}
if ((slot == int.class) && (pclass == Long.class)) {
  long val=((Number)param).longValue();
  if (val == VoltType.NULL_BIGINT)   return VoltType.NULL_INTEGER;
  if ((val <= Integer.MAX_VALUE) && (val >= Integer.MIN_VALUE) && (val != VoltType.NULL_INTEGER))   return ((Number)param).intValue();
}
if ((slot == short.class) && (pclass == Long.class || pclass == Integer.class)) {
  long val=((Number)param).longValue();
  if ((pclass == Long.class) && (val == VoltType.NULL_BIGINT))   return VoltType.NULL_SMALLINT;
  if ((pclass == Integer.class) && (val == VoltType.NULL_INTEGER))   return VoltType.NULL_SMALLINT;
  if ((val <= Short.MAX_VALUE) && (val >= Short.MIN_VALUE) && (val != VoltType.NULL_SMALLINT))   return ((Number)param).shortValue();
}
if ((slot == byte.class) && (pclass == Long.class || pclass == Integer.class || pclass == Short.class)) {
  long val=((Number)param).longValue();
  if ((pclass == Long.class) && (val == VoltType.NULL_BIGINT))   return VoltType.NULL_TINYINT;
  if ((pclass == Integer.class) && (val == VoltType.NULL_INTEGER))   return VoltType.NULL_TINYINT;
  if ((pclass == Short.class) && (val == VoltType.NULL_SMALLINT))   return VoltType.NULL_TINYINT;
  if ((val <= Byte.MAX_VALUE) && (val >= Byte.MIN_VALUE) && (val != VoltType.NULL_TINYINT))   return ((Number)param).byteValue();
}
throw new Exception("tryToMakeCompatible: Unable to match parameters:" + slot.getName() + " to provided "+ pclass.getName());
}
