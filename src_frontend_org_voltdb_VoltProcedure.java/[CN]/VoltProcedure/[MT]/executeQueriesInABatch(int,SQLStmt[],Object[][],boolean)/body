{
  assert(batchStmts != null);
  assert(batchArgs != null);
  assert(batchStmts.length > 0);
  assert(batchArgs.length > 0);
  if (stmtCount == 0)   return new VoltTable[]{};
  final int batchSize=stmtCount;
  int fragmentIdIndex=0;
  int parameterSetIndex=0;
  boolean slowPath=false;
  for (int i=0; i < batchSize; ++i) {
    final SQLStmt stmt=batchStmts[i];
    if (stmt.catStmt == null) {
      String msg="SQLStmt objects cannot be instantiated after";
      msg+=" VoltDB initialization. User may have instantiated a SQLStmt";
      msg+=" inside a stored procedure's run method.";
      throw new RuntimeException(msg);
    }
    slowPath=slowPath || !(stmt.catStmt.getSinglepartition());
    final Object[] args=batchArgs[i];
    final ParameterSet params=getCleanParams(stmt,args);
    final int numFrags=stmt.numFragGUIDs;
    final long fragGUIDs[]=stmt.fragGUIDs;
    for (int ii=0; ii < numFrags; ii++) {
      m_fragmentIds[fragmentIdIndex++]=fragGUIDs[ii];
      m_parameterSets[parameterSetIndex++]=params;
    }
  }
  if (slowPath) {
    if (batchSize == 1) {
      return slowPath(batchSize,batchStmts,batchArgs,finalTask);
    }
    boolean hasRead=false;
    boolean hasWrite=false;
    for (int i=0; i < batchSize; ++i) {
      final SQLStmt stmt=batchStmts[i];
      if (stmt.catStmt.getReadonly()) {
        hasRead=true;
      }
 else {
        hasWrite=true;
      }
    }
    if ((hasRead && !hasWrite) || (!hasRead && hasWrite)) {
      return slowPath(batchSize,batchStmts,batchArgs,finalTask);
    }
 else {
      return executeQueriesInIndividualBatches(batchSize,batchStmts,batchArgs,finalTask);
    }
  }
  VoltTable[] results=null;
  results=m_site.executeQueryPlanFragmentsAndGetResults(m_fragmentIds,fragmentIdIndex,m_parameterSets,parameterSetIndex,m_currentTxnState.txnId,m_catProc.getReadonly());
  return results;
}
