{
  VoltTable[] results=new VoltTable[batchSize];
  FastSerializer fs=new FastSerializer();
  int[] depsToResume=new int[batchSize];
  int[] depsForLocalTask=new int[batchSize];
  long[] localFragIds=new long[batchSize];
  ArrayList<Long> distributedFragIds=new ArrayList<Long>();
  ArrayList<Integer> distributedOutputDepIds=new ArrayList<Integer>();
  ByteBuffer[] localParams=new ByteBuffer[batchSize];
  ArrayList<ByteBuffer> distributedParams=new ArrayList<ByteBuffer>();
  boolean localFragsAreNonTransactional=true;
  for (int i=0; i < batchSize; ++i) {
    SQLStmt stmt=batchStmts[i];
    if (stmt.catStmt == null) {
      String msg="SQLStmt objects cannot be instantiated after";
      msg+=" VoltDB initialization. User may have instantiated a SQLStmt";
      msg+=" inside a stored procedure's run method.";
      throw new RuntimeException(msg);
    }
    int collectorOutputDepId=m_site.dtxnConn.getNextDependencyId();
    depsToResume[i]=collectorOutputDepId;
    ParameterSet paramSet=getCleanParams(stmt,batchArgs[i]);
    fs.clear();
    try {
      fs.writeObject(paramSet);
    }
 catch (    IOException e) {
      e.printStackTrace();
      assert(false);
    }
    ByteBuffer params=fs.getBuffer();
    assert(params != null);
    int numFrags=stmt.catStmt.getFragments().size();
    assert(numFrags > 0);
    assert(numFrags <= 2);
    if (numFrags == 1) {
      for (      PlanFragment frag : stmt.catStmt.getFragments()) {
        assert(frag != null);
        assert(frag.getHasdependencies() == false);
        localFragIds[i]=CatalogUtil.getUniqueIdForFragment(frag);
        localParams[i]=params;
        if (frag.getNontransactional() == false)         localFragsAreNonTransactional=true;
      }
      depsForLocalTask[i]=-1;
    }
 else {
      for (      PlanFragment frag : stmt.catStmt.getFragments()) {
        assert(frag != null);
        if (frag.getHasdependencies() == false) {
          distributedFragIds.add(CatalogUtil.getUniqueIdForFragment(frag));
          distributedParams.add(params);
        }
 else {
          localFragIds[i]=CatalogUtil.getUniqueIdForFragment(frag);
          localParams[i]=params;
          assert(frag.getHasdependencies());
          int outputDepId=m_site.dtxnConn.getNextDependencyId() | DtxnConstants.MULTIPARTITION_DEPENDENCY;
          depsForLocalTask[i]=outputDepId;
          distributedOutputDepIds.add(outputDepId);
          if (frag.getNontransactional() == false)           localFragsAreNonTransactional=true;
        }
      }
    }
  }
  long[] distributedFragIdArray=new long[distributedFragIds.size()];
  int[] distributedOutputDepIdArray=new int[distributedFragIds.size()];
  ByteBuffer[] distributedParamsArray=new ByteBuffer[distributedFragIds.size()];
  assert(distributedFragIds.size() == distributedParams.size());
  for (int i=0; i < distributedFragIds.size(); i++) {
    distributedFragIdArray[i]=distributedFragIds.get(i);
    distributedOutputDepIdArray[i]=distributedOutputDepIds.get(i);
    distributedParamsArray[i]=distributedParams.get(i);
  }
  m_site.dtxnConn.setupProcedureResume(finalTask,depsToResume);
  FragmentTask localTask=new FragmentTask(m_site.getCurrentInitiatorSiteId(),m_site.siteId,m_site.getCurrentTxnId(),m_site.getCurrentSPTask().isReadOnly(),localFragIds,depsToResume,localParams,false);
  for (int i=0; i < depsForLocalTask.length; i++) {
    if (depsForLocalTask[i] < 0)     continue;
    localTask.addInputDepId(i,depsForLocalTask[i]);
  }
  m_site.dtxnConn.createLocalWork(localTask,localFragsAreNonTransactional && finalTask);
  FragmentTask distributedTask=new FragmentTask(m_site.getCurrentInitiatorSiteId(),m_site.siteId,m_site.getCurrentTxnId(),m_site.getCurrentSPTask().isReadOnly(),distributedFragIdArray,distributedOutputDepIdArray,distributedParamsArray,finalTask);
  m_site.dtxnConn.createAllParticipatingWork(distributedTask);
  Map<Integer,List<VoltTable>> mapResults=m_site.dtxnConn.recursableRun(false);
  assert(mapResults != null);
  assert(depsToResume != null);
  assert(depsToResume.length == batchSize);
  for (int i=0; i < batchSize; i++) {
    List<VoltTable> matchingTablesForId=mapResults.get(depsToResume[i]);
    assert(matchingTablesForId != null);
    assert(matchingTablesForId.size() == 1);
    results[i]=matchingTablesForId.get(0);
    if (batchStmts[i].catStmt.getReplicatedtabledml()) {
      long newVal=results[i].asScalarLong() / VoltDB.instance().getNumberOfPartitions();
      results[i]=new VoltTable(new VoltTable.ColumnInfo("",VoltType.BIGINT));
      results[i].addRow(newVal);
    }
  }
  return results;
}
