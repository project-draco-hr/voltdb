{
  m_iv2appointees.start(true);
  m_iv2masters.start(true);
  if (m_iv2appointees.pointInTimeCache().size() == 0) {
    tmLog.debug("LeaderAppointer in startup");
    m_state.set(AppointerState.CLUSTER_START);
  }
 else   if (m_state.get() == AppointerState.INIT) {
    try {
      if ((m_iv2appointees.pointInTimeCache().size() != getInitialPartitionCount()) || (m_iv2masters.pointInTimeCache().size() != getInitialPartitionCount())) {
        VoltDB.crashGlobalVoltDB("Detected failure during startup, unable to start",false,null);
      }
    }
 catch (    IllegalAccessException e) {
      VoltDB.crashLocalVoltDB("Failed to get partition count",true,e);
    }
  }
 else {
    tmLog.debug("LeaderAppointer in repair");
    m_state.set(AppointerState.DONE);
  }
  if (m_state.get() == AppointerState.CLUSTER_START) {
    m_startupLatch=new CountDownLatch(1);
    writeKnownLiveNodes(m_hostMessenger.getLiveHostIds());
    try {
      final int initialPartitionCount=getInitialPartitionCount();
      for (int i=0; i < initialPartitionCount; i++) {
        LeaderElector.createRootIfNotExist(m_zk,LeaderElector.electionDirForPartition(i));
        watchPartition(i,m_es,true);
      }
    }
 catch (    IllegalAccessException e) {
      VoltDB.crashLocalVoltDB("Failed to get partition count on startup",true,e);
    }
    m_startupLatch.await();
    m_zk.getChildren(VoltZK.leaders_initiators,m_partitionCallback);
  }
 else {
    Map<Integer,Long> masters=m_iv2masters.pointInTimeCache();
    tmLog.info("LeaderAppointer repairing with master set: " + masters);
    for (    Entry<Integer,Long> master : masters.entrySet()) {
      int partId=master.getKey();
      String dir=LeaderElector.electionDirForPartition(partId);
      m_callbacks.put(partId,new PartitionCallback(partId,master.getValue()));
      Pair<BabySitter,List<String>> sitterstuff=BabySitter.blockingFactory(m_zk,dir,m_callbacks.get(partId),m_es);
      m_partitionWatchers.put(partId,sitterstuff.getFirst());
    }
    m_MPI.acceptPromotion();
  }
}
