{
  List<Integer> currentNodes=null;
  try {
    currentNodes=m_hostMessenger.getLiveHostIds();
  }
 catch (  Exception e) {
  }
  Set<Integer> currentHosts=new HashSet<Integer>(currentNodes);
  Set<Integer> previousHosts=readPriorKnownLiveNodes();
  int blessedHostId=Integer.MAX_VALUE;
  boolean blessedHostIdInFailedSet=true;
  for (  Integer hostId : previousHosts) {
    if (hostId < blessedHostId) {
      blessedHostId=hostId;
    }
  }
  for (  Integer hostId : currentHosts) {
    if (hostId.equals(blessedHostId)) {
      blessedHostId=hostId;
      blessedHostIdInFailedSet=false;
    }
  }
  boolean partitionDetectionTriggered=false;
  if (currentHosts.size() * 2 == previousHosts.size()) {
    if (blessedHostIdInFailedSet) {
      tmLog.info("Partition detection triggered for 50/50 cluster failure. " + "This survivor set is shutting down.");
      partitionDetectionTriggered=true;
    }
 else {
      tmLog.info("Partition detected for 50/50 failure. " + "This survivor set is continuing execution.");
    }
  }
  if (currentHosts.size() * 2 < previousHosts.size()) {
    tmLog.info("Partition detection triggered. " + "This minority survivor set is shutting down.");
    partitionDetectionTriggered=true;
  }
  if (partitionDetectionTriggered && !m_partitionSnapshotRequested) {
    SnapshotUtil.requestSnapshot(0L,m_partSnapshotSchedule.getPath(),m_partSnapshotSchedule.getPrefix(),true,SnapshotFormat.NATIVE,null,m_snapshotHandler,true);
    m_partitionSnapshotRequested=true;
  }
  if (!currentHosts.equals(previousHosts)) {
    writeKnownLiveNodes(currentNodes);
  }
}
