{
  assert(m_children.size() == 1);
  m_children.get(0).resolveColumnIndexes();
  NodeSchema input_schema=m_children.get(0).getOutputSchema();
  assert(input_schema.equals(m_outputSchemaPreInlineAgg));
  for (  SchemaColumn col : m_outputSchemaPreInlineAgg.getColumns()) {
    assert(col.getExpression() instanceof TupleValueExpression);
    TupleValueExpression tve=(TupleValueExpression)col.getExpression();
    int index=tve.resolveColumnIndexesUsingSchema(input_schema);
    tve.setColumnIndex(index);
  }
  m_outputSchemaPreInlineAgg.sortByTveIndex();
  if (m_mergeReceive) {
    AbstractPlanNode orderNode=getInlinePlanNode(PlanNodeType.ORDERBY);
    assert(orderNode != null && orderNode instanceof OrderByPlanNode);
    OrderByPlanNode opn=(OrderByPlanNode)orderNode;
    opn.resolveSortIndexesUsingSchema(m_outputSchemaPreInlineAgg);
    AggregatePlanNode aggrNode=AggregatePlanNode.getInlineAggregationNode(this);
    if (aggrNode != null) {
      aggrNode.resolveColumnIndexesUsingSchema(m_outputSchemaPreInlineAgg);
      m_outputSchema=aggrNode.getOutputSchema().clone();
      m_outputSchema.sortByTveIndex();
    }
 else {
      m_outputSchema=m_outputSchemaPreInlineAgg;
    }
  }
 else {
    m_outputSchema=m_outputSchemaPreInlineAgg;
  }
}
