{
  assert(planFragmentIds.length == parameterSets.length);
  if (numFragmentIds == 0)   return new VoltTable[0];
  final int batchSize=numFragmentIds;
  if (LOG.isTraceEnabled()) {
    for (int i=0; i < batchSize; ++i) {
      LOG.trace("Batch Executing planfragment:" + planFragmentIds[i] + ", params="+ parameterSets[i].toString());
    }
  }
  fsForParameterSet.clear();
  try {
    for (int i=0; i < batchSize; ++i) {
      parameterSets[i].writeExternal(fsForParameterSet);
    }
  }
 catch (  final IOException exception) {
    throw new RuntimeException(exception);
  }
  deserializer.clear();
  final int errorCode=nativeExecuteQueryPlanFragmentsAndGetResults(pointer,planFragmentIds,numFragmentIds,txnId,lastCommittedTxnId,undoToken);
  checkErrorCode(errorCode);
  try {
    final int totalSize=deserializer.readInt();
    final boolean dirty=deserializer.readBoolean();
    if (dirty)     m_dirty=true;
    final ByteBuffer fullBacking=deserializer.readBuffer(totalSize);
    final VoltTable[] results=new VoltTable[batchSize];
    for (int i=0; i < batchSize; ++i) {
      final int numdeps=fullBacking.getInt();
      assert(numdeps == 1);
      @SuppressWarnings("unused") final int depid=fullBacking.getInt();
      final int tableSize=fullBacking.getInt();
      assert(tableSize < 10000000);
      final ByteBuffer tableBacking=fullBacking.slice();
      fullBacking.position(fullBacking.position() + tableSize);
      tableBacking.limit(tableSize);
      results[i]=new VoltTable(tableBacking,true);
    }
    return results;
  }
 catch (  final IOException ex) {
    LOG.error("Failed to deserialze result table" + ex);
    throw new EEException(ERRORCODE_WRONG_SERIALIZED_BYTES);
  }
}
