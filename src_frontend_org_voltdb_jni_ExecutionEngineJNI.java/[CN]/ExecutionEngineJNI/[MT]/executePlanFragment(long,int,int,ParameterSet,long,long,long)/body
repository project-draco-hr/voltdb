{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Executing planfragment:" + planFragmentId + ", params="+ parameterSet.toString());
  }
  fsForParameterSet.clear();
  try {
    parameterSet.writeExternal(fsForParameterSet);
  }
 catch (  final IOException exception) {
    throw new RuntimeException(exception);
  }
  deserializer.clear();
  final int errorCode=nativeExecutePlanFragment(pointer,planFragmentId,outputDepId,inputDepId,txnId,lastCommittedTxnId,undoToken);
  checkErrorCode(errorCode);
  try {
    deserializer.readInt();
    final boolean dirty=deserializer.readBoolean();
    if (dirty)     m_dirty=true;
    final int numDependencies=deserializer.readInt();
    final VoltTable dependencies[]=new VoltTable[numDependencies];
    final int depIds[]=new int[numDependencies];
    for (int i=0; i < numDependencies; ++i) {
      depIds[i]=deserializer.readInt();
      dependencies[i]=deserializer.readObject(VoltTable.class);
    }
    assert(depIds.length == 1);
    return new DependencyPair(depIds[0],dependencies[0]);
  }
 catch (  final IOException ex) {
    LOG.error("Failed to deserialze result dependencies" + ex);
    throw new EEException(ERRORCODE_WRONG_SERIALIZED_BYTES);
  }
}
