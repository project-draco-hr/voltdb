{
  assert((numFragmentIds == 0) || (planFragmentIds[0] != 0));
  if (numFragmentIds == 0)   return new VoltTable[0];
  final int batchSize=numFragmentIds;
  if (LOG.isTraceEnabled()) {
    for (int i=0; i < batchSize; ++i) {
      LOG.trace("Batch Executing planfragment:" + planFragmentIds[i] + ", params="+ parameterSets[i].toString());
    }
  }
  fsForParameterSet.clear();
  for (int i=0; i < batchSize; ++i) {
    try {
      parameterSets[i].writeExternal(fsForParameterSet);
    }
 catch (    final IOException exception) {
      throw new RuntimeException("Error serializing parameters for SQL batch element: " + i + " with plan fragment ID: "+ planFragmentIds[i]+ " and with params: "+ parameterSets[i].toJSONString(),exception);
    }
  }
  deserializer.clear();
  final int errorCode=nativeExecutePlanFragments(pointer,numFragmentIds,planFragmentIds,inputDepIds,spHandle,lastCommittedSpHandle,uniqueId,undoToken);
  try {
    checkErrorCode(errorCode);
    FastDeserializer fds=fallbackBuffer == null ? deserializer : new FastDeserializer(fallbackBuffer);
    try {
      final int totalSize=fds.readInt();
      final boolean dirty=fds.readBoolean();
      if (dirty)       m_dirty=true;
      final ByteBuffer fullBacking=fds.readBuffer(totalSize);
      final VoltTable[] results=new VoltTable[batchSize];
      for (int i=0; i < batchSize; ++i) {
        final int numdeps=fullBacking.getInt();
        assert(numdeps == 1);
        @SuppressWarnings("unused") final int depid=fullBacking.getInt();
        final int tableSize=fullBacking.getInt();
        assert(tableSize < 50000000);
        final ByteBuffer tableBacking=fullBacking.slice();
        fullBacking.position(fullBacking.position() + tableSize);
        tableBacking.limit(tableSize);
        results[i]=PrivateVoltTableFactory.createVoltTableFromBuffer(tableBacking,true);
      }
      return results;
    }
 catch (    final IOException ex) {
      LOG.error("Failed to deserialze result table" + ex);
      throw new EEException(ERRORCODE_WRONG_SERIALIZED_BYTES);
    }
  }
  finally {
    fallbackBuffer=null;
  }
}
