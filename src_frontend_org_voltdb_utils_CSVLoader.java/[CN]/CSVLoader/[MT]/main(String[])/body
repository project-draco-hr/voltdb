{
  long start=System.currentTimeMillis();
  int waits=0;
  int shortWaits=0;
  new CSVLoader(args);
  try {
    final CSVReader reader;
    if (CSVLoader.standin)     reader=new CSVReader(new BufferedReader(new InputStreamReader(System.in)),config.separator,config.quotechar,config.escape,config.skip,config.strictquotes,config.nowhitespace);
 else     reader=new CSVReader(new FileReader(config.file),config.separator,config.quotechar,config.escape,config.skip,config.strictquotes,config.nowhitespace);
    ProcedureCallback cb=null;
    String[] serverlist=config.servers.split(",");
    ClientConfig c_config=new ClientConfig(config.user,config.password);
    c_config.setProcedureCallTimeout(0);
    final Client client=CSVLoader.getClient(c_config,serverlist,config.port);
    boolean lastOK=true;
    String line[]=null;
    int columnCnt=0;
    VoltTable procInfo=null;
    try {
      procInfo=client.callProcedure("@SystemCatalog","PROCEDURECOLUMNS").getResults()[0];
      while (procInfo.advanceRow()) {
        if (insertProcedure.matches((String)procInfo.get("PROCEDURE_NAME",VoltType.STRING))) {
          columnCnt++;
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    while ((config.limitrows-- > 0) && (line=reader.readNext()) != null) {
      outCount.incrementAndGet();
      boolean queued=false;
      while (queued == false) {
        StringBuilder linedata=new StringBuilder();
        for (int i=0; i < line.length; i++) {
          linedata.append(line[i]);
          if (i != line.length - 1)           linedata.append(",");
        }
        String[] correctedLine=line;
        cb=new MyCallback(outCount.get(),config,linedata.toString());
        String lineCheckResult;
        if ((lineCheckResult=checkLineFormat(correctedLine,columnCnt)) != null) {
          System.err.println("<zheng>Stop at line " + (outCount.get()) + lineCheckResult);
synchronized (errorInfo) {
            if (!errorInfo.containsKey(outCount.get())) {
              String[] info={linedata.toString(),lineCheckResult};
              errorInfo.put(outCount.get(),info);
            }
            if (errorInfo.size() >= config.maxerrors) {
              System.err.println("The number of Failure row data exceeds " + config.maxerrors);
              flush();
              System.exit(1);
            }
          }
          break;
        }
        queued=client.callProcedure(cb,insertProcedure,(Object[])correctedLine);
        if (queued == false) {
          ++waits;
          if (lastOK == false) {
            ++shortWaits;
          }
          Thread.sleep(waitSeconds);
        }
        lastOK=queued;
      }
    }
    client.drain();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  System.out.println("Inserted " + outCount.get() + " and acknowledged "+ inCount.get()+ " rows (final)");
  if (waits > 0) {
    System.out.println("Waited " + waits + " times");
    if (shortWaits > 0) {
      System.out.println("Waited too briefly? " + shortWaits + " times");
    }
  }
  latency=System.currentTimeMillis() - start;
  System.out.println("CSVLoader elaspsed: " + latency / 1000F + " seconds");
  produceFiles();
  flush();
}
