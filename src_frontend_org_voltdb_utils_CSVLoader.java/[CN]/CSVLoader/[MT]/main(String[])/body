{
  start=System.currentTimeMillis();
  long insertTimeStart=start;
  long insertTimeEnd;
  final CSVConfig cfg=new CSVConfig();
  cfg.parse(CSVLoader.class.getName(),args);
  config=cfg;
  configuration();
  final Tokenizer tokenizer;
  ICsvListReader listReader=null;
  try {
    if (CSVLoader.standin) {
      tokenizer=new Tokenizer(new BufferedReader(new InputStreamReader(System.in)),csvPreference,config.strictquotes,config.escape,config.columnsizelimit,config.skip);
      listReader=new CsvListReader(tokenizer,csvPreference);
    }
 else {
      tokenizer=new Tokenizer(new FileReader(config.file),csvPreference,config.strictquotes,config.escape,config.columnsizelimit,config.skip);
      listReader=new CsvListReader(tokenizer,csvPreference);
    }
  }
 catch (  FileNotFoundException e) {
    m_log.error("CSV file '" + config.file + "' could not be found.");
    System.exit(-1);
  }
  final String[] serverlist=config.servers.split(",");
  final ClientConfig c_config=new ClientConfig(config.user,config.password);
  c_config.setProcedureCallTimeout(0);
  Client csvClient=null;
  try {
    csvClient=CSVLoader.getClient(c_config,serverlist,config.port);
  }
 catch (  Exception e) {
    m_log.error("Error connecting to the servers: " + config.servers);
    close_cleanup();
    System.exit(-1);
  }
  assert(csvClient != null);
  int partitionedColumnIndex=-1;
  int columnCnt=0;
  VoltType partitionColumnType=VoltType.NULL;
  try {
    VoltTable procInfo;
    boolean isProcExist=false;
    try {
      if (config.useSuppliedProcedure) {
        procInfo=csvClient.callProcedure("@SystemCatalog","PROCEDURECOLUMNS").getResults()[0];
        while (procInfo.advanceRow()) {
          if (insertProcedure.matches((String)procInfo.get("PROCEDURE_NAME",VoltType.STRING))) {
            columnCnt++;
            isProcExist=true;
            String typeStr=(String)procInfo.get("TYPE_NAME",VoltType.STRING);
            typeList.add(VoltType.typeFromString(typeStr));
          }
        }
        if (isProcExist == false) {
          m_log.error("No matching insert procedure available");
          close_cleanup();
          System.exit(-1);
        }
        if (isProcedureMp(csvClient)) {
          m_log.warn("Using a multi-partitioned procedure to load data will be slow. " + "If loading a partitioned table, use a single-partitioned procedure " + "for best performance.");
        }
      }
    }
 catch (    Exception e) {
      m_log.error(e.getMessage(),e);
      close_cleanup();
      System.exit(-1);
    }
    procInfo=csvClient.callProcedure("@SystemCatalog","COLUMNS").getResults()[0];
    Map<Integer,VoltType> columnTypes=new TreeMap<Integer,VoltType>();
    Map<Integer,String> colNames=new TreeMap<Integer,String>();
    while (procInfo.advanceRow()) {
      String table=procInfo.getString("TABLE_NAME");
      if (config.table.equalsIgnoreCase(table)) {
        VoltType vtype=VoltType.typeFromString(procInfo.getString("TYPE_NAME"));
        int idx=(int)procInfo.getLong("ORDINAL_POSITION") - 1;
        columnTypes.put(idx,vtype);
        colNames.put(idx,procInfo.getString("COLUMN_NAME"));
        String remarks=procInfo.getString("REMARKS");
        if (remarks != null && remarks.equalsIgnoreCase("PARTITION_COLUMN")) {
          partitionColumnType=vtype;
          partitionedColumnIndex=idx;
          m_log.info("Table " + config.table + " Partition Column Name is: "+ procInfo.getString("COLUMN_NAME"));
          m_log.info("Table " + config.table + " Partition Column Type is: "+ vtype.toString());
        }
      }
    }
    if (!config.useSuppliedProcedure && columnTypes.isEmpty()) {
      m_log.error("Table " + config.table + " Not found");
      close_cleanup();
      System.exit(-1);
    }
    VoltTable.ColumnInfo colInfo[]=new VoltTable.ColumnInfo[columnTypes.size()];
    for (int i=0; i < columnTypes.size(); i++) {
      VoltType type=columnTypes.get(i);
      String cname=colNames.get(i);
      VoltTable.ColumnInfo ci=new VoltTable.ColumnInfo(cname,type);
      colInfo[i]=ci;
    }
    int numProcessors=-1;
    int sitesPerHost=1;
    int kfactor=0;
    int hostcount=1;
    procInfo=csvClient.callProcedure("@SystemInformation","deployment").getResults()[0];
    while (procInfo.advanceRow()) {
      String prop=procInfo.getString("PROPERTY");
      if (prop != null && prop.equalsIgnoreCase("sitesperhost")) {
        sitesPerHost=Integer.parseInt(procInfo.getString("VALUE"));
      }
      if (prop != null && prop.equalsIgnoreCase("hostcount")) {
        hostcount=Integer.parseInt(procInfo.getString("VALUE"));
      }
      if (prop != null && prop.equalsIgnoreCase("kfactor")) {
        kfactor=Integer.parseInt(procInfo.getString("VALUE"));
      }
    }
    boolean isMP=(partitionedColumnIndex == -1 ? true : false);
    if (!isMP) {
      numProcessors=(hostcount * sitesPerHost) / (kfactor + 1);
      m_log.info("Number of Partitions: " + numProcessors);
      m_log.info("Batch Size is: " + config.batch);
      TheHashinator.initialize(LegacyHashinator.class,LegacyHashinator.getConfigureBytes(numProcessors));
    }
 else {
      if (!config.useSuppliedProcedure) {
        m_log.warn("Using a multi-partitioned procedure to load data will be slow. " + "If loading a partitioned table, use a single-partitioned procedure " + "for best performance.");
      }
      numProcessors=1;
    }
    CountDownLatch processor_cdl=new CountDownLatch(numProcessors);
    CSVPartitionProcessor.processor_cdl=processor_cdl;
    CSVPartitionProcessor.colInfo=colInfo;
    CSVPartitionProcessor.columnTypes=columnTypes;
    CSVPartitionProcessor.insertProcedure=insertProcedure;
    CSVPartitionProcessor.isMP=isMP;
    CSVPartitionProcessor.config=config;
    CSVPartitionProcessor.tableName=config.table;
    List<Thread> spawned=new ArrayList<Thread>(numProcessors);
    CSVLineWithMetaData endOfData=new CSVLineWithMetaData(null,null,-1);
    Map<Integer,BlockingQueue<CSVLineWithMetaData>> lineq=new HashMap<Integer,BlockingQueue<CSVLineWithMetaData>>(numProcessors);
    List<CSVPartitionProcessor> processors=new ArrayList<CSVPartitionProcessor>(numProcessors);
    for (int i=0; i < numProcessors; i++) {
      LinkedBlockingQueue<CSVLineWithMetaData> partitionQueue=new LinkedBlockingQueue<CSVLineWithMetaData>((int)config.batch);
      lineq.put(i,partitionQueue);
      CSVPartitionProcessor processor=new CSVPartitionProcessor(csvClient,i,partitionedColumnIndex,partitionQueue,endOfData);
      processors.add(processor);
      Thread th=new Thread(processor);
      th.setName(processor.m_processorName);
      spawned.add(th);
    }
    CSVFileReader.config=config;
    if (config.useSuppliedProcedure) {
      CSVFileReader.columnCnt=columnCnt;
    }
 else {
      CSVFileReader.columnCnt=columnTypes.size();
    }
    CSVFileReader.listReader=listReader;
    CSVFileReader.partitionedColumnIndex=partitionedColumnIndex;
    CSVFileReader.partitionColumnType=partitionColumnType;
    CSVFileReader.tableName=config.table;
    CSVFileReader.typeList=typeList;
    CSVFileReader.csvClient=csvClient;
    CSVFileReader.processorQueues=lineq;
    CSVFileReader.endOfData=endOfData;
    CSVFileReader.processor_cdl=processor_cdl;
    CSVFileReader rdr=new CSVFileReader();
    Thread th=new Thread(rdr);
    th.setName("CSVFileReader");
    th.setDaemon(true);
    for (    Thread th2 : spawned) {
      th2.start();
    }
    th.start();
    th.join();
    long readerTime=0;
    readerTime+=(rdr.m_parsingTimeEnd - rdr.m_parsingTimeSt);
    readerTime=readerTime / 1000000;
    insertTimeEnd=System.currentTimeMillis();
    csvClient.drain();
    csvClient.close();
    long insertCount=0, ackCount=0;
    for (    CSVPartitionProcessor pp : processors) {
      insertCount+=pp.m_partitionProcessedCount.get();
    }
    ackCount=CSVPartitionProcessor.partitionAcknowledgedCount.get();
    m_log.info("Parsing CSV file took " + readerTime + " milliseconds.");
    m_log.info("Inserting Data took " + ((insertTimeEnd - insertTimeStart) - readerTime) + " milliseconds.");
    m_log.info("Inserted " + insertCount + " and acknowledged "+ ackCount+ " rows (final)");
    produceFiles(ackCount,insertCount);
    close_cleanup();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}
