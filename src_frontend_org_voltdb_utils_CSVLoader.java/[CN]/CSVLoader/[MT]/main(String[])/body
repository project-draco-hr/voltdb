{
  start=System.currentTimeMillis();
  int waits=0;
  int shortWaits=0;
  CSVConfig cfg=new CSVConfig();
  cfg.parse(CSVLoader.class.getName(),args);
  config=cfg;
  configuration();
  ICsvListReader listReader=null;
  try {
    if (CSVLoader.standin)     listReader=new CsvListReader(new BufferedReader(new InputStreamReader(System.in)),csvPreference);
 else     listReader=new CsvListReader(new FileReader(config.file),csvPreference);
  }
 catch (  FileNotFoundException e) {
    m_log.error("CSV file '" + config.file + "' could not be found.");
    System.exit(-1);
  }
  assert(listReader != null);
  String[] serverlist=config.servers.split(",");
  ClientConfig c_config=new ClientConfig(config.user,config.password);
  c_config.setProcedureCallTimeout(0);
  Client csvClient=null;
  try {
    csvClient=CSVLoader.getClient(c_config,serverlist,config.port);
  }
 catch (  Exception e) {
    m_log.error("Error to connect to the servers:" + config.servers);
    close_cleanup();
    System.exit(-1);
  }
  assert(csvClient != null);
  try {
    ProcedureCallback cb=null;
    boolean lastOK=true;
    int columnCnt=0;
    VoltTable procInfo=null;
    boolean isProcExist=false;
    try {
      procInfo=csvClient.callProcedure("@SystemCatalog","PROCEDURECOLUMNS").getResults()[0];
      while (procInfo.advanceRow()) {
        if (insertProcedure.matches((String)procInfo.get("PROCEDURE_NAME",VoltType.STRING))) {
          columnCnt++;
          isProcExist=true;
          String typeStr=(String)procInfo.get("TYPE_NAME",VoltType.STRING);
          typeList.add(VoltType.typeFromString(typeStr));
        }
      }
    }
 catch (    Exception e) {
      m_log.error(e.getMessage(),e);
      close_cleanup();
      System.exit(-1);
    }
    if (isProcExist == false) {
      m_log.error("No matching insert procedure available");
      close_cleanup();
      System.exit(-1);
    }
    List<String> lineList=null;
    while ((config.limitrows-- > 0) && !listReader.isEOF()) {
      try {
        while (listReader.getLineNumber() < config.skip)         lineList=listReader.read();
        lineList=listReader.read();
        if (lineList == null)         break;
        outCount.incrementAndGet();
        boolean queued=false;
        while (queued == false) {
          Object[] correctedLine=lineList.toArray();
          cb=new MyCallback(outCount.get(),config,lineList.toString());
          String lineCheckResult;
          if ((lineCheckResult=checkparams_trimspace(correctedLine,columnCnt)) != null) {
synchronized (errorInfo) {
              if (!errorInfo.containsKey(outCount.get())) {
                String[] info={lineList.toString(),lineCheckResult};
                errorInfo.put(outCount.get(),info);
              }
              if (errorInfo.size() >= config.maxerrors) {
                m_log.error("The number of Failure row data exceeds " + config.maxerrors);
                produceFiles();
                close_cleanup();
                System.exit(-1);
              }
            }
            break;
          }
          queued=csvClient.callProcedure(cb,insertProcedure,(Object[])correctedLine);
          if (queued == false) {
            ++waits;
            if (lastOK == false) {
              ++shortWaits;
            }
            Thread.sleep(waitSeconds);
          }
          lastOK=queued;
        }
      }
 catch (      SuperCsvException e) {
        outCount.incrementAndGet();
        String msg=e.getMessage();
synchronized (errorInfo) {
          if (!errorInfo.containsKey(outCount.get())) {
            String[] info={"At line" + listReader.getLineNumber(),msg};
            errorInfo.put(outCount.get(),info);
          }
          if (errorInfo.size() >= config.maxerrors) {
            m_log.error("The number of Failure row data exceeds " + config.maxerrors);
            produceFiles();
            close_cleanup();
            System.exit(-1);
          }
        }
      }
    }
    csvClient.drain();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  m_log.info("Inserted " + outCount.get() + " and acknowledged "+ inCount.get()+ " rows (final)");
  if (waits > 0) {
    m_log.info("Waited " + waits + " times");
    if (shortWaits > 0) {
      m_log.info("Waited too briefly? " + shortWaits + " times");
    }
  }
  produceFiles();
  close_cleanup();
  listReader.close();
  csvClient.close();
}
