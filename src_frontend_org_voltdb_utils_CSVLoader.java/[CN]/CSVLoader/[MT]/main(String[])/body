{
  start=System.currentTimeMillis();
  int waits=0;
  int shortWaits=0;
  CSVConfig cfg=new CSVConfig();
  cfg.parse(CSVLoader.class.getName(),args);
  config=cfg;
  configuration();
  ICsvListReader listReader=null;
  try {
    if (CSVLoader.standin) {
      listReader=new CsvListReader(new BufferedReader(new InputStreamReader(System.in)),CsvPreference.STANDARD_PREFERENCE);
    }
 else     listReader=new CsvListReader(new FileReader(config.file),CsvPreference.STANDARD_PREFERENCE);
    listReader.getHeader(true);
    final CellProcessor[] processors=getProcessors();
  }
 catch (  FileNotFoundException e) {
    m_log.error("CSV file '" + config.file + "' could not be found.");
    System.exit(-1);
  }
  assert(listReader != null);
  String[] serverlist=config.servers.split(",");
  ClientConfig c_config=new ClientConfig(config.user,config.password);
  c_config.setProcedureCallTimeout(0);
  Client csvClient=null;
  try {
    csvClient=CSVLoader.getClient(c_config,serverlist,config.port);
  }
 catch (  Exception e) {
    m_log.error("Error connecting to the servers:" + config.servers);
    close_cleanup();
    System.exit(-1);
  }
  assert(csvClient != null);
  try {
    final CellProcessor[] processors=getProcessors();
    ProcedureCallback cb=null;
    boolean lastOK=true;
    List<String> lineList;
    Object[] line;
    while ((config.limitrows-- > 0) && (lineList=listReader.read()) != null) {
      outCount.incrementAndGet();
      boolean queued=false;
      while (queued == false) {
        StringBuilder linedata=new StringBuilder();
        line=lineList.toArray();
        for (int i=0; i < line.length; i++) {
          linedata.append("\"" + line[i] + "\"");
          if (i != line.length - 1)           linedata.append(",");
        }
        Object[] correctedLine=line;
        cb=new MyCallback(outCount.get(),config,linedata.toString());
        String lineCheckResult;
        if ((lineCheckResult=checkparams_trimspace(correctedLine,columnCnt)) != null) {
synchronized (errorInfo) {
            if (!errorInfo.containsKey(outCount.get())) {
              String[] info={linedata.toString(),lineCheckResult};
              errorInfo.put(outCount.get(),info);
            }
            if (errorInfo.size() >= config.maxerrors) {
              m_log.error("The number of Failure row data exceeds " + config.maxerrors);
              produceFiles();
              close_cleanup();
              System.exit(-1);
            }
          }
          break;
        }
        queued=csvClient.callProcedure(cb,insertProcedure,(Object[])correctedLine);
        if (queued == false) {
          ++waits;
          if (lastOK == false) {
            ++shortWaits;
          }
          Thread.sleep(waitSeconds);
        }
        lastOK=queued;
      }
    }
    csvClient.drain();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  m_log.info("Inserted " + outCount.get() + " and acknowledged "+ inCount.get()+ " rows (final)");
  if (waits > 0) {
    m_log.info("Waited " + waits + " times");
    if (shortWaits > 0) {
      m_log.info("Waited too briefly? " + shortWaits + " times");
    }
  }
  produceFiles();
  close_cleanup();
  listReader.close();
  csvClient.close();
}
