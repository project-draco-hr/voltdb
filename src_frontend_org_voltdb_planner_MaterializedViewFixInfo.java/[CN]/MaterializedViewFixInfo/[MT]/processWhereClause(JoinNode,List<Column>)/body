{
  AbstractExpression where=analyzeJoinTreeFilters(joinTree);
  if (where != null) {
    List<TupleValueExpression> needReAggTVEs=new ArrayList<TupleValueExpression>();
    for (int i=m_numOfGroupByColumns; i < mvColumnArray.size(); i++) {
      Column mvCol=mvColumnArray.get(i);
      TupleValueExpression tve=new TupleValueExpression();
      tve.setColumnIndex(i);
      tve.setColumnName(mvCol.getName());
      tve.setTableName(getMVTableName());
      tve.setColumnAlias(mvCol.getName());
      tve.setValueType(VoltType.get((byte)mvCol.getType()));
      tve.setValueSize(mvCol.getSize());
      needReAggTVEs.add(tve);
    }
    List<AbstractExpression> remaningExprs=new ArrayList<AbstractExpression>();
    List<AbstractExpression> aggPostExprs=new ArrayList<AbstractExpression>();
    List<AbstractExpression> exprs=ExpressionUtil.uncombine(where);
    for (    AbstractExpression expr : exprs) {
      ArrayList<AbstractExpression> tves=expr.findBaseTVEs();
      boolean reAggPostExprs=false;
      if (fromNumberOfTables(tves) == 1) {
        for (        TupleValueExpression needReAggTVE : needReAggTVEs) {
          if (tves.contains(needReAggTVE)) {
            reAggPostExprs=true;
            break;
          }
        }
      }
      if (reAggPostExprs) {
        aggPostExprs.add(expr);
      }
 else {
        remaningExprs.add(expr);
      }
    }
    AbstractExpression aggPostExpr=ExpressionUtil.combine(aggPostExprs);
    m_reAggNode.setPostPredicate(aggPostExpr);
    AbstractExpression scanFilters=ExpressionUtil.combine(remaningExprs);
    boolean updated=updateJoinFilters(joinTree,scanFilters);
    assert(updated);
  }
}
