{
  if (isHSQL())   return;
  final long partitionRowLimit=5;
  final long numPartitions=getLogicalPartitionCount();
  Client client=getClient();
  for (int j=0; j < 2; ++j) {
    VoltTable vt;
    for (int i=0; i < 50; ++i) {
      String uuid=UUID.randomUUID().toString();
      vt=client.callProcedure("@AdHoc","INSERT INTO events_capped VALUES ('" + uuid + "', NOW, "+ i+ ")").getResults()[0];
      validateTableOfScalarLongs(vt,new long[]{1});
    }
    if (numPartitions > 1) {
      final long minRows=partitionRowLimit;
      final long maxRows=partitionRowLimit * numPartitions;
      vt=client.callProcedure("@AdHoc","select count(*) from events_capped").getResults()[0];
      long numRows=vt.asScalarLong();
      assertTrue("Too many rows in target table: ",numRows <= maxRows);
      assertTrue("Too few rows in target table: ",numRows >= minRows);
      vt=client.callProcedure("@AdHoc","SELECT info FROM events_capped " + "ORDER BY when_occurred desc, info desc " + "LIMIT 50 OFFSET 5").getResults()[0];
      long prevValue=50;
      while (vt.advanceRow()) {
        long curValue=vt.getLong(0);
        assertTrue(curValue < prevValue);
        prevValue=curValue;
      }
    }
    vt=client.callProcedure("@AdHoc","select info from events_capped order by when_occurred desc, info desc limit 5").getResults()[0];
    validateTableOfScalarLongs(vt,new long[]{49,48,47,46,45});
    if (j == 0) {
      client.callProcedure("@AdHoc","delete from events_capped");
    }
  }
}
