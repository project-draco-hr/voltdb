{
  while (!Thread.interrupted() && m_saveFile.hasMoreChunks()) {
    if (m_availableBytes.get() > m_maxAvailableBytes) {
      Thread.sleep(5);
      continue;
    }
    BBContainer c=m_saveFile.getNextChunk();
    if (c == null) {
      return;
    }
    try {
      final int size=c.b.remaining();
      final VoltTable vt=PrivateVoltTableFactory.createVoltTableFromBuffer(c.b,true);
      StringBuilder sb=new StringBuilder(size * 2);
      while (vt.advanceRow()) {
        for (int ii=0; ii < vt.getColumnCount(); ii++) {
          final VoltType type=vt.getColumnType(ii);
          if (vt.wasNull()) {
            m_escaper.writeRawField(sb,"NULL",ii > 0);
          }
 else           if (type == VoltType.BIGINT || type == VoltType.INTEGER || type == VoltType.SMALLINT || type == VoltType.TINYINT) {
            m_escaper.writeRawField(sb,String.valueOf(vt.getLong(ii)),ii > 0);
          }
 else           if (type == VoltType.FLOAT) {
            m_escaper.writeRawField(sb,String.valueOf(vt.getDouble(ii)),ii > 0);
          }
 else           if (type == VoltType.DECIMAL) {
            m_escaper.writeRawField(sb,vt.getDecimalAsBigDecimal(ii).toString(),ii > 0);
          }
 else           if (type == VoltType.STRING) {
            m_escaper.writeEscapedField(sb,vt.getString(ii),ii > 0);
          }
 else           if (type == VoltType.TIMESTAMP) {
            final TimestampType timestamp=vt.getTimestampAsTimestamp(ii);
            m_escaper.writeRawField(sb,m_sdf.format(timestamp.asApproximateJavaDate()),ii > 0);
            m_escaper.writeRawField(sb,String.valueOf(timestamp.getUSec()),false);
          }
        }
        sb.append('\n');
      }
      byte bytes[]=null;
      try {
        bytes=sb.toString().getBytes("UTF-8");
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
        return;
      }
      m_availableBytes.addAndGet(bytes.length);
      m_available.offer(bytes);
    }
  finally {
      c.discard();
    }
  }
}
