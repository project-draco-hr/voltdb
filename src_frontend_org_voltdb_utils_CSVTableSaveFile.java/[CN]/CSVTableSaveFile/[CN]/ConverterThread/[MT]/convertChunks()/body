{
  while (!Thread.interrupted() && m_saveFile.hasMoreChunks()) {
    if (m_availableBytes.get() > m_maxAvailableBytes) {
      Thread.sleep(5);
      continue;
    }
    BBContainer c=m_saveFile.getNextChunk();
    if (c == null) {
      return;
    }
    try {
      final int size=c.b.remaining();
      final VoltTable vt=PrivateVoltTableFactory.createVoltTableFromBuffer(c.b,true);
      StringWriter sw=new StringWriter(size * 2);
      CSVWriter csv;
      if (m_delimiter == '\t')       csv=CSVWriter.getStrictTSVWriter(sw);
 else       csv=new CSVWriter(sw,m_delimiter);
      String[] fields=new String[vt.getColumnCount()];
      while (vt.advanceRow()) {
        for (int ii=0; ii < vt.getColumnCount(); ii++) {
          final VoltType type=vt.getColumnType(ii);
          if (vt.wasNull()) {
            fields[ii]="NULL";
          }
 else           if (type == VoltType.BIGINT || type == VoltType.INTEGER || type == VoltType.SMALLINT || type == VoltType.TINYINT) {
            fields[ii]=String.valueOf(vt.getLong(ii));
          }
 else           if (type == VoltType.FLOAT) {
            fields[ii]=String.valueOf(vt.getDouble(ii));
          }
 else           if (type == VoltType.DECIMAL) {
            fields[ii]=vt.getDecimalAsBigDecimal(ii).toString();
          }
 else           if (type == VoltType.STRING) {
            fields[ii]=vt.getString(ii);
          }
 else           if (type == VoltType.TIMESTAMP) {
            final TimestampType timestamp=vt.getTimestampAsTimestamp(ii);
            fields[ii]=m_sdf.format(timestamp.asApproximateJavaDate());
            fields[ii]+=String.valueOf(timestamp.getUSec());
          }
        }
        csv.writeNext(fields);
      }
      csv.flush();
      byte bytes[]=null;
      try {
        bytes=sw.toString().getBytes("UTF-8");
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
        return;
      }
      m_availableBytes.addAndGet(bytes.length);
      m_available.offer(bytes);
    }
  finally {
      c.discard();
    }
  }
}
