{
  Thread.currentThread().setName("Iv2ExecutionSite: " + CoreUtils.hsIdToString(m_siteId));
  if (m_coreBindIds != null) {
    PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindIds);
  }
  initialize(m_startupConfig.m_serializedCatalog,m_startupConfig.m_timestamp);
  m_startupConfig=null;
  final MinimumRatioMaintainer mrm=new MinimumRatioMaintainer(m_taskLogReplayRatio);
  try {
    while (m_shouldContinue) {
      if (m_rejoinState == kStateRunning) {
        SiteTasker task=m_scheduler.take();
        if (task instanceof TransactionTask) {
          m_currentTxnId=((TransactionTask)task).getTxnId();
          m_lastTxnTime=EstTime.currentTimeMillis();
        }
        task.run(getSiteProcedureConnection());
      }
 else {
        SiteTasker task=null;
        boolean didWork=false;
        while ((task=m_scheduler.poll()) != null) {
          didWork=true;
          if (!m_rejoinTaskLog.isEmpty() && !mrm.canDoRestricted()) {
            while (!mrm.canDoRestricted()) {
              replayFromTaskLog(mrm);
            }
          }
          mrm.didRestricted();
          task.runForRejoin(getSiteProcedureConnection(),m_rejoinTaskLog);
        }
        didWork|=replayFromTaskLog(mrm);
        if (!didWork)         Thread.yield();
      }
    }
  }
 catch (  OutOfMemoryError e) {
    String errmsg="Site: " + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) + " ran out of Java memory. "+ "This node will shut down.";
    VoltDB.crashLocalVoltDB(errmsg,true,e);
  }
catch (  Throwable t) {
    String errmsg="Site: " + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) + " encountered an "+ "unexpected error and will die, taking this VoltDB node down.";
    VoltDB.crashLocalVoltDB(errmsg,true,t);
  }
  shutdown();
}
