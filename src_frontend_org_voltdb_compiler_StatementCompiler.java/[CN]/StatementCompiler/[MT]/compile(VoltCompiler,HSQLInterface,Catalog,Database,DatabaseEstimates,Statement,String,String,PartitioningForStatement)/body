{
  boolean compilerDebug=System.getProperties().contains("compilerdebug");
  stmt=stmt.replaceAll("\n"," ");
  stmt=stmt.trim();
  compiler.addInfo("Compiling Statement: " + stmt);
  QueryType qtype=QueryType.INVALID;
  boolean statementRO=true;
  if (stmt.toLowerCase().startsWith("insert")) {
    qtype=QueryType.INSERT;
    statementRO=false;
  }
 else   if (stmt.toLowerCase().startsWith("update")) {
    qtype=QueryType.UPDATE;
    statementRO=false;
  }
 else   if (stmt.toLowerCase().startsWith("delete")) {
    qtype=QueryType.DELETE;
    statementRO=false;
  }
 else   if (stmt.toLowerCase().startsWith("select")) {
    qtype=QueryType.SELECT;
  }
 else   if (stmt.toLowerCase().startsWith("(")) {
    qtype=QueryType.SELECT;
  }
  catalogStmt.setReadonly(statementRO);
  catalogStmt.setQuerytype(qtype.getValue());
  catalogStmt.setSqltext(stmt);
  catalogStmt.setSinglepartition(partitioning.wasSpecifiedAsSingle());
  catalogStmt.setBatched(false);
  catalogStmt.setParamnum(0);
  String name=catalogStmt.getParent().getTypeName() + "-" + catalogStmt.getTypeName();
  PlanNodeList node_list=null;
  TrivialCostModel costModel=new TrivialCostModel();
  QueryPlanner planner=new QueryPlanner(catalog.getClusters().get("cluster"),db,partitioning,hsql,estimates,true,false);
  CompiledPlan plan=null;
  try {
    plan=planner.compilePlan(costModel,catalogStmt.getSqltext(),joinOrder,catalogStmt.getTypeName(),catalogStmt.getParent().getTypeName(),DEFAULT_MAX_JOIN_TABLES,null);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw compiler.new VoltCompilerException("Failed to plan for stmt: " + catalogStmt.getTypeName());
  }
  if (plan == null) {
    String msg="Failed to plan for statement type(" + catalogStmt.getTypeName() + ") "+ catalogStmt.getSqltext();
    String plannerMsg=planner.getErrorMessage();
    if (plannerMsg != null) {
      msg+=" Error: \"" + plannerMsg + "\"";
    }
    throw compiler.new VoltCompilerException(msg);
  }
  boolean orderDeterministic=plan.isOrderDeterministic();
  catalogStmt.setIsorderdeterministic(orderDeterministic);
  boolean contentDeterministic=plan.isContentDeterministic();
  catalogStmt.setIscontentdeterministic(contentDeterministic);
  String nondeterminismDetail=plan.nondeterminismDetail();
  catalogStmt.setNondeterminismdetail(nondeterminismDetail);
  catalogStmt.setSeqscancount(plan.countSeqScans());
  for (  ParameterInfo param : plan.parameters) {
    StmtParameter catalogParam=catalogStmt.getParameters().add(String.valueOf(param.index));
    catalogParam.setJavatype(param.type.getValue());
    catalogParam.setIndex(param.index);
  }
  int index=0;
  for (  SchemaColumn col : plan.columns.getColumns()) {
    Column catColumn=catalogStmt.getOutput_columns().add(String.valueOf(index));
    catColumn.setNullable(false);
    catColumn.setIndex(index);
    if (col.getColumnAlias() != null && !col.getColumnAlias().equals("")) {
      catColumn.setName(col.getColumnAlias());
    }
 else {
      catColumn.setName(col.getColumnName());
    }
    catColumn.setType(col.getType().getValue());
    catColumn.setSize(col.getSize());
    index++;
  }
  catalogStmt.setReplicatedtabledml(plan.replicatedTableDML);
  partitioning.setIsReplicatedTableDML(plan.replicatedTableDML);
  PrintStream plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-winner-plans",name + ".txt");
  plansOut.println("SQL: " + plan.sql);
  plansOut.println("COST: " + Double.toString(plan.cost));
  plansOut.println("PLAN:\n");
  plansOut.println(plan.explainedPlan);
  plansOut.close();
  catalogStmt.setExplainplan(Encoder.hexEncode(plan.explainedPlan));
  int i=0;
  Collections.sort(plan.fragments);
  for (  CompiledPlan.Fragment fragment : plan.fragments) {
    node_list=new PlanNodeList(fragment.planGraph);
    String planFragmentName=Integer.toString(i);
    PlanFragment planFragment=catalogStmt.getFragments().add(planFragmentName);
    planFragment.setNontransactional(!fragmentReferencesPersistentTable(fragment.planGraph));
    planFragment.setHasdependencies(fragment.hasDependencies);
    planFragment.setMultipartition(fragment.multiPartition);
    String json=node_list.toJSONString();
    if (compilerDebug) {
      String prettyJson=null;
      try {
        JSONObject jobj=new JSONObject(json);
        prettyJson=jobj.toString(4);
      }
 catch (      JSONException e2) {
        e2.printStackTrace();
        throw compiler.new VoltCompilerException(e2.getMessage());
      }
      plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-winner-plan-fragments",name + "-" + String.valueOf(i)+ ".txt");
      plansOut.println(prettyJson);
      plansOut.close();
      plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-winner-plan-fragments",name + String.valueOf(i) + ".dot");
      plansOut.println(node_list.toDOTString(name + "-" + String.valueOf(i)));
      plansOut.close();
    }
    try {
      FastSerializer fs=new FastSerializer(true,false);
      fs.write(json.getBytes());
      String hexString=fs.getHexEncodedBytes();
      planFragment.setPlannodetree(hexString);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw compiler.new VoltCompilerException(e.getMessage());
    }
    i++;
  }
  int validType=catalogStmt.getQuerytype();
  assert(validType != QueryType.INVALID.getValue());
}
