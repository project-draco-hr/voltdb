{
  stmt=stmt.replaceAll("\n"," ");
  stmt=stmt.trim();
  compiler.addInfo("Compiling Statement: " + stmt);
  QueryType qtype;
  if (stmt.toLowerCase().startsWith("insert")) {
    qtype=QueryType.INSERT;
    catalogStmt.setReadonly(false);
  }
 else   if (stmt.toLowerCase().startsWith("update")) {
    qtype=QueryType.UPDATE;
    catalogStmt.setReadonly(false);
  }
 else   if (stmt.toLowerCase().startsWith("delete")) {
    qtype=QueryType.DELETE;
    catalogStmt.setReadonly(false);
  }
 else   if (stmt.toLowerCase().startsWith("select")) {
    qtype=QueryType.SELECT;
    catalogStmt.setReadonly(true);
  }
 else {
    throw compiler.new VoltCompilerException("Unparsable SQL statement: " + stmt);
  }
  catalogStmt.setQuerytype(qtype.getValue());
  catalogStmt.setSqltext(stmt);
  catalogStmt.setSinglepartition(singlePartition);
  catalogStmt.setBatched(false);
  catalogStmt.setParamnum(0);
  String name=catalogStmt.getParent().getTypeName() + "-" + catalogStmt.getTypeName();
  PlanNodeList node_list=null;
  TrivialCostModel costModel=new TrivialCostModel();
  QueryPlanner planner=new QueryPlanner(catalog.getClusters().get("cluster"),db,hsql,estimates,true,false);
  CompiledPlan plan=null;
  try {
    plan=planner.compilePlan(costModel,catalogStmt.getSqltext(),joinOrder,catalogStmt.getTypeName(),catalogStmt.getParent().getTypeName(),catalogStmt.getSinglepartition(),null);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw compiler.new VoltCompilerException("Failed to plan for stmt: " + catalogStmt.getTypeName());
  }
  if (plan == null) {
    String msg="Failed to plan for statement type(" + catalogStmt.getTypeName() + ") "+ catalogStmt.getSqltext();
    String plannerMsg=planner.getErrorMessage();
    if (plannerMsg != null) {
      msg+=" Error: \"" + plannerMsg + "\"";
    }
    throw compiler.new VoltCompilerException(msg);
  }
  for (  ParameterInfo param : plan.parameters) {
    StmtParameter catalogParam=catalogStmt.getParameters().add(String.valueOf(param.index));
    catalogParam.setJavatype(param.type.getValue());
    catalogParam.setIndex(param.index);
  }
  int index=0;
  for (  SchemaColumn col : plan.columns.getColumns()) {
    Column catColumn=catalogStmt.getOutput_columns().add(String.valueOf(index));
    catColumn.setNullable(false);
    catColumn.setIndex(index);
    if (col.getColumnAlias() != null && !col.getColumnAlias().equals("")) {
      catColumn.setName(col.getColumnAlias());
    }
 else {
      catColumn.setName(col.getColumnName());
    }
    catColumn.setType(col.getType().getValue());
    catColumn.setSize(col.getSize());
    index++;
  }
  catalogStmt.setReplicatedtabledml(plan.replicatedTableDML);
  int i=0;
  Collections.sort(plan.fragments);
  for (  CompiledPlan.Fragment fragment : plan.fragments) {
    node_list=new PlanNodeList(fragment.planGraph);
    String planFragmentName=Integer.toString(i);
    PlanFragment planFragment=catalogStmt.getFragments().add(planFragmentName);
    planFragment.setNontransactional(!fragmentReferencesPersistentTable(fragment.planGraph));
    planFragment.setHasdependencies(fragment.hasDependencies);
    planFragment.setMultipartition(fragment.multiPartition);
    String json=null;
    try {
      JSONObject jobj=new JSONObject(node_list.toJSONString());
      json=jobj.toString(4);
    }
 catch (    JSONException e2) {
      e2.printStackTrace();
      throw compiler.new VoltCompilerException(e2.getMessage());
    }
    PrintStream plansOut=BuildDirectoryUtils.getDebugOutputPrintStream("statement-winner-plans",name + "-" + String.valueOf(i++)+ ".txt");
    plansOut.println(json);
    plansOut.close();
    try {
      FastSerializer fs=new FastSerializer(false,false);
      fs.write(json.getBytes());
      String hexString=fs.getHexEncodedBytes();
      planFragment.setPlannodetree(hexString);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw compiler.new VoltCompilerException(e.getMessage());
    }
  }
}
