{
  final Long now=System.currentTimeMillis();
  final VoltTable retval=new VoltTable(procedureStatsColumns);
  long totalInvocations=0;
  long totalAbortedInvocations=0;
  long totalFailedInvocations=0;
  long totalRoundTripTime=0;
  int totalRoundTripMax=Integer.MIN_VALUE;
  int totalRoundTripMin=Integer.MAX_VALUE;
  long totalClusterRoundTripTime=0;
  int totalClusterRoundTripMax=Integer.MIN_VALUE;
  int totalClusterRoundTripMin=Integer.MAX_VALUE;
synchronized (m_connections) {
    for (    NodeConnection cxn : m_connections) {
synchronized (cxn) {
        for (        ProcedureStats stats : cxn.m_stats.values()) {
          long invocationsCompleted=stats.m_invocationsCompleted;
          long invocationAborts=stats.m_invocationAborts;
          long invocationErrors=stats.m_invocationErrors;
          long roundTripTime=stats.m_roundTripTime;
          int maxRoundTripTime=stats.m_maxRoundTripTime;
          int minRoundTripTime=stats.m_minRoundTripTime;
          long clusterRoundTripTime=stats.m_clusterRoundTripTime;
          int clusterMinRoundTripTime=stats.m_minClusterRoundTripTime;
          int clusterMaxRoundTripTime=stats.m_maxClusterRoundTripTime;
          if (interval) {
            invocationsCompleted=stats.m_invocationsCompleted - stats.m_lastInvocationsCompleted;
            if (invocationsCompleted == 0) {
              continue;
            }
            stats.m_lastInvocationsCompleted=stats.m_invocationsCompleted;
            invocationAborts=stats.m_invocationAborts - stats.m_lastInvocationAborts;
            stats.m_lastInvocationAborts=stats.m_invocationAborts;
            invocationErrors=stats.m_invocationErrors - stats.m_lastInvocationErrors;
            stats.m_lastInvocationErrors=stats.m_invocationErrors;
            roundTripTime=stats.m_roundTripTime - stats.m_lastRoundTripTime;
            stats.m_lastRoundTripTime=stats.m_roundTripTime;
            maxRoundTripTime=stats.m_lastMaxRoundTripTime;
            minRoundTripTime=stats.m_lastMinRoundTripTime;
            stats.m_lastMaxRoundTripTime=Integer.MIN_VALUE;
            stats.m_lastMinRoundTripTime=Integer.MAX_VALUE;
            clusterRoundTripTime=stats.m_clusterRoundTripTime - stats.m_lastClusterRoundTripTime;
            stats.m_lastClusterRoundTripTime=stats.m_clusterRoundTripTime;
            clusterMaxRoundTripTime=stats.m_lastMaxClusterRoundTripTime;
            clusterMinRoundTripTime=stats.m_lastMinClusterRoundTripTime;
            stats.m_lastMaxClusterRoundTripTime=Integer.MIN_VALUE;
            stats.m_lastMinClusterRoundTripTime=Integer.MAX_VALUE;
          }
          totalInvocations+=invocationsCompleted;
          totalAbortedInvocations+=invocationAborts;
          totalFailedInvocations+=invocationErrors;
          totalRoundTripTime+=roundTripTime;
          totalRoundTripMax=Math.max(maxRoundTripTime,totalRoundTripMax);
          totalRoundTripMin=Math.min(minRoundTripTime,totalRoundTripMin);
          totalClusterRoundTripTime+=clusterRoundTripTime;
          totalClusterRoundTripMax=Math.max(clusterMaxRoundTripTime,totalClusterRoundTripMax);
          totalClusterRoundTripMin=Math.min(clusterMinRoundTripTime,totalClusterRoundTripMin);
          retval.addRow(now,m_hostname,cxn.connectionId(),cxn.m_hostId,cxn.m_hostname,cxn.m_connectionId,stats.m_name,(int)(roundTripTime / invocationsCompleted),minRoundTripTime,maxRoundTripTime,(int)(clusterRoundTripTime / invocationsCompleted),clusterMinRoundTripTime,clusterMaxRoundTripTime,invocationsCompleted,invocationAborts,invocationErrors);
        }
      }
    }
  }
  return retval;
}
