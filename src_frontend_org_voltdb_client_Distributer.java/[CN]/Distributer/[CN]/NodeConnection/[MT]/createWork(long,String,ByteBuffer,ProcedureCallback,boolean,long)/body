{
  assert(callback != null);
  long nowNanos=System.nanoTime();
  nowNanos=m_rateLimiter.sendTxnWithOptionalBlockAndReturnCurrentTime(nowNanos,ignoreBackpressure);
  timeoutNanos=(timeoutNanos == Distributer.USE_DEFAULT_TIMEOUT) ? m_procedureCallTimeoutNanos : timeoutNanos;
  assert(m_callbacks.containsKey(handle) == false);
  m_callbacks.put(handle,new CallbackBookeeping(nowNanos,callback,name,timeoutNanos));
  if (timeoutNanos < TimeUnit.SECONDS.toNanos(1)) {
    submitTimeoutTask(handle,timeoutNanos);
  }
  if (!m_isConnected) {
    if (m_callbacks.remove(handle) == null)     return;
    final ClientResponse r=new ClientResponseImpl(ClientResponse.CONNECTION_LOST,new VoltTable[0],"Connection to database host (" + m_connection.getHostnameAndIPAndPort() + ") was lost before a response was received");
    try {
      callback.clientCallback(r);
    }
 catch (    Exception e) {
      uncaughtException(callback,r,e);
    }
    m_rateLimiter.transactionResponseReceived(nowNanos,-1);
    return;
  }
 else {
    m_connection.writeStream().enqueue(c);
  }
}
