{
  super.stopping(c);
synchronized (this) {
synchronized (Distributer.this) {
      Iterator<Map.Entry<Integer,NodeConnection>> i=m_partitionMasters.entrySet().iterator();
      while (i.hasNext()) {
        Map.Entry<Integer,NodeConnection> entry=i.next();
        if (entry.getValue() == this) {
          i.remove();
        }
      }
      i=m_hostIdToConnection.entrySet().iterator();
      while (i.hasNext()) {
        Map.Entry<Integer,NodeConnection> entry=i.next();
        if (entry.getValue() == this) {
          i.remove();
        }
      }
      Iterator<Map.Entry<Integer,NodeConnection[]>> i2=m_partitionReplicas.entrySet().iterator();
      List<Pair<Integer,NodeConnection[]>> entriesToRewrite=new ArrayList<Pair<Integer,NodeConnection[]>>();
      while (i2.hasNext()) {
        Map.Entry<Integer,NodeConnection[]> entry=i2.next();
        for (        NodeConnection nc : entry.getValue()) {
          if (nc == this) {
            entriesToRewrite.add(Pair.of(entry.getKey(),entry.getValue()));
          }
        }
      }
      for (      Pair<Integer,NodeConnection[]> entry : entriesToRewrite) {
        m_partitionReplicas.remove(entry.getFirst());
        NodeConnection survivors[]=new NodeConnection[entry.getSecond().length - 1];
        if (survivors.length == 0)         break;
        int zz=0;
        for (int ii=0; ii < entry.getSecond().length; ii++) {
          if (entry.getSecond()[ii] != this) {
            survivors[zz++]=entry.getSecond()[ii];
          }
        }
        m_partitionReplicas.put(entry.getFirst(),survivors);
      }
      m_connections.remove(this);
      for (      ClientStatusListenerExt s : m_listeners) {
        s.connectionLost(m_hostname,m_port,m_connections.size(),m_closeCause);
      }
    }
    m_isConnected=false;
    final ClientResponse r=new ClientResponseImpl(ClientResponse.CONNECTION_LOST,new VoltTable[0],"Connection to database host (" + m_socketAddress + ") was lost before a response was received");
    for (    final CallbackBookeeping callBk : m_callbacks.values()) {
      try {
        callBk.callback.clientCallback(r);
      }
 catch (      Exception e) {
        uncaughtException(callBk.callback,r,e);
      }
      m_rateLimiter.transactionResponseReceived(System.currentTimeMillis(),-1);
      m_callbacksToInvoke.decrementAndGet();
    }
    m_callbacks.clear();
  }
}
