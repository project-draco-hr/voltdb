{
  assert(callback != null);
  timeoutNanos=(timeoutNanos == Distributer.USE_DEFAULT_TIMEOUT) ? m_procedureCallTimeoutNanos : timeoutNanos;
  final long timeoutTime=nowNanos + timeoutNanos;
  long afterRateLimitNanos=0;
  if (!ignoreBackpressure) {
    try {
      afterRateLimitNanos=m_rateLimiter.sendTxnWithOptionalBlockAndReturnCurrentTime(nowNanos,timeoutNanos,ignoreBackpressure);
    }
 catch (    TimeoutException e) {
      final long deltaNanos=Math.max(1,System.nanoTime() - nowNanos);
      ClientResponseImpl r=new ClientResponseImpl(ClientResponse.CONNECTION_TIMEOUT,ClientResponse.UNINITIALIZED_APP_STATUS_CODE,"",new VoltTable[0],String.format("Timed out acquiring outstanding transaction permit (set to %d ms).",TimeUnit.NANOSECONDS.toMillis(timeoutNanos)));
      r.setClientHandle(handle);
      r.setClientRoundtrip(deltaNanos);
      r.setClusterRoundtrip((int)TimeUnit.NANOSECONDS.toMillis(deltaNanos));
      try {
        callback.clientCallback(r);
      }
 catch (      Exception e3) {
        uncaughtException(callback,r,e);
      }
      return;
    }
  }
  assert(m_callbacks.containsKey(handle) == false);
  final int callbacksToInvoke=m_callbacksToInvoke.incrementAndGet();
  assert(callbacksToInvoke >= 0);
  m_callbacks.put(handle,new CallbackBookeeping(nowNanos,callback,name,timeoutNanos,ignoreBackpressure));
  final long timeoutRemaining=timeoutTime - afterRateLimitNanos;
  if (timeoutNanos < TimeUnit.SECONDS.toNanos(1)) {
    submitTimeoutTask(handle,Math.max(0,timeoutRemaining));
  }
  if (!m_isConnected) {
    if (m_callbacks.remove(handle) == null)     return;
    final ClientResponse r=new ClientResponseImpl(ClientResponse.CONNECTION_LOST,new VoltTable[0],"Connection to database host (" + m_connection.getHostnameAndIPAndPort() + ") was lost before a response was received");
    try {
      callback.clientCallback(r);
    }
 catch (    Exception e) {
      uncaughtException(callback,r,e);
    }
    final int remainingToInvoke=m_callbacksToInvoke.decrementAndGet();
    assert(remainingToInvoke >= 0);
    if (!ignoreBackpressure) {
      m_rateLimiter.transactionResponseReceived(nowNanos,-1);
    }
    return;
  }
 else {
    m_connection.writeStream().enqueue(c);
  }
}
