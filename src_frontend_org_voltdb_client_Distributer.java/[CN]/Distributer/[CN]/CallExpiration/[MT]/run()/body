{
  try {
    ArrayList<NodeConnection> connections=new ArrayList<NodeConnection>();
synchronized (Distributer.this) {
      connections.addAll(m_connections);
    }
    final long nowNanos=System.nanoTime();
    for (    final NodeConnection c : connections) {
      final long sinceLastResponse=Math.max(1,nowNanos - c.m_lastResponseTimeNanos);
      if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutNanos)) {
        c.m_closeCause=DisconnectCause.TIMEOUT;
        c.m_connection.unregister();
      }
      if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutNanos / 3))) {
        c.sendPing();
      }
      for (      final Map.Entry<Long,CallbackBookeeping> e : c.m_callbacks.entrySet()) {
        final long handle=e.getKey();
        final CallbackBookeeping cb=e.getValue();
        final long deltaNanos=Math.max(1,nowNanos - cb.timestampNanos);
        if (deltaNanos > cb.procedureTimeoutNanos) {
          boolean isLongOp=false;
          isLongOp|=cb.name.equals("@UpdateApplicationCatalog");
          isLongOp|=cb.name.equals("@SnapshotSave");
          if (isLongOp && (deltaNanos < TimeUnit.MILLISECONDS.toNanos(MINIMUM_LONG_RUNNING_SYSTEM_CALL_TIMEOUT_MS))) {
            continue;
          }
          if (c.m_callbacks.remove(handle) == null)           continue;
          final ClientResponseImpl r=new ClientResponseImpl(ClientResponse.CONNECTION_TIMEOUT,ClientResponse.UNINITIALIZED_APP_STATUS_CODE,"",new VoltTable[0],String.format("No response received in the allotted time (set to %d ms).",TimeUnit.NANOSECONDS.toMillis(cb.procedureTimeoutNanos)));
          r.setClientHandle(handle);
          r.setClientRoundtrip(deltaNanos);
          r.setClusterRoundtrip((int)TimeUnit.NANOSECONDS.toMillis(deltaNanos));
          try {
            cb.callback.clientCallback(r);
          }
 catch (          Exception e1) {
            uncaughtException(cb.callback,r,e1);
          }
          if (!cb.ignoreBackpressure) {
            m_rateLimiter.transactionResponseReceived(nowNanos,-1);
          }
        }
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}
