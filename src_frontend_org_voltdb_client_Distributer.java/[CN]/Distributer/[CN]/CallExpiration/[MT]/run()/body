{
  List<Runnable> callbacksToDeliver=new ArrayList<Runnable>();
  try {
    ArrayList<NodeConnection> connections=new ArrayList<NodeConnection>();
synchronized (Distributer.this) {
      connections.addAll(m_connections);
    }
    long nowNanos=System.nanoTime();
    for (    NodeConnection c : connections) {
synchronized (c) {
        long sinceLastResponse=Math.max(1,nowNanos - c.m_lastResponseTimeNanos);
        if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutNanos)) {
          c.m_closeCause=DisconnectCause.TIMEOUT;
          c.m_connection.unregister();
        }
        if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutNanos / 3))) {
          c.sendPing();
        }
        Iterator<Entry<Long,CallbackBookeeping>> iter=c.m_callbacks.entrySet().iterator();
        while (iter.hasNext()) {
          Entry<Long,CallbackBookeeping> e=iter.next();
          long handle=e.getKey();
          final CallbackBookeeping cb=e.getValue();
          final long deltaNanos=Math.max(1,nowNanos - cb.timestampNanos);
          if (deltaNanos > cb.m_procedureTimeoutNanos) {
            boolean isLongOp=false;
            isLongOp|=cb.name.equals("@UpdateApplicationCatalog");
            isLongOp|=cb.name.equals("@SnapshotSave");
            if (isLongOp && (deltaNanos < TimeUnit.MILLISECONDS.toNanos(MINIMUM_LONG_RUNNING_SYSTEM_CALL_TIMEOUT_MS))) {
              continue;
            }
            final ClientResponseImpl r=new ClientResponseImpl(ClientResponse.CONNECTION_TIMEOUT,ClientResponse.UNINITIALIZED_APP_STATUS_CODE,"",new VoltTable[0],String.format("No response received in the allotted time (set to %d ms).",TimeUnit.NANOSECONDS.toMillis(cb.m_procedureTimeoutNanos)));
            r.setClientHandle(handle);
            r.setClientRoundtrip(deltaNanos);
            callbacksToDeliver.add(new Runnable(){
              @Override public void run(){
                try {
                  cb.callback.clientCallback(r);
                }
 catch (                Exception e1) {
                  e1.printStackTrace();
                }
              }
            }
);
            iter.remove();
            m_rateLimiter.transactionResponseReceived(nowNanos,-1);
            int callbacksToInvoke=c.m_callbacksToInvoke.decrementAndGet();
            assert(callbacksToInvoke >= 0);
          }
        }
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  for (  Runnable r : callbacksToDeliver) {
    r.run();
  }
}
