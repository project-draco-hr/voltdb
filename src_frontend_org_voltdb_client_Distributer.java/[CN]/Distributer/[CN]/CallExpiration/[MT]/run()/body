{
  try {
    ArrayList<NodeConnection> connections=new ArrayList<NodeConnection>();
synchronized (Distributer.this) {
      connections.addAll(m_connections);
    }
    long now=System.currentTimeMillis();
    for (    NodeConnection c : connections) {
synchronized (c) {
        long sinceLastResponse=now - c.m_lastResponseTime;
        if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutMS)) {
          c.m_closeCause=DisconnectCause.TIMEOUT;
          c.m_connection.unregister();
        }
        if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutMS / 3))) {
          c.sendPing();
        }
        Iterator<Entry<Long,CallbackBookeeping>> iter=c.m_callbacks.entrySet().iterator();
        while (iter.hasNext()) {
          Entry<Long,CallbackBookeeping> e=iter.next();
          long handle=e.getKey();
          CallbackBookeeping cb=e.getValue();
          if ((now - cb.timestamp) > m_procedureCallTimeoutMS) {
            boolean isLongOp=false;
            isLongOp|=cb.name.equals("@UpdateApplicationCatalog");
            isLongOp|=cb.name.equals("@SnapshotSave");
            if (isLongOp && ((now - cb.timestamp) < MINIMUM_CATALOG_UPDATE_TIMEOUT_MS)) {
              break;
            }
            ClientResponseImpl r=new ClientResponseImpl(ClientResponse.CONNECTION_TIMEOUT,ClientResponse.UNINITIALIZED_APP_STATUS_CODE,"",new VoltTable[0],String.format("No response received in the allotted time (set to %d ms).",m_procedureCallTimeoutMS));
            r.setClientHandle(handle);
            r.setClientRoundtrip((int)(now - cb.timestamp));
            r.setClusterRoundtrip((int)(now - cb.timestamp));
            try {
              cb.callback.clientCallback(r);
            }
 catch (            Exception e1) {
              e1.printStackTrace();
            }
            iter.remove();
            m_rateLimiter.transactionResponseReceived(now,-1);
            int callbacksToInvoke=c.m_callbacksToInvoke.decrementAndGet();
            assert(callbacksToInvoke >= 0);
          }
        }
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}
