{
  if (where == null)   return;
  ArrayDeque<AbstractExpression> in=new ArrayDeque<AbstractExpression>();
  ArrayDeque<AbstractExpression> out=new ArrayDeque<AbstractExpression>();
  in.add(where);
  AbstractExpression inExpr=null;
  while ((inExpr=in.poll()) != null) {
    if (inExpr.getExpressionType() == ExpressionType.CONJUNCTION_AND) {
      in.add(inExpr.getLeft());
      in.add(inExpr.getRight());
    }
 else {
      out.add(inExpr);
    }
  }
  whereSelectionList.addAll(out);
  HashSet<Table> tableSet=new HashSet<Table>();
  for (  AbstractExpression expr : whereSelectionList) {
    tableSet.clear();
    getTablesForExpression(db,expr,tableSet);
    if (tableSet.size() == 0) {
      noTableSelectionList.add(expr);
    }
 else     if (tableSet.size() == 1) {
      Table table=(Table)tableSet.toArray()[0];
      ArrayList<AbstractExpression> exprs;
      if (tableFilterList.containsKey(table)) {
        exprs=tableFilterList.get(table);
      }
 else {
        exprs=new ArrayList<AbstractExpression>();
        tableFilterList.put(table,exprs);
      }
      expr.m_isJoiningClause=false;
      addExprToEquivalenceSets(expr);
      exprs.add(expr);
    }
 else     if (tableSet.size() == 2) {
      TablePair pair=new TablePair();
      pair.t1=(Table)tableSet.toArray()[0];
      pair.t2=(Table)tableSet.toArray()[1];
      ArrayList<AbstractExpression> exprs;
      if (joinSelectionList.containsKey(pair)) {
        exprs=joinSelectionList.get(pair);
      }
 else {
        exprs=new ArrayList<AbstractExpression>();
        joinSelectionList.put(pair,exprs);
      }
      expr.m_isJoiningClause=true;
      addExprToEquivalenceSets(expr);
      exprs.add(expr);
    }
 else     if (tableSet.size() > 2) {
      multiTableSelectionList.add(expr);
    }
  }
}
