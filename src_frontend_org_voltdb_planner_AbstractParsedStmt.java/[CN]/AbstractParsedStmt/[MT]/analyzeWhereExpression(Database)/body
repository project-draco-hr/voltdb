{
  if (where == null)   return;
  ArrayDeque<AbstractExpression> in=new ArrayDeque<AbstractExpression>();
  ArrayDeque<AbstractExpression> out=new ArrayDeque<AbstractExpression>();
  in.add(where);
  int loopOps;
  do {
    loopOps=0;
    AbstractExpression inExpr=null;
    while ((inExpr=in.poll()) != null) {
      if (inExpr.getExpressionType() == ExpressionType.CONJUNCTION_AND) {
        out.add(inExpr.getLeft());
        out.add(inExpr.getRight());
        loopOps++;
      }
 else {
        out.add(inExpr);
      }
    }
    ArrayDeque<AbstractExpression> temp=in;
    in=out;
    out=temp;
  }
 while (loopOps > 0);
  whereSelectionList.addAll(in);
  HashSet<Table> tableSet=new HashSet<Table>();
  for (  AbstractExpression expr : whereSelectionList) {
    tableSet.clear();
    getTablesForExpression(db,expr,tableSet);
    if (tableSet.size() == 0) {
      noTableSelectionList.add(expr);
    }
 else     if (tableSet.size() == 1) {
      Table table=(Table)tableSet.toArray()[0];
      ArrayList<AbstractExpression> exprs;
      if (tableFilterList.containsKey(table)) {
        exprs=tableFilterList.get(table);
      }
 else {
        exprs=new ArrayList<AbstractExpression>();
        tableFilterList.put(table,exprs);
      }
      exprs.add(expr);
    }
 else     if (tableSet.size() == 2) {
      TablePair pair=new TablePair();
      pair.t1=(Table)tableSet.toArray()[0];
      pair.t2=(Table)tableSet.toArray()[1];
      ArrayList<AbstractExpression> exprs;
      if (joinSelectionList.containsKey(pair)) {
        exprs=joinSelectionList.get(pair);
      }
 else {
        exprs=new ArrayList<AbstractExpression>();
        joinSelectionList.put(pair,exprs);
      }
      exprs.add(expr);
    }
 else     if (tableSet.size() > 2) {
      multiTableSelectionList.add(expr);
    }
  }
}
