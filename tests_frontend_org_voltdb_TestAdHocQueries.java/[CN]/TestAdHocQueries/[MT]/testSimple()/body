{
  Configuration config=new Configuration();
  config.m_backend=BackendTarget.NATIVE_EE_JNI;
  config.m_noLoadLibVOLTDB=false;
  config.setPathToCatalogForTest("tpcc.jar");
  TPCCProjectBuilder project=new TPCCProjectBuilder();
  project.addDefaultSchema();
  project.addDefaultPartitioning();
  project.addProcedures(org.voltdb.compiler.procedures.EmptyProcedure.class);
  assertTrue(project.compile(config.m_pathToCatalog,2,0));
  config.m_pathToDeployment=project.getPathToDeployment();
  ServerThread server=new ServerThread(config);
  server.start();
  server.waitForInitialization();
  ClientConfig clientConfig=new ClientConfig("program","password");
  Client client=ClientFactory.createClient(clientConfig);
  client.createConnection("localhost");
  VoltTable modCount=client.callProcedure("@AdHoc","INSERT INTO NEW_ORDER VALUES (1, 1, 1);").getResults()[0];
  assertTrue(modCount.getRowCount() == 1);
  assertTrue(modCount.asScalarLong() == 1);
  VoltTable result=client.callProcedure("@AdHoc","SELECT * FROM NEW_ORDER;").getResults()[0];
  assertTrue(result.getRowCount() == 1);
  System.out.println(result.toString());
  result=client.callProcedure("@AdHoc","SELECT * FROM NEW_ORDER;",0).getResults()[0];
  assertTrue(result.getRowCount() == 0);
  System.out.println(result.toString());
  result=client.callProcedure("@AdHoc","SELECT * FROM NEW_ORDER;",1).getResults()[0];
  assertTrue(result.getRowCount() == 1);
  System.out.println(result.toString());
  try {
    client.callProcedure("@AdHoc","INSERT INTO NEW_ORDER VALUES (0, 0, 0);",1);
    fail("Badly partitioned insert failed to throw expected exception");
  }
 catch (  Exception e) {
  }
  try {
    client.callProcedure("@AdHoc","SLEECT * FROOM NEEEW_OOORDERERER;");
    fail("Bad SQL failed to throw expected exception");
  }
 catch (  Exception e) {
  }
  server.shutdown();
  server.join();
  assertTrue(true);
}
