{
  super.initFromBuffer();
  short fragCount=m_buffer.getShort();
  if (fragCount > 0) {
    m_fragmentIds=new long[fragCount];
    for (int i=0; i < fragCount; i++)     m_fragmentIds[i]=m_buffer.getLong();
    m_parameterSets=new ByteBuffer[fragCount];
    for (int i=0; i < fragCount; i++) {
      int paramsbytecount=m_buffer.getInt();
      m_parameterSets[i]=ByteBuffer.allocate(paramsbytecount);
      int cachedLimit=m_buffer.limit();
      m_buffer.limit(m_buffer.position() + m_parameterSets[i].remaining());
      m_parameterSets[i].put(m_buffer);
      m_parameterSets[i].flip();
      m_buffer.limit(cachedLimit);
    }
  }
  short expectedDepCount=m_buffer.getShort();
  if (expectedDepCount > 0) {
    m_outputDepIds=new int[expectedDepCount];
    for (int i=0; i < expectedDepCount; i++)     m_outputDepIds[i]=m_buffer.getInt();
  }
  short inputDepCount=m_buffer.getShort();
  if (inputDepCount > 0) {
    m_inputDepIds=new ArrayList<?>[inputDepCount];
    for (int i=0; i < inputDepCount; i++) {
      short count=m_buffer.getShort();
      if (count > 0) {
        ArrayList<Integer> l=new ArrayList<Integer>();
        for (int j=0; j < count; j++) {
          l.add(m_buffer.getInt());
          m_inputDepCount++;
        }
        m_inputDepIds[i]=l;
      }
    }
  }
  m_isFinal=m_buffer.get() == 1;
  m_taskType=m_buffer.get();
  m_shouldUndo=m_buffer.get() == 1;
  assert(m_isHeartBeat == false);
}
