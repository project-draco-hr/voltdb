{
  super.flattenToBuffer(pool);
  assert(m_buffer != null);
  int startPos=m_buffer.limit();
  int msgsize=m_buffer.limit() - (HEADER_SIZE + 1);
  msgsize+=2 + 2 + 2+ 1+ 1+ 1;
  if (m_fragmentIds != null) {
    msgsize+=8 * m_fragmentIds.length;
    for (int i=0; i < m_fragmentIds.length; i++)     msgsize+=4 + m_parameterSets[i].remaining();
  }
  if (m_inputDepIds != null) {
    msgsize+=4 * m_inputDepIds.length;
  }
  if (m_outputDepIds != null) {
    msgsize+=4 * m_outputDepIds.length;
  }
  setBufferSize(msgsize + 1,pool);
  m_buffer.position(HEADER_SIZE);
  m_buffer.put(FRAGMENT_TASK_ID);
  m_buffer.position(startPos);
  if (m_fragmentIds == null) {
    m_buffer.putShort((short)0);
  }
 else {
    m_buffer.putShort((short)m_fragmentIds.length);
    for (int i=0; i < m_fragmentIds.length; i++) {
      m_buffer.putLong(m_fragmentIds[i]);
    }
    for (int i=0; i < m_fragmentIds.length; i++) {
      m_buffer.putInt(m_parameterSets[i].remaining());
      m_buffer.put(m_parameterSets[i].duplicate());
    }
  }
  if (m_outputDepIds == null) {
    m_buffer.putShort((short)0);
  }
 else {
    m_buffer.putShort((short)m_outputDepIds.length);
    for (int i=0; i < m_outputDepIds.length; i++) {
      m_buffer.putInt(m_outputDepIds[i]);
    }
  }
  if (m_inputDepIds == null) {
    m_buffer.putShort((short)0);
  }
 else {
    m_buffer.putShort((short)m_inputDepIds.length);
    for (int i=0; i < m_inputDepIds.length; i++) {
      @SuppressWarnings("unchecked") ArrayList<Integer> l=(ArrayList<Integer>)m_inputDepIds[i];
      m_buffer.putShort((short)l.size());
      for (      int depId : l)       m_buffer.putInt(depId);
    }
  }
  m_buffer.put(m_isFinal ? (byte)1 : (byte)0);
  m_buffer.put(m_taskType);
  m_buffer.put(m_shouldUndo ? (byte)1 : (byte)0);
  m_buffer.limit(m_buffer.position());
}
