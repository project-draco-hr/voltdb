{
  AbstractPlanNode.enableVerboseExplainForDebugging();
  IndexScanPlanNode c;
  AbstractPlanNode apn;
  AbstractPlanNode pn;
  NestLoopIndexPlanNode nlij;
  List<AbstractExpression> searchKeys;
  apn=compile("select * FROM R2 A, R2 B WHERE A.A = B.A AND B.C > 1 ORDER BY B.C");
  pn=apn.getChild(0).getChild(0);
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select * FROM R2 A, R2 B WHERE A.A = B.A AND B.C > 1 ORDER BY B.A, B.C");
  pn=apn.getChild(0).getChild(0);
  assertTrue(pn instanceof OrderByPlanNode);
  pn=pn.getChild(0);
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select * FROM R2 A, R2 B WHERE A.A = B.A AND B.A > 1 ORDER BY B.A, B.C");
  pn=apn.getChild(0).getChild(0);
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  assertTrue(nlij.getChild(0) instanceof IndexScanPlanNode);
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C, MAX(A.C) FROM R2 A, R2 B WHERE A.A = B.A AND B.C > 1 GROUP BY B.C ORDER BY B.C");
  pn=apn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C, B.A FROM R2 A, R2 B WHERE A.A = B.A AND B.C > 1 GROUP BY B.A, B.C ORDER BY B.A, B.C");
  pn=apn.getChild(0).getChild(0);
  assertTrue(pn instanceof OrderByPlanNode);
  pn=pn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C, B.A FROM R2 A, R2 B WHERE A.A = B.A AND B.A > 1 GROUP BY B.A, B.C ORDER BY B.A, B.C");
  pn=apn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  assertTrue(nlij.getChild(0) instanceof IndexScanPlanNode);
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C FROM R2 A, R2 B WHERE B.A = A.A AND B.C > 1 GROUP BY A.A, B.C ORDER BY A.A, B.C");
  pn=apn.getChild(0);
  assertTrue(pn instanceof ProjectionPlanNode);
  pn=pn.getChild(0);
  assertTrue(pn instanceof OrderByPlanNode);
  pn=pn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C FROM R2 A, R2 B WHERE B.A = A.A AND B.C > 1 GROUP BY A.A, B.C ORDER BY B.C");
  pn=apn.getChild(0);
  assertTrue(pn instanceof OrderByPlanNode);
  pn=pn.getChild(0);
  assertTrue(pn instanceof ProjectionPlanNode);
  pn=pn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertNull(c.getPredicate());
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
  apn=compile("select B.C, B.A FROM R2 A, R2 B WHERE A.A = B.A AND B.A > 1 GROUP BY B.C, B.A ORDER BY B.A, B.C");
  pn=apn.getChild(0);
  assertNotNull(AggregatePlanNode.getInlineAggregationNode(pn));
  assertTrue(pn instanceof NestLoopIndexPlanNode);
  nlij=(NestLoopIndexPlanNode)pn;
  assertNull(nlij.getPreJoinPredicate());
  assertNull(nlij.getJoinPredicate());
  assertNull(nlij.getWherePredicate());
  assertEquals(1,nlij.getChildCount());
  assertTrue(nlij.getChild(0) instanceof IndexScanPlanNode);
  c=(IndexScanPlanNode)nlij.getChild(0);
  assertEquals(IndexLookupType.GT,c.getLookupType());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof ConstantValueExpression);
  c=(IndexScanPlanNode)nlij.getInlinePlanNode(PlanNodeType.INDEXSCAN);
  assertEquals(IndexLookupType.GTE,c.getLookupType());
  assertNull(c.getPredicate());
  searchKeys=c.getSearchKeyExpressions();
  assertEquals(1,searchKeys.size());
  assertTrue(searchKeys.get(0) instanceof TupleValueExpression);
}
