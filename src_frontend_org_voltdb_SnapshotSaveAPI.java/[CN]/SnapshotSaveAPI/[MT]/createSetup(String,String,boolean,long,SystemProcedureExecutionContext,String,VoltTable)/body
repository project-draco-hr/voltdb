{
{
    final int numLocalSites=VoltDB.instance().getLocalSites().values().size();
    SiteTracker tracker=context.getExecutionSite().m_tracker;
    List<Integer> partitionsToInclude=new ArrayList<Integer>();
    List<Long> sitesToInclude=new ArrayList<Long>();
    for (    long localSite : tracker.getLocalSites()) {
      final int partitionId=tracker.getPartitionForSite(localSite);
      List<Long> sites=new ArrayList<Long>(tracker.getSitesForPartition(tracker.getPartitionForSite(localSite)));
      Collections.sort(sites);
      int siteIndex=new java.util.Random(partitionId).nextInt(sites.size());
      if (localSite == sites.get(siteIndex)) {
        partitionsToInclude.add(partitionId);
        sitesToInclude.add(localSite);
      }
    }
    assert(partitionsToInclude.size() == sitesToInclude.size());
    final ArrayList<SnapshotDataTarget> targets=new ArrayList<SnapshotDataTarget>();
    try {
      final ArrayDeque<SnapshotTableTask> partitionedSnapshotTasks=new ArrayDeque<SnapshotTableTask>();
      final ArrayList<SnapshotTableTask> replicatedSnapshotTasks=new ArrayList<SnapshotTableTask>();
      assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() == -1);
      final List<Table> tables=SnapshotUtil.getTablesToSave(context.getDatabase());
      Runnable completionTask=SnapshotUtil.writeSnapshotDigest(txnId,context.getExecutionSite().m_context.getCatalogCRC(),file_path,file_nonce,tables,context.getExecutionSite().getCorrespondingHostId(),SnapshotSiteProcessor.getExportSequenceNumbers());
      if (completionTask != null) {
        SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);
      }
      completionTask=SnapshotUtil.writeSnapshotCatalog(file_path,file_nonce);
      if (completionTask != null) {
        SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);
      }
      final AtomicInteger numTables=new AtomicInteger(tables.size());
      final SnapshotRegistry.Snapshot snapshotRecord=SnapshotRegistry.startSnapshot(txnId,context.getExecutionSite().getCorrespondingHostId(),file_path,file_nonce,csv,tables.toArray(new Table[0]));
      for (      final Table table : SnapshotUtil.getTablesToSave(context.getDatabase())) {
        if (csv && table.getIsreplicated() && !tracker.isFirstHost()) {
          continue;
        }
        String canSnapshot="SUCCESS";
        String err_msg="";
        final File saveFilePath=SnapshotUtil.constructFileForTable(table,file_path,file_nonce,csv ? ".csv" : ".vpt",context.getHostId());
        SnapshotDataTarget sdt=null;
        try {
          if (csv) {
            sdt=new SimpleFileSnapshotDataTarget(saveFilePath);
          }
 else {
            sdt=constructSnapshotDataTargetForTable(context,saveFilePath,table,context.getHostId(),context.getSiteTracker().m_numberOfPartitions,txnId);
          }
          targets.add(sdt);
          final SnapshotDataTarget sdtFinal=sdt;
          final Runnable onClose=new Runnable(){
            @Override public void run(){
              snapshotRecord.updateTable(table.getTypeName(),new SnapshotRegistry.Snapshot.TableUpdater(){
                @Override public SnapshotRegistry.Snapshot.Table update(                SnapshotRegistry.Snapshot.Table registryTable){
                  return snapshotRecord.new Table(registryTable,sdtFinal.getBytesWritten(),sdtFinal.getLastWriteException());
                }
              }
);
              int tablesLeft=numTables.decrementAndGet();
              if (tablesLeft == 0) {
                final SnapshotRegistry.Snapshot completed=SnapshotRegistry.finishSnapshot(snapshotRecord);
                final double duration=(completed.timeFinished - org.voltdb.TransactionIdManager.getTimestampFromTransactionId(completed.txnId)) / 1000.0;
                HOST_LOG.info("Snapshot " + snapshotRecord.nonce + " finished at "+ completed.timeFinished+ " and took "+ duration+ " seconds ");
              }
            }
          }
;
          sdt.setOnCloseHandler(onClose);
          List<SnapshotDataFilter> filters=new ArrayList<SnapshotDataFilter>();
          if (csv) {
            filters.add(new PartitionProjectionSnapshotFilter(Ints.toArray(partitionsToInclude),0));
            filters.add(new CSVSnapshotFilter(CatalogUtil.getVoltTable(table),',',null));
          }
          final SnapshotTableTask task=new SnapshotTableTask(table.getRelativeIndex(),sdt,filters.toArray(new SnapshotDataFilter[filters.size()]),table.getIsreplicated(),table.getTypeName());
          if (table.getIsreplicated()) {
            replicatedSnapshotTasks.add(task);
          }
 else {
            partitionedSnapshotTasks.offer(task);
          }
        }
 catch (        IOException ex) {
          try {
            if (sdt != null) {
              targets.remove(sdt);
              sdt.close();
            }
          }
 catch (          Exception e) {
            HOST_LOG.error(e);
          }
          StringWriter sw=new StringWriter();
          PrintWriter pw=new PrintWriter(sw);
          ex.printStackTrace(pw);
          pw.flush();
          canSnapshot="FAILURE";
          err_msg="SNAPSHOT INITIATION OF " + saveFilePath + "RESULTED IN IOException: \n"+ sw.toString();
        }
        result.addRow(context.getHostId(),hostname,table.getTypeName(),canSnapshot,err_msg);
      }
synchronized (SnapshotSiteProcessor.m_taskListsForSites) {
        boolean aborted=false;
        if (!partitionedSnapshotTasks.isEmpty() || !replicatedSnapshotTasks.isEmpty()) {
          SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.set(VoltDB.instance().getLocalSites().values().size());
          for (int ii=0; ii < numLocalSites; ii++) {
            SnapshotSiteProcessor.m_taskListsForSites.add(new ArrayDeque<SnapshotTableTask>());
          }
        }
 else {
          SnapshotRegistry.discardSnapshot(snapshotRecord);
          aborted=true;
        }
        for (int ii=0; ii < numLocalSites && !partitionedSnapshotTasks.isEmpty(); ii++) {
          SnapshotSiteProcessor.m_taskListsForSites.get(ii).addAll(partitionedSnapshotTasks);
        }
        int siteIndex=0;
        for (        SnapshotTableTask t : replicatedSnapshotTasks) {
          SnapshotSiteProcessor.m_taskListsForSites.get(siteIndex++ % numLocalSites).offer(t);
        }
        if (!aborted) {
          logSnapshotStartToZK(txnId,context,file_nonce);
        }
      }
    }
 catch (    Exception ex) {
      SnapshotSiteProcessor.m_taskListsForSites.clear();
      for (      SnapshotDataTarget sdt : targets) {
        try {
          sdt.close();
        }
 catch (        Exception e) {
          HOST_LOG.error(ex);
        }
      }
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      ex.printStackTrace(pw);
      pw.flush();
      result.addRow(context.getHostId(),hostname,"","FAILURE","SNAPSHOT INITIATION OF " + file_path + file_nonce+ "RESULTED IN Exception: \n"+ sw.toString());
      HOST_LOG.error(ex);
    }
 finally {
      SnapshotSiteProcessor.m_snapshotPermits.release(numLocalSites);
    }
  }
}
