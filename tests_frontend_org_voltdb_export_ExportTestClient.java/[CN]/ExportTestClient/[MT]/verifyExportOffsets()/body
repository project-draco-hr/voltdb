{
  boolean retval=true;
  HashMap<String,HashMap<Integer,Long>> table_offsets=new HashMap<String,HashMap<Integer,Long>>();
  for (  ExportConnection connection : m_exportConnections.values()) {
    HashMap<String,HashMap<Integer,Long>> seen_responses=new HashMap<String,HashMap<Integer,Long>>();
    for (    AdvertisedDataSource source : connection.dataSources) {
      try {
        ExportProtoMessage poll=new ExportProtoMessage(source.partitionId,source.signature);
        poll.poll();
        connection.sendMessage(poll);
        ExportProtoMessage m=null;
        while (m == null || !m.getSignature().equals(source.signature) || m.getPartitionId() != source.partitionId) {
          m=connection.nextMessage();
        }
        assert(m.isPollResponse());
        long offset=m.getAckOffset();
        HashMap<Integer,Long> offsets=table_offsets.get(m.m_signature);
        if (offsets == null) {
          offsets=new HashMap<Integer,Long>();
          table_offsets.put(m.m_signature,offsets);
        }
        if (!offsets.containsKey(source.partitionId)) {
          offsets.put(source.partitionId,offset);
        }
 else {
          if (offsets.get(source.partitionId) != offset) {
            System.out.println("Mismatched Export offset: " + offset);
            System.out.println("  Table ID: " + source.tableName);
            System.out.println("  Partition: " + source.partitionId);
            System.out.println("  Orig. offset: " + offsets.get(m.m_partitionId));
            retval=false;
          }
        }
        HashMap<Integer,Long> responses=seen_responses.get(m.m_signature);
        if (responses == null) {
          responses=new HashMap<Integer,Long>();
          seen_responses.put(m.m_signature,responses);
        }
        if (responses.containsKey(source.partitionId)) {
          System.out.println("Saw duplicate response from connection: " + connection.name);
          System.out.println("   for table: " + source.tableName + ", "+ source.partitionId);
          retval=false;
        }
 else {
          responses.put(source.partitionId,offset);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        System.exit(1);
      }
    }
    int seenResponseCount=0;
    for (    HashMap<Integer,Long> responses : seen_responses.values()) {
      seenResponseCount+=responses.size();
    }
    org.voltdb.VoltType type=VoltType.BIGINT;
switch (type) {
case BIGINT:
      break;
  }
  if (seenResponseCount != connection.dataSources.size()) {
    System.out.println("Didn't see enough responses from connection: " + connection.name + " saw "+ seen_responses.entrySet().size()+ " but expected "+ connection.dataSources.size());
    retval=false;
  }
}
return retval;
}
