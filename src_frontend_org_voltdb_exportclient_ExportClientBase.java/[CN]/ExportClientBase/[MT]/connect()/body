{
  if (m_connected.get()) {
    m_logger.error("Export client already connected.");
    throw new ExportClientException(ExportClientException.Type.USER_ERROR,"Export client already connected.");
  }
  if (m_servers.size() == 0) {
    m_logger.error("No servers provided for export client.");
    throw new ExportClientException(ExportClientException.Type.USER_ERROR,"No servers provided for export client.");
  }
  m_exportConnections.clear();
  boolean foundOneActiveServer=false;
  ArrayList<Pair<Exception,InetSocketAddress>> connectErrors=new ArrayList<Pair<Exception,InetSocketAddress>>();
  for (  InetSocketAddress serverAddr : m_servers) {
    ExportConnection exportConnection=null;
    try {
      exportConnection=new ExportConnection(m_username,m_password,serverAddr,m_sinks);
      exportConnection.openExportConnection();
      if (!exportConnection.isConnected())       continue;
      m_servers.clear();
      m_logger.info("Discovered topology " + exportConnection.hosts.toString());
      for (      String hostname : exportConnection.hosts) {
        assert(hostname.contains(":"));
        String[] parts=hostname.split(":");
        int port=m_useAdminPorts ? Integer.valueOf(parts[2]) : Integer.valueOf(parts[1]);
        InetSocketAddress addr=new InetSocketAddress(parts[0],port);
        m_servers.add(addr);
      }
      foundOneActiveServer=true;
      break;
    }
 catch (    IOException e) {
      if (e instanceof java.nio.channels.ClosedByInterruptException) {
        return false;
      }
      if (e.getMessage().contains("Export")) {
        throw new ExportClientException(ExportClientException.Type.AUTH_FAILURE,"Export is not enabled on this server.",e);
      }
 else       if (e.getMessage().contains("Authentication")) {
        throw new ExportClientException(ExportClientException.Type.AUTH_FAILURE,"Authentication failure",e);
      }
 else {
        connectErrors.add(Pair.of((Exception)e,serverAddr));
      }
    }
 finally {
      if (exportConnection != null)       exportConnection.closeExportConnection();
    }
  }
  if (!foundOneActiveServer) {
    for (    Pair<Exception,InetSocketAddress> p : connectErrors) {
      m_logger.warn("Failed to connect to server " + p.getSecond() + " with error: "+ p.getFirst().getMessage());
    }
    m_logger.warn("Unable to connect to a given server to discover the cluster topology");
    return false;
  }
  HashSet<AdvertisedDataSource> foundSources=new HashSet<AdvertisedDataSource>();
  for (int tryCount=0; tryCount < 3; tryCount++) {
    for (    InetSocketAddress addr : m_servers) {
      if (m_exportConnections.containsKey(addr))       continue;
      ExportConnection connection;
      try {
        connection=connectToServer(addr);
      }
 catch (      InterruptedException e) {
        disconnect();
        return false;
      }
      if (connection != null) {
        m_exportConnections.put(addr,connection);
        foundSources.addAll(connection.dataSources);
      }
    }
    if (m_servers.size() == m_exportConnections.size())     break;
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  if (m_servers.size() != m_exportConnections.size()) {
    disconnect();
    return false;
  }
  HashSet<AdvertisedDataSource> knownSources=new HashSet<AdvertisedDataSource>(m_knownDataSources);
  knownSources.removeAll(foundSources);
  for (  AdvertisedDataSource source : knownSources) {
    HashMap<String,HashMap<Integer,ExportDataSink>> gen_map=m_sinks.get(source.m_generation);
    HashMap<Integer,ExportDataSink> part_map=gen_map.get(source.signature);
    ExportDataSink sink=part_map.remove(source.partitionId);
    if (part_map.isEmpty()) {
      gen_map.remove(source.signature);
    }
    if (gen_map.isEmpty()) {
      m_sinks.remove(source.m_generation);
    }
    sink.sourceNoLongerAdvertised(source);
  }
  m_knownDataSources.clear();
  m_knownDataSources.addAll(foundSources);
  m_connected.set(true);
  return true;
}
