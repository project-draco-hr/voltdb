{
  try {
    Runtime.getRuntime().addShutdownHook(m_shutdownHook);
    long pollTimeMS=0;
    long now=System.currentTimeMillis();
    while ((timeout == 0) || ((System.currentTimeMillis() - now) < timeout)) {
      boolean connected=m_connected.get();
      int offeredMsgs=0;
      boolean disconnectedWithError=false;
      boolean disconnectedForUpdate=false;
      if (!connected) {
        try {
          connected=connect();
        }
 catch (        ExportClientException e) {
switch (e.type) {
case AUTH_FAILURE:
            throw e;
case DISCONNECT_UNEXPECTED:
          if (m_logger.isTraceEnabled()) {
            m_logger.warn(e.getMessage(),e);
          }
 else {
            m_logger.warn(e.getMessage());
          }
        disconnectedWithError=true;
      break;
case DISCONNECT_UPDATE:
    if (m_logger.isTraceEnabled()) {
      m_logger.info(e.getMessage(),e);
    }
 else {
      m_logger.info(e.getMessage());
    }
  disconnectedForUpdate=true;
break;
case USER_ERROR:
throw e;
}
}
}
if (connected) {
try {
offeredMsgs=work();
}
 catch (ExportClientException e) {
switch (e.type) {
case AUTH_FAILURE:
m_logger.fatal(e.getMessage(),e);
throw new RuntimeException("Got a unexpect auth error from connected server",e);
case DISCONNECT_UNEXPECTED:
if (m_logger.isTraceEnabled()) {
m_logger.warn(e.getMessage(),e);
}
 else {
m_logger.warn(e.getMessage());
}
disconnectedWithError=true;
break;
case DISCONNECT_UPDATE:
if (m_logger.isTraceEnabled()) {
m_logger.info(e.getMessage(),e);
}
 else {
m_logger.info(e.getMessage());
}
disconnectedForUpdate=true;
break;
case USER_ERROR:
throw e;
}
}
}
pollTimeMS=getNextPollDuration(pollTimeMS,offeredMsgs == 0,disconnectedWithError,disconnectedForUpdate);
if (pollTimeMS > 0) {
m_logger.trace(String.format("Sleeping for %d ms due to inactivity or no connection.",pollTimeMS));
try {
Thread.sleep(pollTimeMS);
}
 catch (InterruptedException e) {
throw new ExportClientException(e);
}
}
}
}
  finally {
Runtime.getRuntime().removeShutdownHook(m_shutdownHook);
}
}
