{
  super.initFromBuffer(buf);
  short fragCount=buf.getShort();
  if (fragCount > 0) {
    m_fragmentIds=new long[fragCount];
    for (int i=0; i < fragCount; i++)     m_fragmentIds[i]=buf.getLong();
    m_parameterSets=new ByteBuffer[fragCount];
    for (int i=0; i < fragCount; i++) {
      int paramsbytecount=buf.getInt();
      m_parameterSets[i]=ByteBuffer.allocate(paramsbytecount);
      int cachedLimit=buf.limit();
      buf.limit(buf.position() + m_parameterSets[i].remaining());
      m_parameterSets[i].put(buf);
      m_parameterSets[i].flip();
      buf.limit(cachedLimit);
    }
  }
  short expectedDepCount=buf.getShort();
  if (expectedDepCount > 0) {
    m_outputDepIds=new int[expectedDepCount];
    for (int i=0; i < expectedDepCount; i++)     m_outputDepIds[i]=buf.getInt();
  }
  short inputDepCount=buf.getShort();
  if (inputDepCount > 0) {
    m_inputDepIds=new ArrayList<?>[inputDepCount];
    for (int i=0; i < inputDepCount; i++) {
      short count=buf.getShort();
      if (count > 0) {
        ArrayList<Integer> l=new ArrayList<Integer>();
        for (int j=0; j < count; j++) {
          l.add(buf.getInt());
          m_inputDepCount++;
        }
        m_inputDepIds[i]=l;
      }
    }
  }
  m_isFinal=buf.get() == 1;
  m_taskType=buf.get();
  m_shouldUndo=buf.get() == 1;
}
