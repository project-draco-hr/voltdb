{
  int portNo=VoltDB.DEFAULT_PORT + hostId;
  int adminPortNo=m_baseAdminPort - hostId;
  int portNoToRejoin=VoltDB.DEFAULT_PORT + ((hostId + 1) % getNodeCount());
  if (m_hasLocalServer)   portNoToRejoin=VoltDB.DEFAULT_PORT;
  if (portOffset != null) {
    portNoToRejoin=VoltDB.DEFAULT_PORT + portOffset;
  }
  System.out.println("Rejoining " + hostId + " to hostID: "+ portOffset);
  ArrayList<EEProcess> eeProcs=m_eeProcs.get(hostId);
  for (  EEProcess proc : eeProcs) {
    try {
      proc.waitForShutdown();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  eeProcs.clear();
  for (int ii=0; ii < m_siteCount; ii++) {
    String logfile="LocalCluster_host_" + hostId + "_site"+ ii+ ".log";
    eeProcs.add(new EEProcess(m_target,logfile));
  }
  if (m_target.isIPC) {
    m_procBuilder.command().set(m_ipcPortOffset1,"ipcports");
    String portString="";
    for (    EEProcess proc : m_eeProcs.get(hostId)) {
      if (portString.isEmpty()) {
        portString+=Integer.valueOf(proc.port());
      }
 else {
        portString+="," + Integer.valueOf(proc.port());
      }
    }
    m_procBuilder.command().set(m_ipcPortOffset2,portString);
    m_procBuilder.command().set(m_ipcPortOffset3,"valgrind");
  }
  m_procBuilder.command().set(m_voltFilePrefixOffset,"-DVoltFilePrefix=" + m_subRoots.get(hostId).getPath());
  PipeToFile ptf=null;
  long start=0;
  try {
    m_procBuilder.command().set(m_portOffset,String.valueOf(portNo));
    m_procBuilder.command().set(m_adminPortOffset,String.valueOf(adminPortNo));
    m_procBuilder.command().set(m_pathToDeploymentOffset,m_pathToDeployment);
    m_procBuilder.command().set(m_voltStartCmdOffset,"rejoinhost");
    m_procBuilder.command().set(m_rejoinOffset,rejoinHost + ":" + String.valueOf(portNoToRejoin));
    m_procBuilder.command().set(m_licensePathOffset,"");
    m_procBuilder.command().set(m_timestampSaltOffset,String.valueOf(getRandomTimestampSalt()));
    if (m_debug) {
      System.out.println("Debug port is " + m_debugPortOffset);
      m_procBuilder.command().set(m_debugOffset1,"-Xdebug");
      m_procBuilder.command().set(m_debugOffset2,"-agentlib:jdwp=transport=dt_socket,address=" + m_debugPortOffset++ + ",server=y,suspend=n");
    }
    m_procBuilder.command().set(m_zkPortOffset,Integer.toString(2181 + hostId));
    Process proc=m_procBuilder.start();
    start=System.currentTimeMillis();
    String testoutputdir=m_buildDir + File.separator + "testoutput";
    File dir=new File(testoutputdir);
    if (dir.exists()) {
      assert(dir.isDirectory());
    }
 else {
      boolean status=dir.mkdirs();
      assert(status);
    }
    ptf=new PipeToFile(testoutputdir + File.separator + getName()+ "-"+ hostId+ ".txt",proc.getInputStream(),PipeToFile.m_rejoinToken,true);
synchronized (this) {
      m_pipes.set(hostId,ptf);
      m_cluster.set(hostId,proc);
    }
    Thread t=new Thread(ptf);
    t.setName("ClusterPipe:" + String.valueOf(hostId));
    t.start();
  }
 catch (  IOException ex) {
    System.out.println("Failed to start cluster process:" + ex.getMessage());
    Logger.getLogger(LocalCluster.class.getName()).log(Level.SEVERE,null,ex);
    assert(false);
  }
synchronized (ptf) {
    while (ptf.m_witnessedReady.get() != true && !ptf.m_eof) {
      if (logtime)       System.out.println("********** pre witness: " + (System.currentTimeMillis() - startTime) + " ms");
      try {
        ptf.wait();
      }
 catch (      InterruptedException ex) {
        Logger.getLogger(LocalCluster.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
  if (ptf.m_witnessedReady.get()) {
    long finish=System.currentTimeMillis();
    System.out.println("Took " + (finish - start) + " milliseconds, time from init was "+ (finish - ptf.m_initTime));
    return true;
  }
 else {
    System.out.println("Recovering process exited before recovery completed");
    try {
      silentShutdownSingleHost(hostId,true);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    return false;
  }
}
