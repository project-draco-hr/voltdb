{
  m.getData().order(ByteOrder.LITTLE_ENDIAN);
  try {
    if (m.getData().remaining() == 0) {
      m_decoder.noDataReceived(m.getAckOffset());
      poll();
      return;
    }
    int ttllength=m.getData().getInt();
    m_logger.trace("Poller: generation: " + m_generation + " table: "+ m_tableName+ ", partition: "+ partitionId+ " : data payload bytes: "+ ttllength);
    if (ttllength == 0) {
      m_decoder.noDataReceived(m.getAckOffset());
      poll();
      return;
    }
    final int startPosition=m.getData().position();
    int backoffQuantity=10 + (int)(10 * ThreadLocalRandom.current().nextDouble());
    while (true) {
      m.getData().position(startPosition);
      try {
        m_decoder.onBlockStart();
        while (m.getData().hasRemaining()) {
          int length=m.getData().getInt();
          byte[] rowdata=new byte[length];
          m.getData().get(rowdata,0,length);
          m_decoder.processRow(length,rowdata);
        }
        m_decoder.onBlockCompletion();
        break;
      }
 catch (      RestartBlockException e) {
        if (e.requestBackoff) {
          try {
            Thread.sleep(backoffQuantity);
          }
 catch (          InterruptedException e2) {
            Throwables.propagate(e2);
          }
          if (backoffQuantity < 8000) {
            backoffQuantity+=(backoffQuantity * .5);
            backoffQuantity+=(backoffQuantity * .5 * ThreadLocalRandom.current().nextDouble());
          }
        }
      }
    }
    pollAndAck(m);
  }
  finally {
    m.getData().order(ByteOrder.BIG_ENDIAN);
  }
}
