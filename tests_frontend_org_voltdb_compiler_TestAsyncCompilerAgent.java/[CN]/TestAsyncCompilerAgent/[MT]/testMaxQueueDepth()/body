{
  BlockingAnswer blockingAnswer=new BlockingAnswer();
  doAnswer(blockingAnswer).when(m_agent).compileAdHocPlan(any(AdHocPlannerWork.class));
  m_agent.createMailbox(mock(HostMessenger.class),100);
  m_agent.m_mailbox=spy(m_agent.m_mailbox);
  for (int i=0; i < AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2; ++i) {
    AdHocPlannerWork work=new AdHocPlannerWork(100l,false,0,0,"localhost",false,null,"select * from a",Arrays.asList(new String[]{"select * from a"}),0,null,false,true);
    LocalObjectMessage msg=new LocalObjectMessage(work);
    msg.m_sourceHSId=100;
    m_agent.m_mailbox.deliver(msg);
  }
  ArgumentCaptor<LocalObjectMessage> captor=ArgumentCaptor.forClass(LocalObjectMessage.class);
  verify(m_agent.m_mailbox).send(eq(100L),captor.capture());
  assertNotNull(((AsyncCompilerResult)captor.getValue().payload).errorMsg);
  blockingAnswer.flag.release(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 1);
  m_agent.shutdown();
  VerificationMode expected=times(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2);
  verify(m_agent.m_mailbox,expected).send(eq(100L),any(LocalObjectMessage.class));
}
