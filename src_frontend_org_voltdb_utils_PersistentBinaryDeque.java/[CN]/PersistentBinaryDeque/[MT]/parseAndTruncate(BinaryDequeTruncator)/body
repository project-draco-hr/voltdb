{
  assertions();
  if (m_segments.isEmpty()) {
    exportLog.debug("PBD " + m_nonce + " has no finished segments");
    return;
  }
  Long lastSegmentIndex=null;
  ByteBuffer decompressionBuffer=ByteBuffer.allocateDirect(1024 * 512);
  for (  PBDSegment segment : m_segments) {
    long segmentIndex=segment.m_index;
    File segmentFile=segment.m_file;
    RandomAccessFile ras=new RandomAccessFile(segmentFile,"rw");
    FileChannel fc=ras.getChannel();
    ByteBuffer readBuffer=fc.map(MapMode.READ_WRITE,0,fc.size());
    final long buffAddr=((DirectBuffer)readBuffer).address();
    try {
      int numObjects=readBuffer.getInt();
      exportLog.debug("PBD " + m_nonce + " has "+ numObjects+ " objects to parse and truncate");
      for (int ii=0; ii < numObjects; ii++) {
        final int nextObjectLength=readBuffer.getInt();
        final int nextObjectFlags=readBuffer.getInt();
        final boolean compressed=nextObjectFlags == PBDSegment.FLAG_COMPRESSED;
        final int uncompressedLength=compressed ? (int)Snappy.uncompressedLength(buffAddr + readBuffer.position(),nextObjectLength) : nextObjectLength;
        ByteBuffer nextObject=null;
        if (compressed) {
          decompressionBuffer.clear();
          if (decompressionBuffer.remaining() < uncompressedLength) {
            DBBPool.cleanByteBuffer(decompressionBuffer);
            decompressionBuffer=ByteBuffer.allocateDirect(uncompressedLength);
          }
          nextObject=decompressionBuffer;
          final long sourceAddr=(buffAddr + readBuffer.position());
          final long destAddr=((DirectBuffer)nextObject).address();
          Snappy.rawUncompress(sourceAddr,nextObjectLength,destAddr);
          readBuffer.position(readBuffer.position() + nextObjectLength);
        }
 else {
          final int oldLimit=readBuffer.limit();
          readBuffer.limit(readBuffer.position() + nextObjectLength);
          nextObject=readBuffer.slice();
          readBuffer.position(readBuffer.limit());
          readBuffer.limit(oldLimit);
        }
        ByteBuffer retval=truncator.parse(nextObject);
        if (retval == null) {
          DBBPool.cleanByteBuffer(nextObject);
          continue;
        }
 else {
          long startSize=fc.size();
          if (retval.remaining() == 0) {
            if (ii == 0) {
              lastSegmentIndex=segmentIndex - 1;
            }
 else {
              ByteBuffer numObjectsBuffer=ByteBuffer.allocate(4);
              numObjectsBuffer.putInt(0,ii);
              fc.position(0);
              while (numObjectsBuffer.hasRemaining()) {
                fc.write(numObjectsBuffer);
              }
              fc.truncate(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
            }
          }
 else {
            ByteBuffer copy=ByteBuffer.allocate(retval.remaining());
            copy.put(retval);
            copy.flip();
            readBuffer.position(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
            readBuffer.putInt(copy.remaining());
            readBuffer.putInt(0);
            readBuffer.put(copy);
            readBuffer.putInt(0,ii + 1);
            fc.truncate(readBuffer.position());
          }
          if (lastSegmentIndex == null) {
            lastSegmentIndex=segmentIndex;
          }
          DBBPool.cleanByteBuffer(nextObject);
          break;
        }
      }
      if (lastSegmentIndex != null) {
        break;
      }
    }
  finally {
      fc.close();
      DBBPool.cleanByteBuffer(readBuffer);
    }
  }
  DBBPool.cleanByteBuffer(decompressionBuffer);
  if (lastSegmentIndex == null) {
    return;
  }
  Iterator<PBDSegment> iterator=m_segments.descendingIterator();
  while (iterator.hasNext()) {
    PBDSegment segment=iterator.next();
    if (segment.m_index <= lastSegmentIndex) {
      break;
    }
    iterator.remove();
    segment.closeAndDelete();
  }
  Long newSegmentIndex=0L;
  if (m_segments.peekLast() != null)   newSegmentIndex=m_segments.peekLast().m_index + 1;
  PBDSegment newSegment=new PBDSegment(newSegmentIndex,new VoltFile(m_path,m_nonce + "." + newSegmentIndex+ ".pbd"));
  newSegment.open(true);
  m_segments.offer(newSegment);
  assertions();
}
