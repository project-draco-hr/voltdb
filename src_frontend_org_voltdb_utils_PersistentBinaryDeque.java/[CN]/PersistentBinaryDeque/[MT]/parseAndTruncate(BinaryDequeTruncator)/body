{
  assert(preconditions());
  if (m_finishedSegments.isEmpty()) {
    exportLog.debug("PBD " + m_nonce + " has no finished segments");
    return;
  }
  ByteBuffer readBuffer=ByteBuffer.allocateDirect(DequeSegment.m_chunkSize + 16);
  Long lastSegmentIndex=null;
  for (  Map.Entry<Long,DequeSegment> entry : m_finishedSegments.entrySet()) {
    readBuffer.clear();
    DequeSegment segment=entry.getValue();
    long segmentIndex=entry.getKey();
    File segmentFile=segment.m_file;
    RandomAccessFile ras=new RandomAccessFile(segmentFile,"rw");
    FileChannel fc=ras.getChannel();
    try {
      while (readBuffer.hasRemaining()) {
        int read=fc.read(readBuffer);
        if (read == -1) {
          break;
        }
      }
      readBuffer.flip();
      int numObjects=readBuffer.getInt();
      exportLog.debug("PBD " + m_nonce + " has "+ numObjects+ " objects to parse and truncate");
      for (int ii=0; ii < numObjects; ii++) {
        final int nextObjectLength=readBuffer.getInt();
        ByteBuffer nextObject=ByteBuffer.allocate(nextObjectLength);
        final int oldLimit=readBuffer.limit();
        readBuffer.limit(readBuffer.position() + nextObjectLength);
        nextObject.put(readBuffer).flip();
        readBuffer.limit(oldLimit);
        ByteBuffer retval=truncator.parse(nextObject);
        if (retval == null) {
          continue;
        }
 else {
          long startSize=fc.size();
          if (retval.remaining() == 0) {
            if (ii == 0) {
              lastSegmentIndex=segmentIndex - 1;
            }
 else {
              ByteBuffer numObjectsBuffer=ByteBuffer.allocate(4);
              numObjectsBuffer.putInt(0,ii);
              fc.position(0);
              while (numObjectsBuffer.hasRemaining()) {
                fc.write(numObjectsBuffer);
              }
              fc.truncate(readBuffer.position() - (nextObjectLength + 4));
            }
          }
 else {
            readBuffer.position(readBuffer.position() - (nextObjectLength + 4));
            readBuffer.putInt(retval.remaining());
            readBuffer.put(retval);
            readBuffer.flip();
            readBuffer.putInt(0,ii + 1);
            fc.position(0);
            fc.truncate(0);
            while (readBuffer.hasRemaining()) {
              fc.write(readBuffer);
            }
          }
          long endSize=fc.size();
          m_sizeInBytes.addAndGet(endSize - startSize);
          if (lastSegmentIndex == null) {
            lastSegmentIndex=segmentIndex;
          }
          break;
        }
      }
      if (lastSegmentIndex != null) {
        break;
      }
    }
  finally {
      fc.close();
    }
  }
  if (lastSegmentIndex == null) {
    return;
  }
  Iterator<Map.Entry<Long,DequeSegment>> iterator=m_finishedSegments.entrySet().iterator();
  while (iterator.hasNext()) {
    Map.Entry<Long,DequeSegment> entry=iterator.next();
    if (entry.getKey() <= lastSegmentIndex) {
      continue;
    }
    DequeSegment ds=entry.getValue();
    iterator.remove();
    ds.closeAndDelete();
  }
  m_writeSegment.closeAndDelete();
  m_currentPollSegmentIndex=0L;
  Long writeSegmentIndex=0L;
  try {
    m_currentPollSegmentIndex=m_finishedSegments.firstKey();
    writeSegmentIndex=m_finishedSegments.lastKey() + 1;
  }
 catch (  NoSuchElementException e) {
  }
  m_writeSegment=new DequeSegment(writeSegmentIndex,new VoltFile(m_path,m_nonce + "." + writeSegmentIndex+ ".pbd"));
  m_writeSegment.open();
  m_writeSegment.initNumEntries();
  if (m_finishedSegments.isEmpty()) {
    assert(m_writeSegment.m_index.equals(m_currentPollSegmentIndex));
  }
  assert(postconditions());
}
