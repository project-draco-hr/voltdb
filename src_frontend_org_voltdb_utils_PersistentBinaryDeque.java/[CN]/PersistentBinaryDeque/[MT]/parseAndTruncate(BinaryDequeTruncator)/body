{
  assertions();
  if (m_segments.isEmpty()) {
    exportLog.debug("PBD " + m_nonce + " has no finished segments");
    return;
  }
  Long lastSegmentIndex=null;
  BBContainer decompressionBuffer=DBBPool.allocateDirect(1024 * 512);
  try {
    for (    PBDSegment segment : m_segments) {
      long segmentIndex=segment.m_index;
      File segmentFile=segment.m_file;
      RandomAccessFile ras=new RandomAccessFile(segmentFile,"rw");
      FileChannel fc=ras.getChannel();
      MBBContainer readBufferC=DBBPool.wrapMBB(fc.map(MapMode.READ_WRITE,0,fc.size()));
      final ByteBuffer readBuffer=readBufferC.b();
      final long buffAddr=readBufferC.address();
      try {
        int numObjects=readBuffer.getInt();
        int size=readBuffer.getInt();
        int objectsProcessed=0;
        exportLog.debug("PBD " + m_nonce + " has "+ numObjects+ " objects to parse and truncate");
        for (int ii=0; ii < numObjects; ii++) {
          final int nextObjectLength=readBuffer.getInt();
          final int nextObjectFlags=readBuffer.getInt();
          final boolean compressed=nextObjectFlags == PBDSegment.FLAG_COMPRESSED;
          final int uncompressedLength=compressed ? (int)Snappy.uncompressedLength(buffAddr + readBuffer.position(),nextObjectLength) : nextObjectLength;
          objectsProcessed++;
          BBContainer nextObject=null;
          if (compressed) {
            decompressionBuffer.b().clear();
            if (decompressionBuffer.b().remaining() < uncompressedLength) {
              decompressionBuffer.discard();
              decompressionBuffer=DBBPool.allocateDirect(uncompressedLength);
            }
            nextObject=DBBPool.dummyWrapBB(decompressionBuffer.b());
            final long sourceAddr=(buffAddr + readBuffer.position());
            final long destAddr=nextObject.address();
            Snappy.rawUncompress(sourceAddr,nextObjectLength,destAddr);
            readBuffer.position(readBuffer.position() + nextObjectLength);
          }
 else {
            final int oldLimit=readBuffer.limit();
            readBuffer.limit(readBuffer.position() + nextObjectLength);
            nextObject=DBBPool.dummyWrapBB(readBuffer.slice());
            readBuffer.position(readBuffer.limit());
            readBuffer.limit(oldLimit);
          }
          try {
            ByteBuffer retval=truncator.parse(nextObject.b());
            if (retval == null) {
              continue;
            }
 else {
              if (retval.remaining() == 0) {
                if (ii == 0) {
                  lastSegmentIndex=segmentIndex - 1;
                }
 else {
                  addToNumObjects(-(numObjects - (objectsProcessed - 1)));
                  ByteBuffer numObjectsBuffer=ByteBuffer.allocate(4);
                  numObjectsBuffer.putInt(0,ii);
                  fc.position(0);
                  while (numObjectsBuffer.hasRemaining()) {
                    fc.write(numObjectsBuffer);
                  }
                  fc.truncate(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
                }
              }
 else {
                addToNumObjects(-(numObjects - objectsProcessed));
                ByteBuffer copy=ByteBuffer.allocate(retval.remaining());
                copy.put(retval);
                copy.flip();
                readBuffer.position(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
                readBuffer.putInt(copy.remaining());
                readBuffer.putInt(0);
                readBuffer.put(copy);
                readBuffer.putInt(0,ii + 1);
                fc.truncate(readBuffer.position());
              }
              if (lastSegmentIndex == null) {
                lastSegmentIndex=segmentIndex;
              }
              break;
            }
          }
  finally {
            nextObject.discard();
          }
        }
        if (lastSegmentIndex != null) {
          break;
        }
      }
  finally {
        fc.close();
        readBufferC.discard();
      }
    }
  }
  finally {
    decompressionBuffer.discard();
  }
  if (lastSegmentIndex == null) {
    return;
  }
  Iterator<PBDSegment> iterator=m_segments.descendingIterator();
  while (iterator.hasNext()) {
    PBDSegment segment=iterator.next();
    if (segment.m_index <= lastSegmentIndex) {
      break;
    }
    addToNumObjects(-segment.getNumEntries());
    iterator.remove();
    segment.closeAndDelete();
  }
  Long newSegmentIndex=0L;
  if (m_segments.peekLast() != null)   newSegmentIndex=m_segments.peekLast().m_index + 1;
  PBDSegment newSegment=new PBDSegment(newSegmentIndex,new VoltFile(m_path,m_nonce + "." + newSegmentIndex+ ".pbd"));
  newSegment.open(true);
  m_segments.offer(newSegment);
  assertions();
}
