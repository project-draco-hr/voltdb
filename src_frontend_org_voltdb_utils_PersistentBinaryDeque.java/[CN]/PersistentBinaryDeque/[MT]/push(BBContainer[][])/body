{
  assert(preconditions());
  if (m_writeSegment == null) {
    throw new IOException("Closed");
  }
  ArrayDeque<ArrayDeque<BBContainer[]>> segments=new ArrayDeque<ArrayDeque<BBContainer[]>>();
  ArrayDeque<BBContainer[]> currentSegment=new ArrayDeque<BBContainer[]>();
  int available=DequeSegment.m_chunkSize - 4;
  for (  BBContainer object[] : objects) {
    int needed=4;
    for (    BBContainer obj : object) {
      needed+=obj.b.remaining();
    }
    if (available - needed < 0) {
      if (needed > DequeSegment.m_chunkSize - 4) {
        throw new IOException("Maximum object size is " + (DequeSegment.m_chunkSize - 4));
      }
      segments.offer(currentSegment);
      currentSegment=new ArrayDeque<BBContainer[]>();
      available=DequeSegment.m_chunkSize - 4;
    }
    available-=needed;
    currentSegment.add(object);
  }
  segments.add(currentSegment);
  assert(segments.size() > 0);
  Long nextIndex=0L;
  if (m_finishedSegments.size() > 0) {
    nextIndex=m_finishedSegments.firstKey() - 1;
  }
 else {
    nextIndex=m_writeSegment.m_index - 1;
  }
  while (segments.peek() != null) {
    ArrayDeque<BBContainer[]> currentSegmentContents=segments.poll();
    DequeSegment writeSegment=new DequeSegment(nextIndex,new VoltFile(m_path,m_nonce + "." + nextIndex+ ".pbd"));
    m_currentPollSegmentIndex=nextIndex;
    writeSegment.open();
    writeSegment.initNumEntries();
    nextIndex--;
    while (currentSegmentContents.peek() != null) {
      writeSegment.offer(currentSegmentContents.pollFirst());
    }
    writeSegment.m_fc.position(4);
    m_finishedSegments.put(writeSegment.m_index,writeSegment);
  }
  assert(postconditions());
}
