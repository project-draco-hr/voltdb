{
  m_path=path;
  m_nonce=nonce;
  if (!path.exists() || !path.canRead() || !path.canWrite()|| !path.canExecute()|| !path.isDirectory()) {
    throw new IOException(path + " is not usable ( !exists || !readable " + "|| !writable || !executable || !directory)");
  }
  path.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      String[] parts=pathname.getName().split("\\.");
      String parsedNonce=null;
      String seqNum=null;
      String extension=null;
      if (parts.length > 3) {
        Joiner joiner=Joiner.on('.').skipNulls();
        parsedNonce=joiner.join(Arrays.asList(parts).subList(0,parts.length - 2));
        seqNum=parts[parts.length - 2];
        extension=parts[parts.length - 1];
      }
 else       if (parts.length == 3) {
        parsedNonce=parts[0];
        seqNum=parts[1];
        extension=parts[2];
      }
      if (nonce.equals(parsedNonce) && "pbd".equals(extension)) {
        if (pathname.length() == 4) {
          pathname.delete();
          return false;
        }
        Long index=Long.valueOf(seqNum);
        DequeSegment ds=new DequeSegment(index,pathname);
        m_finishedSegments.put(index,ds);
        m_sizeInBytes.addAndGet(ds.sizeInBytes());
      }
      return false;
    }
  }
);
  Long lastKey=null;
  for (  Long key : m_finishedSegments.keySet()) {
    if (lastKey == null) {
      lastKey=key;
    }
 else {
      if (lastKey + 1 != key) {
        throw new IOException("Missing " + nonce + " pbd segments between "+ lastKey+ " and "+ key+ " in directory "+ path+ ". The data files found in the export overflow directory were inconsistent.");
      }
      lastKey=key;
    }
  }
  Long writeSegmentIndex=0L;
  try {
    m_currentPollSegmentIndex=m_finishedSegments.firstKey();
    writeSegmentIndex=m_finishedSegments.lastKey() + 1;
  }
 catch (  NoSuchElementException e) {
  }
  m_writeSegment=new DequeSegment(writeSegmentIndex,new VoltFile(m_path,m_nonce + "." + writeSegmentIndex+ ".pbd"));
  m_writeSegment.open();
  m_writeSegment.initNumEntries();
  assertions();
}
