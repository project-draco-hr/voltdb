{
  m_path=path;
  m_nonce=nonce;
  if (!path.exists() || !path.canRead() || !path.canWrite()|| !path.canExecute()|| !path.isDirectory()) {
    throw new IOException(path + " is not usable ( !exists || !readable " + "|| !writable || !executable || !directory)");
  }
  path.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      String[] parts=pathname.getName().split("\\.");
      if (parts.length > 3) {
        String[] joinedParts=new String[3];
        Joiner joiner=Joiner.on('.').skipNulls();
        joinedParts[0]=joiner.join(Arrays.asList(parts).subList(0,parts.length - 2));
        joinedParts[1]=parts[parts.length - 2];
        joinedParts[2]=parts[parts.length - 1];
        parts=joinedParts;
      }
      if (parts.length > 0 && parts[0].equals(nonce) && parts[parts.length - 1].equals("pbd")) {
        if (pathname.length() == 4) {
          pathname.delete();
          return false;
        }
        Long index=Long.valueOf(parts[parts.length - 2]);
        DequeSegment ds=new DequeSegment(index,pathname);
        m_finishedSegments.put(index,ds);
        m_sizeInBytes.addAndGet(ds.sizeInBytes());
      }
      return false;
    }
  }
);
  Long lastKey=null;
  for (  Long key : m_finishedSegments.keySet()) {
    if (lastKey == null) {
      lastKey=key;
    }
 else {
      if (lastKey + 1 != key) {
        throw new IOException("Missing " + nonce + " pbd segments between "+ lastKey+ " and "+ key+ " in directory "+ path+ ". The data files found in the export overflow directory were inconsistent.");
      }
      lastKey=key;
    }
  }
  Long writeSegmentIndex=0L;
  try {
    m_currentPollSegmentIndex=m_finishedSegments.firstKey();
    writeSegmentIndex=m_finishedSegments.lastKey() + 1;
  }
 catch (  NoSuchElementException e) {
  }
  m_writeSegment=new DequeSegment(writeSegmentIndex,new VoltFile(m_path,m_nonce + "." + writeSegmentIndex+ ".pbd"));
  m_writeSegment.open();
  m_writeSegment.initNumEntries();
}
