{
  long segmentIndex=segment.m_index;
  File segmentFile=segment.m_file;
  RandomAccessFile ras=new RandomAccessFile(segmentFile,"rw");
  FileChannel fc=ras.getChannel();
  MBBWrapperContainer readBufferC=DBBPool.wrapMBB(fc.map(MapMode.READ_WRITE,0,fc.size()));
  final ByteBuffer readBuffer=readBufferC.b();
  final long buffAddr=readBufferC.address();
  try {
    int numObjects=readBuffer.getInt();
    int size=readBuffer.getInt();
    int objectsProcessed=0;
    exportLog.debug("PBD " + m_nonce + " has "+ numObjects+ " objects to parse and truncate");
    for (int ii=0; ii < numObjects; ii++) {
      final int nextObjectLength=readBuffer.getInt();
      final int nextObjectFlags=readBuffer.getInt();
      final boolean compressed=nextObjectFlags == PBDSegment.FLAG_COMPRESSED;
      final int uncompressedLength=compressed ? (int)Snappy.uncompressedLength(buffAddr + readBuffer.position(),nextObjectLength) : nextObjectLength;
      objectsProcessed++;
      BBContainer nextObject=null;
      if (compressed) {
        decompressionBuffer.b().clear();
        if (decompressionBuffer.b().remaining() < uncompressedLength) {
          decompressionBuffer.discard();
          decompressionBuffer=DBBPool.allocateDirect(uncompressedLength);
        }
        nextObject=DBBPool.wrapBB(decompressionBuffer.b());
        final long sourceAddr=(buffAddr + readBuffer.position());
        final long destAddr=nextObject.address();
        Snappy.rawUncompress(sourceAddr,nextObjectLength,destAddr);
        readBuffer.position(readBuffer.position() + nextObjectLength);
      }
 else {
        final int oldLimit=readBuffer.limit();
        readBuffer.limit(readBuffer.position() + nextObjectLength);
        nextObject=DBBPool.wrapBB(readBuffer.slice());
        readBuffer.position(readBuffer.limit());
        readBuffer.limit(oldLimit);
      }
      try {
        ByteBuffer retval=truncator.parse(nextObject.b());
        if (retval == null) {
          continue;
        }
 else {
          if (retval.remaining() == 0) {
            if (ii == 0) {
              lastSegmentIndex=segmentIndex - 1;
            }
 else {
              addToNumObjects(-(numObjects - (objectsProcessed - 1)));
              ByteBuffer numObjectsBuffer=ByteBuffer.allocate(4);
              numObjectsBuffer.putInt(0,ii);
              fc.position(0);
              while (numObjectsBuffer.hasRemaining()) {
                fc.write(numObjectsBuffer);
              }
              fc.truncate(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
            }
          }
 else {
            addToNumObjects(-(numObjects - objectsProcessed));
            ByteBuffer copy=ByteBuffer.allocate(retval.remaining());
            copy.put(retval);
            copy.flip();
            readBuffer.position(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));
            readBuffer.putInt(copy.remaining());
            readBuffer.putInt(0);
            readBuffer.put(copy);
            readBuffer.putInt(0,ii + 1);
            fc.truncate(readBuffer.position());
          }
          if (lastSegmentIndex == null) {
            lastSegmentIndex=segmentIndex;
          }
          break;
        }
      }
  finally {
        nextObject.discard();
      }
    }
    if (lastSegmentIndex != null) {
      myResult=true;
      return this;
    }
  }
  finally {
    fc.close();
    readBufferC.discard();
  }
  myResult=false;
  return this;
}
