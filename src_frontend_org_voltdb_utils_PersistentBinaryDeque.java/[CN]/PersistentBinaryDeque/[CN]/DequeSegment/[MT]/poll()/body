{
  if (m_fc == null) {
    open();
  }
  int numEntries=getNumEntries();
  if (m_objectReadIndex >= numEntries) {
    return null;
  }
  m_objectReadIndex++;
  if (m_objectReadIndex >= numEntries) {
    while (m_finishedSegments.containsKey(m_currentPollSegmentIndex)) {
      DequeSegment ds=m_finishedSegments.get(m_currentPollSegmentIndex);
      if (ds.hasMoreEntries())       break;
      m_currentPollSegmentIndex++;
      if (!m_finishedSegments.containsKey(m_currentPollSegmentIndex) && m_writeSegment != null) {
        assert(m_writeSegment.m_index.intValue() == m_currentPollSegmentIndex);
      }
    }
  }
  m_bufferForNumEntries.clear();
  while (m_bufferForNumEntries.hasRemaining()) {
    int read=m_fc.read(m_bufferForNumEntries);
    if (read == -1) {
      throw new EOFException();
    }
  }
  m_bufferForNumEntries.flip();
  int length=m_bufferForNumEntries.getInt();
  if (length < 1) {
    throw new IOException("Read an invalid length");
  }
  ByteBuffer resultBuffer=ByteBuffer.allocate(length);
  while (resultBuffer.hasRemaining()) {
    int read=m_fc.read(resultBuffer);
    if (read == -1) {
      throw new EOFException();
    }
  }
  resultBuffer.flip();
  return new BBContainer(resultBuffer,0L){
    private boolean discarded=false;
    private final Throwable t=new Throwable();
    @Override public void discard(){
      if (!discarded) {
        discarded=true;
        m_discardsUntilDeletion--;
        if (m_discardsUntilDeletion == 0) {
          m_finishedSegments.remove(m_index);
          try {
            closeAndDelete();
          }
 catch (          IOException e) {
            exportLog.error("Error closing and deleting binary deque segment",e);
          }
        }
      }
 else {
        exportLog.error("An export buffer was discarded multiple times");
      }
    }
    @Override public void finalize(){
      if (!discarded && !m_closed) {
        exportLog.error(m_file + " had a buffer that was finalized without being discarded");
        StringWriter sw=new StringWriter();
        PrintWriter pw=new PrintWriter(sw);
        t.printStackTrace(pw);
        exportLog.error(sw.toString());
        discard();
      }
    }
  }
;
}
