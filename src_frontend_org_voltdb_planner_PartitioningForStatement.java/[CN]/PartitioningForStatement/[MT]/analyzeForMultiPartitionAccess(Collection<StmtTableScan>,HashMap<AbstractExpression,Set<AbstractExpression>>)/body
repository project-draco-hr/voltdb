{
  TupleValueExpression tokenPartitionKey=null;
  Set<Set<AbstractExpression>> eqSets=new HashSet<Set<AbstractExpression>>();
  int unfilteredPartitionKeyCount=0;
  for (  StmtTableScan tableScan : collection) {
    if (tableScan.getIsReplicated()) {
      continue;
    }
    List<SchemaColumn> columnsNeedingCoverage=tableScan.findPartitionColumns();
    if (tableScan instanceof StmtSubqueryScan) {
      StmtSubqueryScan subScan=(StmtSubqueryScan)tableScan;
      PartitioningForStatement pStmt=subScan.getPartitioningForStatement();
      if (!pStmt.requiresTwoFragments()) {
        AbstractExpression spExpr=pStmt.singlePartitioningExpression();
        TupleValueExpression pColumn=pStmt.getPartitionColumn();
        TupleValueExpression tveKey=subScan.upgradeTableNames(pColumn);
        if (valueEquivalence.containsKey(tveKey)) {
          Set<AbstractExpression> values=valueEquivalence.get(tveKey);
          values.add(spExpr);
          if (!valueEquivalence.containsKey(spExpr)) {
            valueEquivalence.put(spExpr,values);
          }
        }
 else         if (valueEquivalence.containsKey(spExpr)) {
          Set<AbstractExpression> values=valueEquivalence.get(spExpr);
          values.add(tveKey);
          valueEquivalence.put(tveKey,values);
        }
 else {
          Set<AbstractExpression> values=new HashSet<AbstractExpression>();
          values.add(spExpr);
          values.add(tveKey);
          valueEquivalence.put(spExpr,values);
          valueEquivalence.put(tveKey,values);
        }
      }
    }
    boolean unfiltered=true;
    for (    AbstractExpression candidateColumn : valueEquivalence.keySet()) {
      if (!(candidateColumn instanceof TupleValueExpression)) {
        continue;
      }
      TupleValueExpression candidatePartitionKey=(TupleValueExpression)candidateColumn;
      if (!canCoverPartitioningColumn(candidatePartitionKey,columnsNeedingCoverage)) {
        continue;
      }
      unfiltered=false;
      if (tokenPartitionKey == null) {
        tokenPartitionKey=candidatePartitionKey;
      }
      Set<AbstractExpression> eqValues=valueEquivalence.get(candidatePartitionKey);
      eqSets.add(eqValues);
    }
    if (unfiltered) {
      ++unfilteredPartitionKeyCount;
    }
  }
  m_countOfIndependentlyPartitionedTables=eqSets.size() + unfilteredPartitionKeyCount;
  if ((unfilteredPartitionKeyCount == 0) && (eqSets.size() == 1)) {
    for (    Set<AbstractExpression> partitioningValues : eqSets) {
      for (      AbstractExpression constExpr : partitioningValues) {
        if (constExpr instanceof TupleValueExpression) {
          continue;
        }
        addPartitioningExpression(tokenPartitionKey,constExpr);
        break;
      }
    }
  }
  return m_countOfIndependentlyPartitionedTables;
}
