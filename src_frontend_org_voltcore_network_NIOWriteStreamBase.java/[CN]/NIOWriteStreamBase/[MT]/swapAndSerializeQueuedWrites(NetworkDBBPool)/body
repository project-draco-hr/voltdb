{
  final ArrayDeque<DeferredSerialization> oldlist=getQueuedWrites();
  if (oldlist.isEmpty())   return;
  DeferredSerialization ds=null;
  int bytesQueued=0;
  while ((ds=oldlist.poll()) != null) {
    final int serializedSize=ds.getSerializedSize();
    if (serializedSize == -1)     continue;
    BBContainer outCont=m_queuedBuffers.peekLast();
    if (outCont == null || !outCont.b.hasRemaining()) {
      outCont=pool.acquire();
      outCont.b.clear();
      m_queuedBuffers.offer(outCont);
    }
    if (outCont.b.remaining() >= serializedSize) {
      final ByteBuffer outbuf=outCont.b;
      final int oldLimit=outbuf.limit();
      outbuf.limit(outbuf.position() + serializedSize);
      final ByteBuffer slice=outbuf.slice();
      ds.serialize(slice);
      checkSloppySerialization(slice,ds);
      slice.position(0);
      bytesQueued+=slice.remaining();
      outbuf.position(outbuf.limit());
      outbuf.limit(oldLimit);
    }
 else {
      ByteBuffer buf=ByteBuffer.allocate(serializedSize);
      ds.serialize(buf);
      checkSloppySerialization(buf,ds);
      buf.position(0);
      bytesQueued+=buf.remaining();
      while (buf.hasRemaining()) {
        if (!outCont.b.hasRemaining()) {
          outCont=pool.acquire();
          outCont.b.clear();
          m_queuedBuffers.offer(outCont);
        }
        if (outCont.b.remaining() >= buf.remaining()) {
          outCont.b.put(buf);
        }
 else {
          final int oldLimit=buf.limit();
          buf.limit(buf.position() + outCont.b.remaining());
          outCont.b.put(buf);
          buf.limit(oldLimit);
        }
      }
    }
  }
  updateQueued(bytesQueued,true);
}
