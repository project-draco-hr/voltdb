{
  rejoinLog.trace("Starting write");
  try {
    BBContainer chunk;
    try {
      chunk=tupleData.call();
    }
 catch (    Exception e) {
      return Futures.immediateFailedFuture(e);
    }
    if (m_writeFailed.get() != null || (chunk == null)) {
      if (chunk != null) {
        chunk.discard();
      }
      return null;
    }
    if (m_closed.get()) {
      chunk.discard();
      IOException e=new IOException("Trying to write snapshot data " + "after the stream is closed");
      m_writeFailed.set(e);
      return Futures.immediateFailedFuture(e);
    }
    if (m_schemas.containsKey(tableId)) {
      byte[] schema=m_schemas.remove(tableId);
      rejoinLog.debug("Sending schema for table " + tableId);
      rejoinLog.trace("Writing schema as part of this write");
      send(StreamSnapshotMessageType.SCHEMA,tableId,schema);
    }
    chunk.b().put((byte)StreamSnapshotMessageType.DATA.ordinal());
    chunk.b().putInt(m_blockIndex);
    chunk.b().putInt(tableId);
    chunk.b().position(0);
    return send(m_blockIndex++,chunk);
  }
  finally {
    rejoinLog.trace("Finished call to write");
  }
}
