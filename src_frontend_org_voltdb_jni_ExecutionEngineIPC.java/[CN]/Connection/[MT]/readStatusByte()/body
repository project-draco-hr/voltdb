{
  int status=kErrorCode_RetrieveDependency;
  while (true) {
    status=m_socket.getInputStream().read();
    if (status == kErrorCode_RetrieveDependency) {
      final ByteBuffer dependencyIdBuffer=ByteBuffer.allocate(4);
      while (dependencyIdBuffer.hasRemaining()) {
        final int read=m_socketChannel.read(dependencyIdBuffer);
        if (read == -1) {
          throw new IOException("Unable to read enough bytes for dependencyId in order to " + " satisfy IPC backend request for a dependency table");
        }
      }
      dependencyIdBuffer.rewind();
      sendDependencyTable(dependencyIdBuffer.getInt());
      continue;
    }
    if (status == kErrorCode_CrashVoltDB) {
      ByteBuffer lengthBuffer=ByteBuffer.allocate(4);
      while (lengthBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(lengthBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      lengthBuffer.flip();
      ByteBuffer messageBuffer=ByteBuffer.allocate(lengthBuffer.getInt());
      while (messageBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(messageBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      messageBuffer.flip();
      final int reasonLength=messageBuffer.getInt();
      final byte reasonBytes[]=new byte[reasonLength];
      messageBuffer.get(reasonBytes);
      final String message=new String(reasonBytes,"UTF-8");
      final int filenameLength=messageBuffer.getInt();
      final byte filenameBytes[]=new byte[filenameLength];
      messageBuffer.get(filenameBytes);
      final String filename=new String(filenameBytes,"UTF-8");
      final int lineno=messageBuffer.getInt();
      final int numTraces=messageBuffer.getInt();
      final String traces[]=new String[numTraces];
      for (int ii=0; ii < numTraces; ii++) {
        final int traceLength=messageBuffer.getInt();
        final byte traceBytes[]=new byte[traceLength];
        messageBuffer.get(traceBytes);
        traces[ii]=new String(traceBytes,"UTF-8");
      }
      ExecutionEngine.crashVoltDB(message,traces,filename,lineno);
    }
    if (status == kErrorCode_pushExportBuffer) {
      ByteBuffer header=ByteBuffer.allocate(30);
      while (header.hasRemaining()) {
        final int read=m_socket.getChannel().read(header);
        if (read == -1) {
          throw new EOFException();
        }
      }
      header.flip();
      long exportGeneration=header.getLong();
      int partitionId=header.getInt();
      int signatureLength=header.getInt();
      byte signatureBytes[]=new byte[signatureLength];
      header.get(signatureBytes);
      String signature=new String(signatureBytes,"UTF-8");
      long uso=header.getLong();
      boolean sync=header.get() == 1 ? true : false;
      boolean isEndOfGeneration=header.get() == 1 ? true : false;
      int length=header.getInt();
      ByteBuffer exportBuffer=ByteBuffer.allocateDirect(length);
      while (exportBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(exportBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      exportBuffer.flip();
      ExportManager.pushExportBuffer(exportGeneration,partitionId,signature,uso,0,length == 0 ? null : exportBuffer,sync,isEndOfGeneration);
      continue;
    }
    if (status == kErrorCode_getQueuedExportBytes) {
      ByteBuffer header=ByteBuffer.allocate(12);
      while (header.hasRemaining()) {
        final int read=m_socket.getChannel().read(header);
        if (read == -1) {
          throw new EOFException();
        }
      }
      header.flip();
      int partitionId=header.getInt();
      int signatureLength=header.getInt();
      byte signatureBytes[]=new byte[signatureLength];
      header.get(signatureBytes);
      String signature=new String(signatureBytes,"UTF-8");
      long retval=ExportManager.getQueuedExportBytes(partitionId,signature);
      ByteBuffer buf=ByteBuffer.allocate(8);
      buf.putLong(retval).flip();
      while (buf.hasRemaining()) {
        m_socketChannel.write(buf);
      }
      continue;
    }
    try {
      checkErrorCode(status);
      break;
    }
 catch (    final RuntimeException e) {
      if (e instanceof SerializableException) {
        throw e;
      }
 else {
        throw (IOException)e.getCause();
      }
    }
  }
  return status;
}
