{
  int status=kErrorCode_RetrieveDependency;
  while (true) {
    status=m_socket.getInputStream().read();
    if (status == kErrorCode_RetrieveDependency) {
      final ByteBuffer dependencyIdBuffer=ByteBuffer.allocate(4);
      while (dependencyIdBuffer.hasRemaining()) {
        final int read=m_socketChannel.read(dependencyIdBuffer);
        if (read == -1) {
          throw new IOException("Unable to read enough bytes for dependencyId in order to " + " satisfy IPC backend request for a dependency table");
        }
      }
      dependencyIdBuffer.rewind();
      sendDependencyTable(dependencyIdBuffer.getInt());
      continue;
    }
    if (status == kErrorCode_CrashVoltDB) {
      ByteBuffer lengthBuffer=ByteBuffer.allocate(4);
      while (lengthBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(lengthBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      lengthBuffer.flip();
      ByteBuffer messageBuffer=ByteBuffer.allocate(lengthBuffer.getInt());
      while (messageBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(messageBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      final int reasonLength=messageBuffer.getInt();
      final byte reasonBytes[]=new byte[reasonLength];
      messageBuffer.get(reasonBytes);
      final String message=new String(reasonBytes,"UTF-8");
      final int filenameLength=messageBuffer.getInt();
      final byte filenameBytes[]=new byte[filenameLength];
      messageBuffer.get(filenameBytes);
      final String filename=new String(filenameBytes,"UTF-8");
      final int lineno=messageBuffer.getInt();
      final int numTraces=messageBuffer.getInt();
      final String traces[]=new String[numTraces];
      for (int ii=0; ii < numTraces; ii++) {
        final int traceLength=messageBuffer.getInt();
        final byte traceBytes[]=new byte[traceLength];
        traces[ii]=new String(traceBytes,"UTF-8");
      }
      ExecutionEngine.crashVoltDB(message,traces,filename,lineno);
    }
    if (status == kErrorCode_pushExportBuffer) {
      ByteBuffer header=ByteBuffer.allocate(20);
      while (header.hasRemaining()) {
        final int read=m_socket.getChannel().read(header);
        if (read == -1) {
          throw new EOFException();
        }
      }
      header.flip();
      int partitionId=header.getInt();
      long delegateId=header.getLong();
      long uso=header.getLong();
      header.order(ByteOrder.LITTLE_ENDIAN);
      int length=header.getInt();
      ByteBuffer exportBuffer=ByteBuffer.allocateDirect(length + 4);
      exportBuffer.order(ByteOrder.LITTLE_ENDIAN);
      exportBuffer.putInt(length);
      exportBuffer.order(ByteOrder.BIG_ENDIAN);
      while (exportBuffer.hasRemaining()) {
        final int read=m_socket.getChannel().read(exportBuffer);
        if (read == -1) {
          throw new EOFException();
        }
      }
      exportBuffer.flip();
      ExportManager.pushExportBuffer(partitionId,delegateId,uso,0,exportBuffer);
      continue;
    }
    try {
      checkErrorCode(status);
      break;
    }
 catch (    final RuntimeException e) {
      if (e instanceof SerializableException) {
        throw e;
      }
 else {
        throw (IOException)e.getCause();
      }
    }
  }
  return status;
}
