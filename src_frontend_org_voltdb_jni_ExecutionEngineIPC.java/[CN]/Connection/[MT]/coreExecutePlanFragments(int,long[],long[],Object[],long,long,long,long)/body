{
  sendPlanFragmentsInvocation(Commands.QueryPlanFragments,numFragmentIds,planFragmentIds,inputDepIds,parameterSets,spHandle,lastCommittedSpHandle,uniqueId,undoToken);
  int result=ExecutionEngine.ERRORCODE_ERROR;
  while (true) {
    try {
      result=m_connection.readStatusByte();
      if (result == ExecutionEngine.ERRORCODE_NEED_PLAN) {
        long fragmentId=m_connection.readLong();
        byte[] plan=planForFragmentId(fragmentId);
        m_data.clear();
        m_data.put(plan);
        m_data.flip();
        m_connection.write();
      }
 else       if (result == ExecutionEngine.ERRORCODE_PROGRESS_UPDATE) {
        int batchIndex=m_connection.readInt();
        short size=m_connection.readShort();
        String planNodeName=m_connection.readString(size);
        size=m_connection.readShort();
        String lastAccessedTable=m_connection.readString(size);
        long lastAccessedTableSize=m_connection.readLong();
        long tuplesFound=m_connection.readLong();
        boolean isCancel=fragmentProgressUpdate(batchIndex,planNodeName,lastAccessedTable,lastAccessedTableSize,tuplesFound);
        short isCancelInt=isCancel ? (short)1 : 0;
        m_data.clear();
        m_data.putShort(isCancelInt);
        m_data.flip();
        m_connection.write();
      }
 else       if (result == ExecutionEngine.ERRORCODE_SUCCESS) {
        final VoltTable resultTables[]=new VoltTable[numFragmentIds];
        for (int ii=0; ii < numFragmentIds; ii++) {
          resultTables[ii]=PrivateVoltTableFactory.createUninitializedVoltTable();
        }
        try {
          m_connection.readResultTables(resultTables);
        }
 catch (        final IOException e) {
          throw new EEException(ExecutionEngine.ERRORCODE_WRONG_SERIALIZED_BYTES);
        }
        return resultTables;
      }
 else {
        return null;
      }
    }
 catch (    final IOException e) {
      System.out.println("Exception: " + e.getMessage());
      throw new RuntimeException(e);
    }
  }
}
