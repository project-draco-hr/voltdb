{
  if (m_haveDoneRestore) {
    throw new VoltAbortException("Cluster has already been restored or has failed a restore." + " Restart the cluster before doing another restore.");
  }
  final long startTime=System.currentTimeMillis();
  HOST_LOG.info("Restoring from path: " + path + " with nonce: "+ nonce);
  VoltTable[] savefile_data;
  savefile_data=performRestoreScanWork(path,nonce);
  List<JSONObject> digests;
  Map<String,Map<Integer,Long>> exportSequenceNumbers;
  try {
    Pair<List<JSONObject>,Map<String,Map<Integer,Long>>> digestScanResult=performRestoreDigestScanWork();
    digests=digestScanResult.getFirst();
    exportSequenceNumbers=digestScanResult.getSecond();
  }
 catch (  VoltAbortException e) {
    ColumnInfo[] result_columns=new ColumnInfo[2];
    int ii=0;
    result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
    result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
    VoltTable results[]=new VoltTable[]{new VoltTable(result_columns)};
    results[0].addRow("FAILURE",e.toString());
    return results;
  }
  ClusterSaveFileState savefile_state=null;
  try {
    savefile_state=new ClusterSaveFileState(savefile_data[0]);
  }
 catch (  IOException e) {
    throw new VoltAbortException(e.getMessage());
  }
  HashSet<String> relevantTableNames=new HashSet<String>();
  try {
    if (digests.isEmpty()) {
      throw new Exception("No digests found");
    }
    for (    JSONObject obj : digests) {
      JSONArray tables=obj.getJSONArray("tables");
      for (int ii=0; ii < tables.length(); ii++) {
        relevantTableNames.add(tables.getString(ii));
      }
    }
  }
 catch (  Exception e) {
    ColumnInfo[] result_columns=new ColumnInfo[2];
    int ii=0;
    result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
    result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
    VoltTable results[]=new VoltTable[]{new VoltTable(result_columns)};
    results[0].addRow("FAILURE",e.toString());
    return results;
  }
  assert(relevantTableNames != null);
  assert(relevantTableNames.size() > 0);
  VoltTable[] results=null;
  for (  String tableName : relevantTableNames) {
    if (!savefile_state.getSavedTableNames().contains(tableName)) {
      if (results == null) {
        ColumnInfo[] result_columns=new ColumnInfo[2];
        int ii=0;
        result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
        result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
        results=new VoltTable[]{new VoltTable(result_columns)};
      }
      results[0].addRow("FAILURE","Save data contains no information for table " + tableName);
      break;
    }
    final TableSaveFileState saveFileState=savefile_state.getTableState(tableName);
    if (saveFileState == null) {
      if (results == null) {
        ColumnInfo[] result_columns=new ColumnInfo[2];
        int ii=0;
        result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
        result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
        results=new VoltTable[]{new VoltTable(result_columns)};
      }
      results[0].addRow("FAILURE","Save data contains no information for table " + tableName);
    }
 else     if (!saveFileState.isConsistent()) {
      if (results == null) {
        ColumnInfo[] result_columns=new ColumnInfo[2];
        int ii=0;
        result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
        result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
        results=new VoltTable[]{new VoltTable(result_columns)};
      }
      results[0].addRow("FAILURE",saveFileState.getConsistencyResult());
    }
  }
  if (results != null) {
    return results;
  }
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    ObjectOutputStream oos=new ObjectOutputStream(baos);
    oos.writeObject(exportSequenceNumbers);
    oos.flush();
    byte exportSequenceNumberBytes[]=baos.toByteArray();
    oos.close();
    results=performDistributeExportSequenceNumbers(exportSequenceNumberBytes,digests.get(0).getLong("txnId"));
  }
 catch (  IOException e) {
    throw new VoltAbortException(e);
  }
catch (  JSONException e) {
    throw new VoltAbortException(e);
  }
  while (results[0].advanceRow()) {
    if (results[0].getString("RESULT").equals("FAILURE")) {
      throw new VoltAbortException("Error distributing export sequence numbers");
    }
  }
  results=performTableRestoreWork(savefile_state);
  final long endTime=System.currentTimeMillis();
  final double duration=(endTime - startTime) / 1000.0;
  final StringWriter sw=new StringWriter();
  final PrintWriter pw=new PrintWriter(sw);
  pw.toString();
  pw.printf("%.2f",duration);
  HOST_LOG.info("Finished restore of " + path + " with nonce: "+ nonce+ " in "+ sw.toString()+ " seconds");
  return results;
}
