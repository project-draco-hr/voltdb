{
  if (m_haveDoneRestore) {
    throw new VoltAbortException("Cluster has already been restored or has failed a restore." + " Restart the cluster before doing another restore.");
  }
  final long startTime=System.currentTimeMillis();
  HOST_LOG.info("Restoring from path: " + path + ", with ID: "+ nonce+ " at "+ startTime);
  VoltTable[] savefile_data;
  savefile_data=performRestoreScanWork(path,nonce);
  ClusterSaveFileState savefile_state=null;
  try {
    savefile_state=new ClusterSaveFileState(savefile_data[0]);
  }
 catch (  IOException e) {
    throw new VoltAbortException(e.getMessage());
  }
  List<String> relevantTableNames=null;
  try {
    relevantTableNames=SnapshotUtil.retrieveRelevantTableNames(path,nonce);
  }
 catch (  Exception e) {
    ColumnInfo[] result_columns=new ColumnInfo[2];
    int ii=0;
    result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
    result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
    VoltTable results[]=new VoltTable[]{new VoltTable(result_columns)};
    results[0].addRow("FAILURE",e.toString());
    return results;
  }
  assert(relevantTableNames != null);
  assert(relevantTableNames.size() > 0);
  VoltTable[] results=null;
  for (  String tableName : relevantTableNames) {
    if (!savefile_state.getSavedTableNames().contains(tableName)) {
      if (results == null) {
        ColumnInfo[] result_columns=new ColumnInfo[2];
        int ii=0;
        result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
        result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
        results=new VoltTable[]{new VoltTable(result_columns)};
      }
      results[0].addRow("FAILURE","Save data contains no information for table " + tableName);
    }
    final TableSaveFileState saveFileState=savefile_state.getTableState(tableName);
    if (saveFileState == null || !saveFileState.isConsistent()) {
      if (results == null) {
        ColumnInfo[] result_columns=new ColumnInfo[2];
        int ii=0;
        result_columns[ii++]=new ColumnInfo("RESULT",VoltType.STRING);
        result_columns[ii++]=new ColumnInfo("ERR_MSG",VoltType.STRING);
        results=new VoltTable[]{new VoltTable(result_columns)};
      }
      results[0].addRow("FAILURE","Save data for " + tableName + " is inconsistent "+ "(potentially missing partitions) or corrupted");
    }
  }
  if (results != null) {
    return results;
  }
  results=performTableRestoreWork(savefile_state);
  final long endTime=System.currentTimeMillis();
  final double duration=(endTime - startTime) / 1000.0;
  final StringWriter sw=new StringWriter();
  final PrintWriter pw=new PrintWriter(sw);
  pw.toString();
  pw.printf("%.2f",duration);
  HOST_LOG.info("Finished restored of " + path + ", with ID: "+ nonce+ " at "+ endTime+ " took "+ sw.toString()+ " seconds");
  return results;
}
