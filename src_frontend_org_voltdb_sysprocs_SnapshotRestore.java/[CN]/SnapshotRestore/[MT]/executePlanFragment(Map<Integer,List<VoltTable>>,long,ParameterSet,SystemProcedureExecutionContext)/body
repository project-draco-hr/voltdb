{
  if (fragmentId == SysProcFragmentId.PF_restoreDistributeExportAndPartitionSequenceNumbers) {
    assert(params.toArray()[0] != null);
    assert(params.toArray().length == 3);
    assert(params.toArray()[0] instanceof byte[]);
    assert(params.toArray()[2] instanceof long[]);
    VoltTable result=new VoltTable(new VoltTable.ColumnInfo("RESULT",VoltType.STRING));
    long snapshotTxnId=((Long)params.toArray()[1]).longValue();
    long perPartitionTxnIds[]=(long[])params.toArray()[2];
    context.getSiteProcedureConnection().setPerPartitionTxnIds(perPartitionTxnIds);
    if (context.isLowestSiteId()) {
      ExportManager.instance().truncateExportToTxnId(snapshotTxnId,perPartitionTxnIds);
    }
    try {
      ByteArrayInputStream bais=new ByteArrayInputStream((byte[])params.toArray()[0]);
      ObjectInputStream ois=new ObjectInputStream(bais);
      @SuppressWarnings("unchecked") Map<String,Map<Integer,Long>> exportSequenceNumbers=(Map<String,Map<Integer,Long>>)ois.readObject();
      Database db=context.getDatabase();
      Integer myPartitionId=context.getPartitionId();
      for (      Table t : db.getTables()) {
        if (!CatalogUtil.isTableExportOnly(db,t))         continue;
        String signature=t.getSignature();
        String name=t.getTypeName();
        Map<Integer,Long> sequenceNumberPerPartition=exportSequenceNumbers.get(name);
        if (sequenceNumberPerPartition == null) {
          SNAP_LOG.warn("Could not find export sequence number for table " + name + ". This warning is safe to ignore if you are loading a pre 1.3 snapshot"+ " which would not contain these sequence numbers (added in 1.3)."+ " If this is a post 1.3 snapshot then the restore has failed and export sequence "+ " are reset to 0");
          continue;
        }
        Long sequenceNumber=sequenceNumberPerPartition.get(myPartitionId);
        if (sequenceNumber == null) {
          SNAP_LOG.warn("Could not find an export sequence number for table " + name + " partition "+ myPartitionId+ ". This warning is safe to ignore if you are loading a pre 1.3 snapshot "+ " which would not contain these sequence numbers (added in 1.3)."+ " If this is a post 1.3 snapshot then the restore has failed and export sequence "+ " are reset to 0");
          continue;
        }
        context.getSiteProcedureConnection().exportAction(true,0,sequenceNumber,myPartitionId,signature);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      SNAP_LOG.error(e);
      result.addRow("FAILURE");
    }
    return new DependencyPair(DEP_restoreDistributeExportAndPartitionSequenceNumbers,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDistributeExportAndPartitionSequenceNumbersResults) {
    TRACE_LOG.trace("Aggregating digest scan state");
    assert(dependencies.size() > 0);
    VoltTable result=VoltTableUtil.unionTables(dependencies.get(DEP_restoreDistributeExportAndPartitionSequenceNumbers));
    return new DependencyPair(DEP_restoreDistributeExportAndPartitionSequenceNumbersResults,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDigestScan) {
    VoltTable result=new VoltTable(new VoltTable.ColumnInfo("DIGEST",VoltType.STRING),new VoltTable.ColumnInfo("RESULT",VoltType.STRING),new VoltTable.ColumnInfo("ERR_MSG",VoltType.STRING));
    if (context.isLowestSiteId()) {
      try {
        TRACE_LOG.trace("Checking saved table digest state for restore of: " + m_filePath + ", "+ m_fileNonce);
        List<JSONObject> digests=SnapshotUtil.retrieveDigests(m_filePath,m_fileNonce,SNAP_LOG);
        for (        JSONObject obj : digests) {
          result.addRow(obj.toString(),"SUCCESS",null);
        }
      }
 catch (      Exception e) {
        StringWriter sw=new StringWriter();
        PrintWriter pw=new PrintWriter(sw);
        e.printStackTrace(pw);
        pw.flush();
        e.printStackTrace();
        SNAP_LOG.error(e);
        result.addRow(null,"FAILURE",sw.toString());
        return new DependencyPair(DEP_restoreDigestScan,result);
      }
    }
    return new DependencyPair(DEP_restoreDigestScan,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDigestScanResults) {
    TRACE_LOG.trace("Aggregating digest scan state");
    assert(dependencies.size() > 0);
    VoltTable result=VoltTableUtil.unionTables(dependencies.get(DEP_restoreDigestScan));
    return new DependencyPair(DEP_restoreDigestScanResults,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreScan) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    String hostname=CoreUtils.getHostnameOrAddress();
    VoltTable result=ClusterSaveFileState.constructEmptySaveFileStateVoltTable();
    if (context.isLowestSiteId()) {
      m_duplicateRowHandler=null;
      if (params.toArray()[2] != null) {
        m_duplicateRowHandler=new DuplicateRowHandler((String)params.toArray()[2],getTransactionTime());
      }
      m_initializedTableSaveFileNames.clear();
      m_saveFiles.clear();
      m_filePath=(String)params.toArray()[0];
      m_fileNonce=(String)params.toArray()[1];
      TRACE_LOG.trace("Checking saved table state for restore of: " + m_filePath + ", "+ m_fileNonce);
      File[] savefiles=SnapshotUtil.retrieveRelevantFiles(m_filePath,m_fileNonce);
      if (savefiles == null) {
        return new DependencyPair(DEP_restoreScan,result);
      }
      for (      File file : savefiles) {
        TableSaveFile savefile=null;
        try {
          savefile=getTableSaveFile(file,1,null);
          try {
            if (!savefile.getCompleted()) {
              continue;
            }
            String is_replicated="FALSE";
            if (savefile.isReplicated()) {
              is_replicated="TRUE";
            }
            int partitionIds[]=savefile.getPartitionIds();
            for (            int pid : partitionIds) {
              result.addRow(m_hostId,hostname,savefile.getHostId(),savefile.getHostname(),savefile.getClusterName(),savefile.getDatabaseName(),savefile.getTableName(),savefile.getTxnId(),is_replicated,pid,savefile.getTotalPartitions());
            }
          }
  finally {
            savefile.close();
          }
        }
 catch (        FileNotFoundException e) {
          e.printStackTrace();
        }
catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    return new DependencyPair(DEP_restoreScan,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreScanResults) {
    TRACE_LOG.trace("Aggregating saved table state");
    assert(dependencies.size() > 0);
    VoltTable result=VoltTableUtil.unionTables(dependencies.get(DEP_restoreScan));
    return new DependencyPair(DEP_restoreScanResults,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreAsyncRunLoop) {
    Object paramsArray[]=params.toArray();
    assert(paramsArray.length == 1);
    assert(paramsArray[0] instanceof Long);
    long coordinatorHSId=(Long)paramsArray[0];
    Mailbox m=VoltDB.instance().getHostMessenger().createMailbox();
    m_mbox=m;
    TRACE_LOG.trace("Entering async run loop at " + CoreUtils.hsIdToString(context.getSiteId()) + " listening on mbox "+ CoreUtils.hsIdToString(m.getHSId()));
    ByteBuffer responseBuffer=ByteBuffer.allocate(16);
    responseBuffer.putLong(m_site.getCorrespondingSiteId());
    responseBuffer.putLong(m.getHSId());
    BinaryPayloadMessage bpm=new BinaryPayloadMessage(new byte[0],responseBuffer.array());
    m.send(coordinatorHSId,bpm);
    bpm=null;
    while (true) {
      bpm=(BinaryPayloadMessage)m.recvBlocking();
      if (bpm == null)       continue;
      ByteBuffer wrappedMap=ByteBuffer.wrap(bpm.m_payload);
      while (wrappedMap.hasRemaining()) {
        long actualHSId=wrappedMap.getLong();
        long generatedHSId=wrappedMap.getLong();
        m_actualToGenerated.put(actualHSId,generatedHSId);
      }
      break;
    }
    while (true) {
      VoltMessage vm=m.recvBlocking(1000);
      if (vm == null)       continue;
      if (vm instanceof FragmentTaskMessage) {
        FragmentTaskMessage ftm=(FragmentTaskMessage)vm;
        TRACE_LOG.trace(CoreUtils.hsIdToString(context.getSiteId()) + " received fragment id " + VoltSystemProcedure.hashToFragId(ftm.getPlanHash(0)));
        DependencyPair dp=m_runner.executeSysProcPlanFragment(m_runner.getTxnState(),null,VoltSystemProcedure.hashToFragId(ftm.getPlanHash(0)),ftm.getParameterSetForFragment(0));
        FragmentResponseMessage frm=new FragmentResponseMessage(ftm,m.getHSId());
        frm.addDependency(dp.depId,dp.dependency);
        m.send(ftm.getCoordinatorHSId(),frm);
      }
 else       if (vm instanceof BinaryPayloadMessage) {
        if (context.isLowestSiteId() && m_duplicateRowHandler != null) {
          try {
            m_duplicateRowHandler.close();
          }
 catch (          Exception e) {
            VoltDB.crashLocalVoltDB("Error closing duplicate row handler during snapshot restore",true,e);
          }
        }
        return new DependencyPair(DEP_restoreAsyncRunLoop,constructResultsTable());
      }
    }
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreAsyncRunLoopResults) {
    return new DependencyPair(DEP_restoreAsyncRunLoopResults,constructResultsTable());
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreLoadTable) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    assert(params.toArray()[2] != null);
    assert(params.toArray()[3] != null);
    String table_name=(String)params.toArray()[0];
    int dependency_id=(Integer)params.toArray()[1];
    byte compressedTable[]=(byte[])params.toArray()[2];
    int checkUniqueViolations=(Integer)params.toArray()[3];
    int[] partition_ids=(int[])params.toArray()[4];
    if (checkUniqueViolations > 0) {
      assert(partition_ids != null && partition_ids.length == 1);
    }
    TRACE_LOG.trace("Received table: " + table_name + (partition_ids == null ? "[REPLICATED]" : "of partition [" + partition_ids.toString())+ "]");
    String result_str="SUCCESS";
    String error_msg="";
    try {
      VoltTable table=PrivateVoltTableFactory.createVoltTableFromBuffer(ByteBuffer.wrap(CompressionService.decompressBytes(compressedTable)),true);
      if (checkUniqueViolations > 0) {
        byte uniqueViolations[]=voltLoadTable(context.getCluster().getTypeName(),context.getDatabase().getTypeName(),table_name,table,m_duplicateRowHandler != null);
        if (uniqueViolations != null && m_duplicateRowHandler != null) {
          m_duplicateRowHandler.handleDuplicates(table_name,uniqueViolations);
        }
      }
 else {
        voltLoadTable(context.getCluster().getTypeName(),context.getDatabase().getTypeName(),table_name,table,false);
      }
    }
 catch (    Exception e) {
      result_str="FAILURE";
      error_msg=e.getMessage();
    }
    VoltTable result=constructResultsTable();
    result.addRow(m_hostId,CoreUtils.getHostnameOrAddress(),CoreUtils.getSiteIdFromHSId(m_siteId),table_name,((checkUniqueViolations > 0) ? partition_ids[0] : -1),result_str,error_msg);
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreReceiveResultTables) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    int dependency_id=(Integer)params.toArray()[0];
    String tracingLogMsg=(String)params.toArray()[1];
    TRACE_LOG.trace(tracingLogMsg);
    List<VoltTable> table_list=new ArrayList<VoltTable>();
    for (    int dep_id : dependencies.keySet()) {
      table_list.addAll(dependencies.get(dep_id));
    }
    assert(table_list.size() == dependencies.size());
    VoltTable result=VoltTableUtil.unionTables(table_list);
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreLoadReplicatedTable) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    String table_name=(String)params.toArray()[0];
    int dependency_id=(Integer)params.toArray()[1];
    TRACE_LOG.trace("Loading replicated table: " + table_name);
    String result_str="SUCCESS";
    String error_msg="";
    TableSaveFile savefile=null;
    try {
      savefile=getTableSaveFile(getSaveFileForReplicatedTable(table_name),3,null);
      assert(savefile.getCompleted());
    }
 catch (    IOException e) {
      String hostname=CoreUtils.getHostnameOrAddress();
      VoltTable result=constructResultsTable();
      result.addRow(m_hostId,hostname,CoreUtils.getSiteIdFromHSId(m_siteId),table_name,-1,"FAILURE","Unable to load table: " + table_name + " error: "+ e.getMessage());
      return new DependencyPair(dependency_id,result);
    }
    try {
      final Table new_catalog_table=getCatalogTable(table_name);
      Boolean needsConversion=null;
      while (savefile.hasMoreChunks()) {
        VoltTable table=null;
        final org.voltcore.utils.DBBPool.BBContainer c=savefile.getNextChunk();
        if (c == null) {
          continue;
        }
        if (needsConversion == null) {
          VoltTable old_table=PrivateVoltTableFactory.createVoltTableFromBuffer(c.b.duplicate(),true);
          needsConversion=SavedTableConverter.needsConversion(old_table,new_catalog_table);
        }
        if (needsConversion.booleanValue()) {
          VoltTable old_table=PrivateVoltTableFactory.createVoltTableFromBuffer(c.b,true);
          table=SavedTableConverter.convertTable(old_table,new_catalog_table);
        }
 else {
          ByteBuffer copy=ByteBuffer.allocate(c.b.remaining());
          copy.put(c.b);
          copy.flip();
          table=PrivateVoltTableFactory.createVoltTableFromBuffer(copy,true);
        }
        c.discard();
        try {
          voltLoadTable(context.getCluster().getTypeName(),context.getDatabase().getTypeName(),table_name,table,false);
        }
 catch (        VoltAbortException e) {
          result_str="FAILURE";
          error_msg=e.getMessage();
          break;
        }
      }
    }
 catch (    IOException e) {
      String hostname=CoreUtils.getHostnameOrAddress();
      VoltTable result=constructResultsTable();
      result.addRow(m_hostId,hostname,CoreUtils.getSiteIdFromHSId(m_siteId),table_name,-1,"FAILURE","Unable to load table: " + table_name + " error: "+ e.getMessage());
      return new DependencyPair(dependency_id,result);
    }
catch (    VoltTypeException e) {
      String hostname=CoreUtils.getHostnameOrAddress();
      VoltTable result=constructResultsTable();
      result.addRow(m_hostId,hostname,CoreUtils.getSiteIdFromHSId(m_siteId),table_name,-1,"FAILURE","Unable to load table: " + table_name + " error: "+ e.getMessage());
      return new DependencyPair(dependency_id,result);
    }
    String hostname=CoreUtils.getHostnameOrAddress();
    VoltTable result=constructResultsTable();
    result.addRow(m_hostId,hostname,CoreUtils.getSiteIdFromHSId(m_siteId),table_name,-1,result_str,error_msg);
    try {
      savefile.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDistributeReplicatedTableAsReplicated) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    assert(params.toArray()[2] != null);
    String table_name=(String)params.toArray()[0];
    long site_id=(Long)params.toArray()[1];
    int dependency_id=(Integer)params.toArray()[2];
    TRACE_LOG.trace(CoreUtils.hsIdToString(context.getSiteId()) + " distributing replicated table: " + table_name+ " to: "+ CoreUtils.hsIdToString(site_id));
    VoltTable result=performDistributeReplicatedTable(table_name,context,site_id,false);
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDistributePartitionedTableAsPartitioned) {
    Object paramsA[]=params.toArray();
    assert(paramsA[0] != null);
    assert(paramsA[1] != null);
    assert(paramsA[2] != null);
    assert(paramsA[3] != null);
    String table_name=(String)paramsA[0];
    int originalHosts[]=(int[])paramsA[1];
    int relevantPartitions[]=(int[])paramsA[2];
    int dependency_id=(Integer)paramsA[3];
    for (    int partition_id : relevantPartitions) {
      TRACE_LOG.trace("Distributing partitioned table: " + table_name + " partition id: "+ partition_id);
    }
    VoltTable result=performDistributePartitionedTable(table_name,originalHosts,relevantPartitions,context,false);
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDistributePartitionedTableAsReplicated) {
    Object paramsA[]=params.toArray();
    assert(paramsA[0] != null);
    assert(paramsA[1] != null);
    assert(paramsA[2] != null);
    assert(paramsA[3] != null);
    String table_name=(String)paramsA[0];
    int originalHosts[]=(int[])paramsA[1];
    int relevantPartitions[]=(int[])paramsA[2];
    int dependency_id=(Integer)paramsA[3];
    for (    int partition_id : relevantPartitions) {
      TRACE_LOG.trace("Loading partitioned-to-replicated table: " + table_name + " partition id: "+ partition_id);
    }
    VoltTable result=performDistributePartitionedTable(table_name,originalHosts,relevantPartitions,context,true);
    return new DependencyPair(dependency_id,result);
  }
 else   if (fragmentId == SysProcFragmentId.PF_restoreDistributeReplicatedTableAsPartitioned) {
    assert(params.toArray()[0] != null);
    assert(params.toArray()[1] != null);
    String table_name=(String)params.toArray()[0];
    int dependency_id=(Integer)params.toArray()[1];
    TRACE_LOG.trace("Loading replicated-to-partitioned table: " + table_name);
    VoltTable result=performDistributeReplicatedTable(table_name,context,-1,true);
    return new DependencyPair(dependency_id,result);
  }
  assert(false);
  return null;
}
