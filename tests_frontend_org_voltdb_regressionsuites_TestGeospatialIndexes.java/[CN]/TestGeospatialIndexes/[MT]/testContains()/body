{
  System.out.println("Starting tests for Contains() ... ");
  Client client=getClient();
  populateGeoTables(client);
  VoltTable resultsUsingGeoIndex, resultsFromNonGeoIndex;
  String sql;
  String prefixMsg;
  final double EPSILON=1.0e-12;
  sql="Select * from PLACES order by id, loc;";
  resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  sql="Select * from INDEXED_PLACES order by id, loc;";
  resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  prefixMsg="Assertion failed comparing contents of places and indexed_places to be same: ";
  assertTablesAreEqual(prefixMsg,resultsUsingGeoIndex,resultsFromNonGeoIndex);
  sql="Select * from BORDERS order by id, region;";
  resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  sql="Select * from INDEXED_BORDERS order by id, region;";
  resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  prefixMsg="Assertion failed comparing contents of places and indexed_borders to be same: ";
  assertTablesAreEqual(prefixMsg,resultsUsingGeoIndex,resultsFromNonGeoIndex);
  sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id = 0 " + "order by A.id, A.region, B.loc;";
  resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  assertApproximateContentOfTable(new Object[][]{{0,polygonWithVertexNearBoundingBox,pointCentroidOfPolygonWithNoHole}},resultsUsingGeoIndex,EPSILON);
  sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id = 0 " + "order by A.id, A.region, B.loc;";
  resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  prefixMsg="Assertion failed comparing results of Contains on fixed data set: ";
  resultsUsingGeoIndex.resetRowPosition();
  assertTablesAreEqual(prefixMsg,resultsUsingGeoIndex,resultsFromNonGeoIndex);
  sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id = 0 " + "order by A.id, A.region, B.loc;";
  resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  assertApproximateContentOfTable(new Object[][]{{0,polygonWithVertexNearBoundingBox,pointOutSidePolygon},{0,polygonWithVertexNearBoundingBox,pointDisjointRegionCellNPolygon},{0,polygonWithVertexNearBoundingBox,pointBBVertexOutsidePolygon},{0,polygonWithVertexNearBoundingBoxWithHoles,pointOutSidePolygon},{0,polygonWithVertexNearBoundingBoxWithHoles,pointCentroidOfPolygonWithNoHole},{0,polygonWithVertexNearBoundingBoxWithHoles,pointDisjointRegionCellNPolygon},{0,polygonWithVertexNearBoundingBoxWithHoles,pointBBVertexOutsidePolygon}},resultsUsingGeoIndex,EPSILON);
  sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id = 0 " + "order by A.id, A.region, B.loc;";
  resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
  prefixMsg="Assertion failed comparing results of Not Contains on fixed data set: ";
  resultsUsingGeoIndex.resetRowPosition();
  assertTablesAreEqual(prefixMsg,resultsUsingGeoIndex,resultsFromNonGeoIndex);
  if (isValgrind()) {
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id < 25 " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id < 25 " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    prefixMsg="Assertion failed comparing results of Contains on indexed with non-indexed tables: ";
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id >= 25 " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id and A.id >= 25 " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    prefixMsg="Assertion failed comparing results of Contains on indexed with non-indexed tables: ";
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
    prefixMsg="Assertion failed comparing results of Contains on indexed with non-indexed tables: ";
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id < 25 " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id < 25 " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    resultsUsingGeoIndex.resetRowPosition();
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id >= 25 " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id and A.id >= 25 " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
  }
 else {
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where Contains(A.region, B.loc) and A.id = B.id " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    prefixMsg="Assertion failed comparing results of Contains on indexed with non-indexed tables: ";
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
    sql="Select A.id, A.region, B.loc from INDEXED_BORDERS A, INDEXED_PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id " + "order by A.id, A.region, B.loc;";
    resultsUsingGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    sql="Select A.id, A.region, B.loc from BORDERS A, PLACES B " + "where NOT Contains(A.region, B.loc) and A.id = B.id " + "order by A.id, A.region, B.loc;";
    resultsFromNonGeoIndex=client.callProcedure("@AdHoc",sql).getResults()[0];
    prefixMsg="Assertion failed comparing results of Contains on indexed with non-indexed tables: ";
    assertTablesAreEqual(prefixMsg,resultsFromNonGeoIndex,resultsUsingGeoIndex);
  }
  sql="Create procedure PointInPolygon as select A.region from INDEXED_BORDERS A " + "where Contains(A.region, ?) and A.id > 0;";
  client.callProcedure("@AdHoc",sql);
  for (  PolygonPoints polygonPoints : m_generatedPolygonPoints) {
    resultsUsingGeoIndex=client.callProcedure("PointInPolygon",polygonPoints.getInsidePoint()).getResults()[0];
    assertApproximateContentOfTable(new Object[][]{{polygonPoints.getPolygon()}},resultsUsingGeoIndex,EPSILON);
  }
  System.out.println(" ... Completed tests for Contains().");
}
