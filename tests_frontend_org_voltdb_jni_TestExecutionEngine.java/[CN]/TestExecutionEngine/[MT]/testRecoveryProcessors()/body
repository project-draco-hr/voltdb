{
  final int sourceId=0;
  final int destinationId=32;
  final AtomicReference<Boolean> sourceCompleted=new AtomicReference<Boolean>(false);
  final AtomicReference<Boolean> destinationCompleted=new AtomicReference<Boolean>(false);
  final Catalog catalog=new Catalog();
  catalog.execute(LoadCatalogToString.THE_CATALOG);
  sourceEngine.loadCatalog(catalog.serialize());
  final ExecutionEngine destinationEngine=new ExecutionEngineJNI(null,CLUSTER_ID,NODE_ID,destinationId,destinationId,"");
  destinationEngine.loadCatalog(catalog.serialize());
  int WAREHOUSE_TABLEID=warehouseTableId(catalog);
  int STOCK_TABLEID=stockTableId(catalog);
  loadTestTables(catalog);
  HashMap<Pair<String,Integer>,HashSet<Integer>> tablesAndDestinations=new HashMap<Pair<String,Integer>,HashSet<Integer>>();
  HashSet<Integer> destinations=new HashSet<Integer>();
  destinations.add(destinationId);
  tablesAndDestinations.put(Pair.of("STOCK",STOCK_TABLEID),destinations);
  tablesAndDestinations.put(Pair.of("WAREHOUSE",WAREHOUSE_TABLEID),destinations);
  final MockMailbox sourceMailbox=new MockMailbox();
  MockMailbox.registerMailbox(sourceId,sourceMailbox);
  final Runnable onSourceCompletion=new Runnable(){
    @Override public void run(){
      sourceCompleted.set(true);
    }
  }
;
  OnRecoveringPartitionInitiate onInitiate=new OnRecoveringPartitionInitiate(){
    @Override public long pickTxnToStopAfter(    long recoveringPartitionTxnId){
      return 0;
    }
  }
;
  final MessageHandler mh=new MessageHandler(){
    @Override public void handleMessage(    VoltMessage message){
      fail();
    }
  }
;
  final RecoverySiteProcessorSource sourceProcessor=new RecoverySiteProcessorSource(tablesAndDestinations,sourceEngine,sourceMailbox,sourceId,onSourceCompletion,onInitiate,mh);
  Thread sourceThread=new Thread(){
    @Override public void run(){
      VoltMessage message=sourceMailbox.recvBlocking();
      assertTrue(message != null);
      assertTrue(message instanceof RecoveryMessage);
      sourceProcessor.handleRecoveryMessage((RecoveryMessage)message);
    }
  }
;
  sourceThread.start();
  final HashMap<Pair<String,Integer>,Integer> tablesAndSources=new HashMap<Pair<String,Integer>,Integer>();
  tablesAndSources.put(Pair.of("STOCK",STOCK_TABLEID),sourceId);
  tablesAndSources.put(Pair.of("WAREHOUSE",WAREHOUSE_TABLEID),sourceId);
  final MockMailbox destinationMailbox=new MockMailbox();
  MockMailbox.registerMailbox(destinationId,destinationMailbox);
  final OnRecoveryCompletion onDestinationCompletion=new OnRecoveryCompletion(){
    @Override public void complete(    long txnId){
      destinationCompleted.set(true);
    }
  }
;
  Thread destinationThread=new Thread(){
    @Override public void run(){
      RecoverySiteProcessorDestination destinationProcess=new RecoverySiteProcessorDestination(tablesAndSources,destinationEngine,destinationMailbox,destinationId,onDestinationCompletion,0,mh);
      destinationProcess.sendInitiateMessage();
      while (!destinationCompleted.get()) {
        VoltMessage message=destinationMailbox.recvBlocking();
        assertTrue(message != null);
        assertTrue(message instanceof RecoveryMessage);
        destinationProcess.handleRecoveryMessage((RecoveryMessage)message);
        message.discard();
      }
    }
  }
;
  destinationThread.start();
  destinationThread.join();
  sourceThread.join();
  assertEquals(sourceEngine.tableHashCode(STOCK_TABLEID),destinationEngine.tableHashCode(STOCK_TABLEID));
  assertEquals(sourceEngine.tableHashCode(WAREHOUSE_TABLEID),destinationEngine.tableHashCode(WAREHOUSE_TABLEID));
  assertEquals(200,sourceEngine.serializeTable(WAREHOUSE_TABLEID).getRowCount());
  assertEquals(1000,sourceEngine.serializeTable(STOCK_TABLEID).getRowCount());
  assertEquals(200,destinationEngine.serializeTable(WAREHOUSE_TABLEID).getRowCount());
  assertEquals(1000,destinationEngine.serializeTable(STOCK_TABLEID).getRowCount());
}
