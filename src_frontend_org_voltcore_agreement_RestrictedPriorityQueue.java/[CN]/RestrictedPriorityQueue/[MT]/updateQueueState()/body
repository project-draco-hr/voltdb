{
  QueueState newState=QueueState.UNBLOCKED;
  OrderableTransaction ts=super.peek();
  LastInitiatorData lid=null;
  if (m_state == QueueState.BLOCKED_CLOSED) {
    return m_state;
  }
  assert(newState == QueueState.UNBLOCKED);
  if (ts == null) {
    QueueState checkRoadBlock=checkRoadBlock(m_newestCandidateTransaction);
    if (checkRoadBlock == QueueState.BLOCKED_CLOSED) {
      executeStateChange(checkRoadBlock,ts,lid);
      return m_state;
    }
 else {
      newState=QueueState.BLOCKED_EMPTY;
      executeStateChange(newState,ts,lid);
      return m_state;
    }
  }
  assert(newState == QueueState.UNBLOCKED);
{
    newState=checkRoadBlock(ts.txnId);
    if (newState == QueueState.BLOCKED_CLOSED) {
      executeStateChange(newState,ts,lid);
      return m_state;
    }
  }
  assert(newState == QueueState.UNBLOCKED);
  if (ts.txnId > m_newestCandidateTransaction) {
    newState=QueueState.BLOCKED_ORDERING;
    executeStateChange(newState,ts,lid);
    return m_state;
  }
  assert(newState == QueueState.UNBLOCKED);
  lid=m_initiatorData.get(ts.initiatorHSId);
  if (lid == null) {
  }
 else   if (m_useSafetyDance && (ts.txnId > lid.m_lastSafeTxnId)) {
    newState=QueueState.BLOCKED_SAFETY;
    executeStateChange(newState,ts,lid);
    return m_state;
  }
  assert(newState == QueueState.UNBLOCKED);
  assert(ts != null);
  executeStateChange(newState,ts,lid);
  return newState;
}
