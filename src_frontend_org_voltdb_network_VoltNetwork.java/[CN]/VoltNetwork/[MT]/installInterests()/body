{
  ArrayDeque<VoltPort> oldlist;
synchronized (m_selectorUpdates_1) {
    if (m_activeUpdateList == m_selectorUpdates_1) {
      oldlist=m_selectorUpdates_1;
      m_activeUpdateList=m_selectorUpdates_2;
    }
 else {
      oldlist=m_selectorUpdates_2;
      m_activeUpdateList=m_selectorUpdates_1;
    }
  }
  while (!oldlist.isEmpty()) {
    final VoltPort port=oldlist.poll();
    try {
      if (port.isRunning()) {
        continue;
      }
      if (port.isDead()) {
        unregisterChannel(port);
        try {
          port.m_selectionKey.channel().close();
        }
 catch (        IOException e) {
        }
      }
 else       if (port.hasQueuedRunnables()) {
        try {
          port.lockForHandlingWork();
          port.getKey().interestOps(0);
        }
 catch (        java.nio.channels.CancelledKeyException e) {
          networkLog.warn("Had a cancelled key exception while processing queued runnables for port " + port.m_remoteHost,e);
        }
        m_selector.selectedKeys().remove(port.getKey());
        Runnable r=getPortCallRunnable(port);
        if (m_useExecutorService) {
synchronized (m_tasks) {
            m_tasks.offer(getPortCallRunnable(port));
            m_tasks.notify();
          }
        }
 else {
          r.run();
        }
      }
 else {
        resumeSelection(port);
      }
    }
 catch (    java.nio.channels.CancelledKeyException e) {
      networkLog.warn("Had a cancelled key exception while processing queued runnables for port " + port.m_remoteHost,e);
    }
  }
}
