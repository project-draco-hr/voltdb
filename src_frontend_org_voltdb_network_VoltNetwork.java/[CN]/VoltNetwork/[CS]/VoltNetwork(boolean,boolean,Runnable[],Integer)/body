{
  m_thread=new Thread(this,"Volt Network");
  m_thread.setDaemon(true);
  m_useExecutorService=useExecutorService;
  m_useBlockingSelect=blockingSelect;
  m_periodicWork=periodicWork;
  try {
    m_selector=Selector.open();
  }
 catch (  IOException ex) {
    m_logger.fatal(null,ex);
    throw new RuntimeException(ex);
  }
  final int availableProcessors=Runtime.getRuntime().availableProcessors();
  if (!useExecutorService) {
    m_executor=null;
    return;
  }
  int threadPoolSize=1;
  if (threads != null) {
    threadPoolSize=threads.intValue();
  }
 else   if (availableProcessors <= 4) {
    threadPoolSize=1;
  }
 else   if (availableProcessors <= 8) {
    threadPoolSize=2;
  }
 else   if (availableProcessors <= 16) {
    threadPoolSize=2;
  }
  final ThreadFactory tf=new ThreadFactory(){
    private ThreadGroup group=new ThreadGroup(Thread.currentThread().getThreadGroup(),"Network threads");
    private int threadIndex=0;
    @Override public Thread newThread(    final Runnable run){
      final Thread t=new Thread(group,run,"Network Thread - " + threadIndex++){
        @Override public void run(){
          try {
            run.run();
          }
  finally {
synchronized (m_poolsToClearOnShutdown) {
              m_poolsToClearOnShutdown.add(VoltPort.m_pool.get());
            }
          }
        }
      }
;
synchronized (m_networkThreads) {
        m_networkThreads.add(t);
      }
      t.setDaemon(true);
      return t;
    }
  }
;
  m_executor=Executors.newFixedThreadPool(threadPoolSize,tf);
}
