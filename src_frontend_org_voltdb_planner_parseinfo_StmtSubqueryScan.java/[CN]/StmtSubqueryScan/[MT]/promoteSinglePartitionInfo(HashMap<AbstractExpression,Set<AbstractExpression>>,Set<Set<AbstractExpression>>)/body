{
  PartitioningForStatement pStmt=getPartitioningForStatement();
  if (pStmt.getCountOfPartitionedTables() > 0 && !pStmt.requiresTwoFragments()) {
    AbstractExpression spExpr=pStmt.singlePartitioningExpression();
    TupleValueExpression tveKey=pStmt.getPartitionColumn();
    assert(tveKey != null);
    tveKey.setTableName(m_tableAlias);
    tveKey.setTableAlias(m_tableAlias);
    if (valueEquivalence.containsKey(tveKey)) {
      Set<AbstractExpression> values=valueEquivalence.get(tveKey);
      boolean hasLegacyValues=false;
      if (eqSets.contains(values)) {
        eqSets.remove(values);
        hasLegacyValues=true;
      }
      values.add(spExpr);
      if (hasLegacyValues) {
        eqSets.add(values);
      }
      if (!valueEquivalence.containsKey(spExpr)) {
        valueEquivalence.put(spExpr,values);
      }
    }
 else     if (valueEquivalence.containsKey(spExpr)) {
      Set<AbstractExpression> values=valueEquivalence.get(spExpr);
      boolean hasLegacyValues=false;
      if (eqSets.contains(values)) {
        eqSets.remove(values);
        hasLegacyValues=true;
      }
      values.add(tveKey);
      if (hasLegacyValues) {
        eqSets.add(values);
      }
      valueEquivalence.put(tveKey,values);
    }
 else {
      Set<AbstractExpression> values=new HashSet<AbstractExpression>();
      values.add(spExpr);
      values.add(tveKey);
      valueEquivalence.put(spExpr,values);
      valueEquivalence.put(tveKey,values);
    }
  }
}
