{
  Client client=getClient();
  client.callProcedure("Truncate01");
  client.callProcedure("Truncate03");
  client.callProcedure("InsertO1",5,5,"dummy","dummy");
  client.callProcedure("InsertO1",1,5,"dummy1","dummy");
  client.callProcedure("InsertO1",4,2,"dummy","dummy");
  client.callProcedure("InsertO1",3,1,"dummy","dummy");
  client.callProcedure("InsertO1",2,7,"dummy","dummy");
  client.callProcedure("InsertO1",6,7,"dummy1","dummy");
  client.callProcedure("InsertO1",7,8,"dummy","dummy");
  client.callProcedure("InsertO3",1,1,7,7);
  client.callProcedure("InsertO3",2,2,7,7);
  client.callProcedure("InsertO3",3,3,8,8);
  client.callProcedure("InsertO3",4,4,1,1);
  client.callProcedure("InsertO3",10,10,10,10);
  client.callProcedure("TruncateP");
  client.callProcedure("@AdHoc","insert into P values (0, 1, 2, 10)");
  client.callProcedure("@AdHoc","insert into P values (1, 1, 1, 10)");
  client.callProcedure("@AdHoc","insert into P values (2, 1, 1, 20)");
  client.callProcedure("@AdHoc","insert into P values (3, 1, 0, 30)");
  String sql;
  VoltTable vt;
  long[][] expected;
  sql="SELECT PKEY FROM O1 ORDER BY PKEY DESC";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{7},{6},{5},{4},{3},{2},{1}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  sql="SELECT PKEY FROM O1 ORDER BY PKEY DESC LIMIT 3 OFFSET 3";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{4},{3},{2}};
  validateTableOfLongs(vt,expected);
  sql="SELECT A_INT, PKEY FROM O1 ORDER BY A_INT DESC, PKEY DESC LIMIT 3";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{8,7},{7,6},{7,2}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  sql="SELECT O1.A_INT FROM O1, O3 WHERE O1.A_INT = O3.I3 ORDER BY O1.A_INT";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{1},{7},{7},{7},{7},{8}};
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  sql="select P_D0 from P where P.P_D3 / 10 > 0 order by P_D3 / 10, P_D2";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{1},{0},{2},{3}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  assertTrue(vt.toString().contains("P_D32_10_IDX"));
  sql="select P_D0 from P where P.P_D3 / 10 > 0 order by P_D3 / 5, P_D2";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{1},{0},{2},{3}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  assertTrue(vt.toString().contains("P_D32_10_IDX"));
  client.callProcedure("TruncateP");
  client.callProcedure("@AdHoc","insert into P values (1, 1, 2, 10)");
  client.callProcedure("@AdHoc","insert into P values (3, 1, 1, 10)");
  client.callProcedure("@AdHoc","insert into P values (5, 1, 1, 20)");
  client.callProcedure("@AdHoc","insert into P values (7, 1, 0, 30)");
  sql="select P_D0 from P where P.P_D3 / 10 > 0 order by P_D3 / 10, P_D2";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{3},{1},{5},{7}};
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  sql="select PKEY, A_INT from O1 order by A_INT, A_INLINE_STR";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{3,1},{4,2},{5,5},{1,5},{2,7},{6,7},{7,8}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  assertTrue(vt.toString().contains("SEQUENTIAL SCAN of \"O1\""));
  sql="select O1.PKEY, O3.PK1, O3.PK2 from O1, O3 where O1.A_INT = O3.PK2 order by O3.PK2;";
  vt=client.callProcedure("@AdHoc",sql).getResults()[0];
  expected=new long[][]{{3,1,1},{4,2,2}};
  validateTableOfLongs(vt,expected);
  vt=client.callProcedure("@Explain",sql).getResults()[0];
  assertTrue(vt.toString().contains("MERGE RECEIVE"));
  assertTrue(vt.toString().contains("NESTLOOP INDEX INNER JOIN"));
}
