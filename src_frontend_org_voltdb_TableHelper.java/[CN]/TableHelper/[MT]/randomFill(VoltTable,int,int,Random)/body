{
  int[] pkeyIndexes=table.getPkeyColumnIndexes();
  Set<Tuple> pkeyValues=new HashSet<Tuple>();
  Map<Integer,Set<Object>> uniqueValues=new TreeMap<Integer,Set<Object>>();
  for (int col=0; col < table.getColumnCount(); col++) {
    if (table.getColumnUniqueness(col)) {
      uniqueValues.put(col,new HashSet<Object>());
    }
  }
  for (int i=0; i < rowCount; i++) {
    Object[] row;
    Tuple pkey=new Tuple(pkeyIndexes.length);
    boolean success=false;
    trynewrow:     while (!success) {
      row=randomRow(table,maxStringSize,rand);
      for (int col=0; col < table.getColumnCount(); col++) {
        int pkeyIndex=ArrayUtils.indexOf(pkeyIndexes,col);
        if (pkeyIndex != -1) {
          pkey.values[pkeyIndex]=row[col];
        }
      }
      if (pkeyIndexes.length > 0) {
        if (pkeyValues.contains(pkey)) {
          continue trynewrow;
        }
      }
      for (int col=0; col < table.getColumnCount(); col++) {
        Set<Object> uniqueColValues=uniqueValues.get(col);
        if (uniqueColValues != null) {
          if (uniqueColValues.contains(row[col])) {
            continue trynewrow;
          }
        }
      }
      if (pkeyIndexes.length > 0) {
        pkeyValues.add(pkey);
      }
      for (int col=0; col < table.getColumnCount(); col++) {
        Set<Object> uniqueColValues=uniqueValues.get(col);
        if (uniqueColValues != null) {
          uniqueColValues.add(row[col]);
        }
      }
      table.addRow(row);
      success=true;
    }
  }
}
