{
  if (!isRunning() || job == null)   return false;
  PoolThread thread=null;
  boolean spawn=false;
synchronized (_lock) {
    int idle=_idle.size();
    if (idle > 0)     thread=(PoolThread)_idle.remove(idle - 1);
 else {
      _queued++;
      if (_queued > _maxQueued)       _maxQueued=_queued;
      _jobs[_nextJobSlot++]=job;
      if (_nextJobSlot == _jobs.length)       _nextJobSlot=0;
      if (_nextJobSlot == _nextJob) {
        Runnable[] jobs=new Runnable[_jobs.length + _maxThreads];
        int split=_jobs.length - _nextJob;
        if (split > 0)         System.arraycopy(_jobs,_nextJob,jobs,0,split);
        if (_nextJob != 0)         System.arraycopy(_jobs,0,jobs,split,_nextJobSlot);
        _jobs=jobs;
        _nextJob=0;
        _nextJobSlot=_queued;
      }
      spawn=_queued > _spawnOrShrinkAt;
    }
  }
  if (thread != null) {
    thread.dispatch(job);
  }
 else   if (spawn) {
    newThread();
  }
  return true;
}
