{
  boolean idle=false;
  Runnable job=null;
  try {
    while (isRunning()) {
      if (job != null) {
        final Runnable todo=job;
        job=null;
        idle=false;
        todo.run();
      }
synchronized (_lock) {
        if (_queued > 0) {
          _queued--;
          job=_jobs[_nextJob++];
          if (_nextJob == _jobs.length)           _nextJob=0;
          continue;
        }
        final int threads=_threads.size();
        if (threads > _minThreads && (threads > _maxThreads || _idle.size() > _spawnOrShrinkAt)) {
          long now=System.currentTimeMillis();
          if ((now - _lastShrink) > getMaxIdleTimeMs()) {
            _lastShrink=now;
            _idle.remove(this);
            return;
          }
        }
        if (!idle) {
          _idle.add(this);
          idle=true;
        }
      }
synchronized (this) {
        if (_job == null)         this.wait(getMaxIdleTimeMs());
        job=_job;
        _job=null;
      }
    }
  }
 catch (  InterruptedException e) {
    Log.ignore(e);
  }
 finally {
synchronized (_lock) {
      _idle.remove(this);
    }
synchronized (_threadsLock) {
      _threads.remove(this);
    }
synchronized (this) {
      job=_job;
    }
    if (job != null) {
      OldQueuedThreadPool.this.dispatch(job);
    }
  }
}
