{
  Object returnArray[]=new Object[3];
  boolean success=false;
  if (addr.isUnresolved()) {
    throw new java.net.UnknownHostException(addr.getHostName());
  }
  SocketChannel aChannel=SocketChannel.open(addr);
  returnArray[0]=aChannel;
  assert(aChannel.isConnected());
  if (!aChannel.isConnected()) {
    throw new IOException("Failed to open host " + addr.getHostName());
  }
  final long retvals[]=new long[4];
  returnArray[1]=retvals;
  try {
    aChannel.configureBlocking(true);
    aChannel.socket().setTcpNoDelay(true);
    FastSerializer fs=new FastSerializer();
    fs.writeInt(0);
    fs.writeByte(0);
    fs.writeString(service);
    fs.writeString(username);
    fs.write(hashedPassword);
    final ByteBuffer fsBuffer=fs.getBuffer();
    final ByteBuffer b=ByteBuffer.allocate(fsBuffer.remaining());
    b.put(fsBuffer);
    final int size=fsBuffer.limit() - 4;
    b.flip();
    b.putInt(size);
    b.position(0);
    boolean successfulWrite=false;
    IOException writeException=null;
    try {
      for (int ii=0; ii < 4 && b.hasRemaining(); ii++) {
        aChannel.write(b);
      }
      if (!b.hasRemaining()) {
        successfulWrite=true;
      }
    }
 catch (    IOException e) {
      writeException=e;
    }
    int read=0;
    ByteBuffer lengthBuffer=ByteBuffer.allocate(4);
    while (lengthBuffer.hasRemaining()) {
      read=aChannel.read(lengthBuffer);
      if (read == -1) {
        if (writeException != null) {
          throw writeException;
        }
        if (!successfulWrite) {
          throw new IOException("Unable to write authentication info to server");
        }
        throw new IOException("Authentication rejected");
      }
    }
    lengthBuffer.flip();
    int len=lengthBuffer.getInt();
    ByteBuffer loginResponse=ByteBuffer.allocate(len);
    while (loginResponse.hasRemaining()) {
      read=aChannel.read(loginResponse);
      if (read == -1) {
        if (writeException != null) {
          throw writeException;
        }
        if (!successfulWrite) {
          throw new IOException("Unable to write authentication info to server");
        }
        throw new IOException("Authentication rejected");
      }
    }
    loginResponse.flip();
    loginResponse.position(1);
    byte loginResponseCode=loginResponse.get();
    if (loginResponseCode != 0) {
      aChannel.close();
switch (loginResponseCode) {
case ClientInterface.MAX_CONNECTIONS_LIMIT_ERROR:
        throw new IOException("Server has too many connections");
case ClientInterface.WIRE_PROTOCOL_TIMEOUT_ERROR:
      throw new IOException("Connection timed out during authentication. " + "The VoltDB server may be overloaded.");
case ClientInterface.EXPORT_DISABLED_REJECTION:
    throw new IOException("Export not enabled for server");
case ClientInterface.WIRE_PROTOCOL_FORMAT_ERROR:
  throw new IOException("Wire protocol format violation error");
case ClientInterface.AUTHENTICATION_FAILURE_DUE_TO_REJOIN:
throw new IOException("Failed to authenticate to rejoining node");
default :
throw new IOException("Authentication rejected");
}
}
retvals[0]=loginResponse.getInt();
retvals[1]=loginResponse.getLong();
retvals[2]=loginResponse.getLong();
retvals[3]=loginResponse.getInt();
int buildStringLength=loginResponse.getInt();
byte buildStringBytes[]=new byte[buildStringLength];
loginResponse.get(buildStringBytes);
returnArray[2]=new String(buildStringBytes,"UTF-8");
aChannel.configureBlocking(false);
aChannel.socket().setKeepAlive(true);
success=true;
}
  finally {
if (!success) {
aChannel.close();
}
}
return returnArray;
}
