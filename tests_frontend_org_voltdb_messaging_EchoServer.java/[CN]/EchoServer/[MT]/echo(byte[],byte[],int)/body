{
  VoltType type=null;
  if (t[0] == ARRAY_BEGIN) {
    isArray=true;
    return;
  }
 else   if (t[0] == ARRAY_END) {
    isArray=false;
    return;
  }
 else {
    type=VoltType.get(t[0]);
  }
  FastDeserializer fds=new FastDeserializer(buffer);
  short count=1;
  try {
    fs.writeInt(length);
    fs.writeByte(type.getValue());
    if (isArray) {
      count=fds.readShort();
      fs.writeShort(count);
    }
    for (int ii=0; ii < count; ii++) {
switch (type) {
case TINYINT:
        byte b=fds.readByte();
      fs.write(b);
    System.err.println("Type: tiny int " + b);
  break;
case SMALLINT:
short s=fds.readShort();
fs.writeShort(s);
System.err.println("Type: small int " + s);
break;
case INTEGER:
int i=fds.readInt();
fs.writeInt(i);
System.err.println("Type: int " + i);
break;
case BIGINT:
long l=fds.readLong();
fs.writeLong(l);
System.err.println("Type: big int " + l);
break;
case FLOAT:
double f=fds.readDouble();
fs.writeDouble(f);
System.err.println("Type: double " + f);
break;
case STRING:
String str=fds.readString();
int strLen=2;
if (str != null) {
strLen+=str.getBytes("UTF-8").length;
}
fs.writeString(str);
System.err.println("Type: string " + str);
break;
case TIMESTAMP:
fs.writeTimestamp(fds.readTimestamp());
System.err.println("Type: timestamp");
break;
case DECIMAL:
BigDecimal bd=VoltDecimalHelper.deserializeBigDecimal(fds);
VoltDecimalHelper.serializeBigDecimal(bd,fs);
System.err.println("Type: big decimal " + bd);
break;
case VOLTTABLE:
VoltTable table=fds.readObject(VoltTable.class);
System.err.println("Type: table " + table);
fs.writeObject(table);
break;
default :
throw new RuntimeException("FIXME: Unsupported type " + type);
}
}
client.getOutputStream().write(fs.getBytes());
fs.clear();
}
 catch (IOException e) {
e.printStackTrace();
}
}
