{
  super(db,parsedStmt,partitioning);
  if (parsedStmt.m_joinOrder != null) {
    ArrayList<String> tableAliases=new ArrayList<String>();
    HashSet<String> dupCheck=new HashSet<String>();
    for (    String element : parsedStmt.m_joinOrder.trim().split(",")) {
      String alias=element.trim().toUpperCase();
      tableAliases.add(alias);
      if (!dupCheck.add(alias)) {
        StringBuilder sb=new StringBuilder();
        sb.append("The specified join order \"").append(parsedStmt.m_joinOrder);
        sb.append("\" contains a duplicate element \"").append(alias).append("\".");
        throw new PlanningErrorException(sb.toString());
      }
    }
    if (parsedStmt.m_tableAliasMap.size() != tableAliases.size()) {
      StringBuilder sb=new StringBuilder();
      sb.append("The specified join order \"");
      sb.append(parsedStmt.m_joinOrder).append("\" does not contain the correct number of elements\n");
      sb.append("Expected ").append(parsedStmt.m_tableList.size());
      sb.append(" but found ").append(tableAliases.size()).append(" elements.");
      throw new PlanningErrorException(sb.toString());
    }
    Set<String> aliasSet=parsedStmt.m_tableAliasMap.keySet();
    Set<String> specifiedNames=new HashSet<String>(tableAliases);
    specifiedNames.removeAll(aliasSet);
    if (specifiedNames.isEmpty() == false) {
      StringBuilder sb=new StringBuilder();
      sb.append("The specified join order \"");
      sb.append(parsedStmt.m_joinOrder).append("\" contains ");
      int i=0;
      for (      String name : specifiedNames) {
        sb.append(name);
        if (++i != specifiedNames.size()) {
          sb.append(',');
        }
      }
      sb.append(" which ");
      if (specifiedNames.size() == 1) {
        sb.append("doesn't ");
      }
 else {
        sb.append("don't ");
      }
      sb.append("exist in the FROM clause");
      throw new PlanningErrorException(sb.toString());
    }
    if (!isValidJoinOrder(tableAliases)) {
      throw new PlanningErrorException("The specified join order is invalid for the given query");
    }
    m_joinOrders.add(m_parsedStmt.m_joinTree);
  }
 else {
    queueAllJoinOrders();
  }
}
