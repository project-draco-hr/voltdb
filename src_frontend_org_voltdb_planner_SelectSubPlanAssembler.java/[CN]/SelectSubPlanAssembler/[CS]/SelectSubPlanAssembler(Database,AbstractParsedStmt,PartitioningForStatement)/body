{
  super(db,parsedStmt,partitioning);
  if (parsedStmt.joinOrder != null) {
    ArrayList<String> tableNames=new ArrayList<String>();
    HashSet<String> dupCheck=new HashSet<String>();
    for (    String table : parsedStmt.joinOrder.split(",")) {
      tableNames.add(table.trim());
      if (!dupCheck.add(table.trim())) {
        StringBuilder sb=new StringBuilder();
        sb.append("The specified join order \"");
        sb.append(parsedStmt.joinOrder).append("\" contains duplicate tables. ");
        sb.append("Self-joins are not supported yet.");
        throw new RuntimeException(sb.toString());
      }
    }
    if (parsedStmt.tableList.size() != tableNames.size()) {
      StringBuilder sb=new StringBuilder();
      sb.append("The specified join order \"");
      sb.append(parsedStmt.joinOrder).append("\" does not contain the correct number of tables\n");
      sb.append("Expected ").append(parsedStmt.tableList.size());
      sb.append(" but found ").append(tableNames.size()).append(" tables");
      throw new RuntimeException(sb.toString());
    }
    Table tables[]=new Table[tableNames.size()];
    int zz=0;
    ArrayList<Table> tableList=new ArrayList<Table>(parsedStmt.tableList);
    for (int qq=tableNames.size() - 1; qq >= 0; qq--) {
      String name=tableNames.get(qq);
      boolean foundMatch=false;
      for (int ii=0; ii < tableList.size(); ii++) {
        if (tableList.get(ii).getTypeName().equalsIgnoreCase(name)) {
          tables[zz++]=tableList.remove(ii);
          foundMatch=true;
          break;
        }
      }
      if (!foundMatch) {
        StringBuilder sb=new StringBuilder();
        sb.append("The specified join order \"");
        sb.append(parsedStmt.joinOrder).append("\" contains ").append(name);
        sb.append(" which doesn't exist in the FROM clause");
        throw new RuntimeException(sb.toString());
      }
    }
    if (zz != tableNames.size()) {
      StringBuilder sb=new StringBuilder();
      sb.append("The specified join order \"");
      sb.append(parsedStmt.joinOrder).append("\" doesn't contain enough tables ");
      throw new RuntimeException(sb.toString());
    }
    if (!isValidJoinOrder(tableNames)) {
      throw new RuntimeException("The specified join order is invalid for the given query");
    }
    m_parsedStmt.joinTree.m_joinOrder=tables;
    m_joinOrders.add(m_parsedStmt.joinTree);
  }
 else {
    queueAllJoinOrders();
  }
}
