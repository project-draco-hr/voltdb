{
  super(db,parsedStmt,partitioning);
  if (parsedStmt.joinOrder != null) {
    ArrayList<String> tableAliases=new ArrayList<String>();
    HashSet<String> dupCheck=new HashSet<String>();
    for (    String table : parsedStmt.joinOrder.split(",")) {
      tableAliases.add(table.trim());
      if (!dupCheck.add(table.trim())) {
        StringBuilder sb=new StringBuilder();
        sb.append("The specified join order \"");
        sb.append(parsedStmt.joinOrder).append("\" contains duplicate tables. ");
        throw new RuntimeException(sb.toString());
      }
    }
    if (parsedStmt.tableAliasIndexMap.size() != tableAliases.size()) {
      StringBuilder sb=new StringBuilder();
      sb.append("The specified join order \"");
      sb.append(parsedStmt.joinOrder).append("\" does not contain the correct number of tables\n");
      sb.append("Expected ").append(parsedStmt.tableList.size());
      sb.append(" but found ").append(tableAliases.size()).append(" tables");
      throw new RuntimeException(sb.toString());
    }
    if (parsedStmt.tableAliasIndexMap.keySet().containsAll(tableAliases) == false) {
      for (      String name : tableAliases) {
        if (parsedStmt.tableAliasIndexMap.containsKey(name) == false) {
          StringBuilder sb=new StringBuilder();
          sb.append("The specified join order \"");
          sb.append(parsedStmt.joinOrder).append("\" contains ").append(name);
          sb.append(" which doesn't exist in the FROM clause");
          throw new RuntimeException(sb.toString());
        }
      }
    }
    if (!isValidJoinOrder(tableAliases)) {
      throw new RuntimeException("The specified join order is invalid for the given query");
    }
    m_joinOrders.add(m_parsedStmt.joinTree);
  }
 else {
    queueAllJoinOrders();
  }
}
