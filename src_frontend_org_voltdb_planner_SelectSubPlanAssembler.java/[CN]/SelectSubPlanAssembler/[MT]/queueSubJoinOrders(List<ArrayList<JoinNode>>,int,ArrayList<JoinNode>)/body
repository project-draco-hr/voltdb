{
  if (joinOrderListIdx == joinOrderList.size()) {
    assert(!currentJoinOrder.isEmpty());
    JoinTree joinTree=new JoinTree();
    joinTree.m_hasOuterJoin=true;
    JoinNode joinNode=currentJoinOrder.get(0);
    for (int i=1; i < currentJoinOrder.size(); ++i) {
      JoinNode nextNode=currentJoinOrder.get(i);
      boolean replaced=replaceChild(joinNode,nextNode);
      assert(replaced == true);
    }
    joinTree.m_root=joinNode;
    m_joinOrders.add(joinTree);
    return;
  }
  ArrayList<JoinNode> nextTrees=joinOrderList.get(joinOrderListIdx);
  for (  JoinNode headTree : nextTrees) {
    ArrayList<JoinNode> updatedJoinOrder=new ArrayList<JoinNode>();
    for (    JoinNode node : currentJoinOrder) {
      updatedJoinOrder.add((JoinNode)node.clone());
    }
    updatedJoinOrder.add((JoinNode)headTree.clone());
    queueSubJoinOrders(joinOrderList,joinOrderListIdx + 1,updatedJoinOrder);
  }
}
