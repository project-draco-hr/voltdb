{
  assert(m_parsedStmt.joinTree != null);
  List<JoinNode> subTrees=m_parsedStmt.joinTree.extractSubTrees();
  int tableNameIdx=0;
  List<JoinNode> finalSubTrees=new ArrayList<JoinNode>();
  for (int i=subTrees.size() - 1; i >= 0; --i) {
    JoinNode subTree=subTrees.get(i);
    List<JoinNode> subTableNodes=subTree.generateLeafNodesJoinOrder();
    if (subTree.m_joinType == JoinType.INNER) {
      Map<Integer,JoinNode> nodeNameMap=new HashMap<Integer,JoinNode>();
      for (      JoinNode tableNode : subTableNodes) {
        assert(tableNode.m_tableAliasIndex != StmtTableScan.NULL_ALIAS_INDEX);
        if (tableNode.m_id >= 0) {
          nodeNameMap.put(tableNode.m_tableAliasIndex,tableNode);
        }
      }
      List<JoinNode> joinOrderSubNodes=new ArrayList<JoinNode>();
      for (int j=0; j < subTableNodes.size(); ++j) {
        if (subTableNodes.get(j).m_id >= 0) {
          assert(tableNameIdx < tableAliases.size());
          String tableAlias=tableAliases.get(tableNameIdx);
          assert(m_parsedStmt.tableAliasIndexMap.containsKey(tableAlias));
          int aliasIdx=m_parsedStmt.tableAliasIndexMap.get(tableAlias);
          if (!nodeNameMap.containsKey(aliasIdx)) {
            return false;
          }
          joinOrderSubNodes.add(nodeNameMap.get(aliasIdx));
          ++tableNameIdx;
        }
 else {
          joinOrderSubNodes.add(subTableNodes.get(j));
        }
      }
      JoinNode joinOrderSubTree=JoinNode.reconstructJoinTreeFromTableNodes(joinOrderSubNodes);
      AbstractExpression combinedWhereExpr=subTree.getAllInnerJoinFilters();
      if (combinedWhereExpr != null) {
        joinOrderSubTree.m_whereExpr=(AbstractExpression)combinedWhereExpr.clone();
      }
      joinOrderSubTree.m_id=subTree.m_id;
      finalSubTrees.add(0,joinOrderSubTree);
    }
 else {
      for (      JoinNode tableNode : subTableNodes) {
        assert(tableNode.m_tableAliasIndex != StmtTableScan.NULL_ALIAS_INDEX && tableNameIdx < tableAliases.size());
        if (tableNode.m_id >= 0) {
          assert(m_parsedStmt.stmtCache.size() > tableNode.m_tableAliasIndex);
          StmtTableScan tableCache=m_parsedStmt.stmtCache.get(tableNode.m_tableAliasIndex);
          if (!tableAliases.get(tableNameIdx++).equals(tableCache.m_tableAlias)) {
            return false;
          }
        }
      }
      finalSubTrees.add(0,subTree);
    }
  }
  m_parsedStmt.joinTree=JoinNode.reconstructJoinTreeFromSubTrees(finalSubTrees);
  return true;
}
