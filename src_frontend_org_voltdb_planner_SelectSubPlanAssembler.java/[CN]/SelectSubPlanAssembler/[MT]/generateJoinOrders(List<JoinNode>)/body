{
  ArrayList<ArrayList<JoinNode>> permutations=new ArrayList<ArrayList<JoinNode>>();
  for (  JoinNode subTree : subTrees) {
    ArrayList<JoinNode> treePermutations=new ArrayList<JoinNode>();
    if (subTree.m_joinType != JoinType.INNER) {
      treePermutations.add(subTree);
    }
 else {
      JoinNode[] inputNodes=subTree.generateLeafNodesJoinOrder().toArray(new JoinNode[1]);
      JoinNode[] outputNodes=new JoinNode[inputNodes.length];
      List<JoinNode> newTrees=new ArrayList<JoinNode>();
      queueInnerSubJoinOrdersRecursively(inputNodes,outputNodes,0,newTrees);
      Collection<AbstractExpression> combinedExprs=subTree.getAllExpressions();
      AbstractExpression combinedWhereExpr=ExpressionUtil.combine(combinedExprs);
      for (      JoinNode newTree : newTrees) {
        if (combinedWhereExpr != null) {
          newTree.m_whereExpr=(AbstractExpression)combinedWhereExpr.clone();
        }
        newTree.m_id=subTree.m_id;
        treePermutations.add(newTree);
      }
    }
    permutations.add(treePermutations);
  }
  return permutations;
}
