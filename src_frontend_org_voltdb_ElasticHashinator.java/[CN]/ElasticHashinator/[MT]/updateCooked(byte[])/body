{
  ByteArrayOutputStream bos=new ByteArrayOutputStream((int)(compressedData.length * 1.5));
  InflaterOutputStream dos=new InflaterOutputStream(bos);
  try {
    dos.write(compressedData);
    dos.close();
  }
 catch (  IOException e) {
    throw new RuntimeException("Unable to decompress elastic hashinator data.");
  }
  byte[] cookedBytes=bos.toByteArray();
  int numEntries=(cookedBytes.length >= 4 ? ByteBuffer.wrap(cookedBytes).getInt() : 0);
  int tokensSize=4 * numEntries;
  int partitionsSize=4 * numEntries;
  if (numEntries <= 0 || cookedBytes.length != 4 + tokensSize + partitionsSize) {
    throw new RuntimeException("Bad elastic hashinator cooked config size.");
  }
  long tokens=unsafe.allocateMemory(8 * numEntries);
  ByteBuffer tokenBuf=ByteBuffer.wrap(cookedBytes,4,tokensSize);
  ByteBuffer partitionBuf=ByteBuffer.wrap(cookedBytes,4 + tokensSize,partitionsSize);
  int lastToken=Integer.MIN_VALUE;
  for (int ii=0; ii < numEntries; ii++) {
    int token=tokenBuf.getInt();
    Preconditions.checkArgument(token >= lastToken);
    lastToken=token;
    long ptr=tokens + (ii * 8);
    unsafe.putInt(ptr,token);
    final int partitionId=partitionBuf.getInt();
    unsafe.putInt(ptr + 4,partitionId);
  }
  return Pair.of(tokens,numEntries);
}
