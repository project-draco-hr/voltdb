{
  return new Maps.EntrySet<Range<K>,V>(){
    @Override Map<Range<K>,V> map(){
      return SubRangeMapAsMap.this;
    }
    @Override public Iterator<Entry<Range<K>,V>> iterator(){
      if (subRange.isEmpty()) {
        return Iterators.emptyIterator();
      }
      Cut<K> cutToStart=MoreObjects.firstNonNull(entriesByLowerBound.floorKey(subRange.lowerBound),subRange.lowerBound);
      final Iterator<RangeMapEntry<K,V>> backingItr=entriesByLowerBound.tailMap(cutToStart,true).values().iterator();
      return new AbstractIterator<Entry<Range<K>,V>>(){
        @Override protected Entry<Range<K>,V> computeNext(){
          while (backingItr.hasNext()) {
            RangeMapEntry<K,V> entry=backingItr.next();
            if (entry.getLowerBound().compareTo(subRange.upperBound) >= 0) {
              break;
            }
 else             if (entry.getUpperBound().compareTo(subRange.lowerBound) > 0) {
              return Maps.immutableEntry(entry.getKey().intersection(subRange),entry.getValue());
            }
          }
          return endOfData();
        }
      }
;
    }
    @Override public boolean retainAll(    Collection<?> c){
      return removeEntryIf(not(in(c)));
    }
    @Override public int size(){
      return Iterators.size(iterator());
    }
    @Override public boolean isEmpty(){
      return !iterator().hasNext();
    }
  }
;
}
