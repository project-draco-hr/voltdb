{
  roundTripTimeNanos=Math.max(LOWEST_TRACKABLE,roundTripTimeNanos);
  m_invocationsCompleted++;
  if (abort)   m_invocationAborts++;
  if (error)   m_invocationErrors++;
  m_roundTripTimeNanos+=roundTripTimeNanos;
  m_clusterRoundTripTime+=clusterRoundTripTime;
  final long roundTripMicros=Math.max(1,TimeUnit.NANOSECONDS.toMicros(roundTripTimeNanos));
  if (roundTripMicros > m_latencyHistogram.getHighestTrackableValue()) {
    m_latencyHistogram.recordValue(roundTripMicros % m_latencyHistogram.getHighestTrackableValue());
    int count=(int)(roundTripMicros / m_latencyHistogram.getHighestTrackableValue());
    for (int ii=0; ii < count; ii++) {
      m_latencyHistogram.recordValue(m_latencyHistogram.getHighestTrackableValue());
    }
  }
 else {
    m_latencyHistogram.recordValue(roundTripMicros);
  }
}
